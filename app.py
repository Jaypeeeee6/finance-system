from flask import Flask, render_template, request, redirect, url_for, flash, jsonify, send_from_directory, send_file, session, Response, abort
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from flask_socketio import SocketIO, emit, join_room
from flask_mail import Mail, Message
from werkzeug.utils import secure_filename
from functools import wraps
import os
from datetime import datetime, date, timedelta
import calendar
import re
import threading
import time
import random
from werkzeug.security import generate_password_hash, check_password_hash
from models import db, User, UserPermission, PaymentRequest, AuditLog, Notification, PaidNotification, RecurringPaymentSchedule, LateInstallment, InstallmentEditHistory, ReturnReasonHistory, RequestType, Branch, BranchAlias, FinanceAdminNote, ChequeBook, ChequeSerial, ProcurementItemRequest, PersonCompanyOption, ProcurementCategory, ProcurementItem, LocationPriority, CurrentMoneyEntry, DepartmentTemporaryManager
from config import Config
import json
from playwright.sync_api import sync_playwright
from io import BytesIO
import base64
from sqlalchemy import func

# Wrap Flask's flash to centralize permission-denied handling.
# Any code that calls flash("You do not have permission...") will instead
# store the message in session['permission_denied'] so we can render it once
# in the UI and avoid duplicate/stale alerts.
_original_flash = flash
def flash(message, category='message'):
    try:
        if isinstance(message, str) and message.startswith('You do not have permission to access this page'):
            session['permission_denied'] = message
            # Do not call original flash for permission messages
            return
    except Exception:
        pass
    return _original_flash(message, category)

# --- Maintenance mode storage (instance file) ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_INSTANCE_DIR = os.path.join(BASE_DIR, 'instance')
MAINTENANCE_FILE_PATH = os.path.join(DEFAULT_INSTANCE_DIR, 'maintenance.json')
# Feature flags file (for IT-only temporary toggles)
FEATURE_FLAGS_FILE_PATH = os.path.join(DEFAULT_INSTANCE_DIR, 'feature_flags.json')

def read_maintenance_state():
    try:
        with open(MAINTENANCE_FILE_PATH, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return {"enabled": False, "message": "The system is undergoing maintenance. Please try again later."}

def write_maintenance_state(enabled: bool, message: str = None):
    state = read_maintenance_state()
    state['enabled'] = bool(enabled)
    if message is not None:
        state['message'] = message
    os.makedirs(os.path.dirname(MAINTENANCE_FILE_PATH), exist_ok=True)
    with open(MAINTENANCE_FILE_PATH, 'w', encoding='utf-8') as f:
        json.dump(state, f)


def read_feature_flags():
    """Read feature flags used for IT-only temporary toggles."""
    try:
        with open(FEATURE_FLAGS_FILE_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
            if isinstance(data, dict):
                return data
            return {}
    except Exception:
        # Default: all flags off
        return {}


def write_feature_flags(**kwargs):
    """Update feature flags (stored as JSON in the instance folder)."""
    flags = read_feature_flags()
    flags.update({k: bool(v) for k, v in kwargs.items()})
    os.makedirs(os.path.dirname(FEATURE_FLAGS_FILE_PATH), exist_ok=True)
    with open(FEATURE_FLAGS_FILE_PATH, 'w', encoding='utf-8') as f:
        json.dump(flags, f)

# Initialize Flask app
app = Flask(__name__)
app.config.from_object(Config)

# Ensure new procurement item request columns exist before first request (SQLite only)
def ensure_procurement_item_request_columns_exist():
    try:
        import sqlite3
        db_uri = app.config.get('SQLALCHEMY_DATABASE_URI', '') or ''
        # Only attempt SQLite migrations here
        if db_uri.startswith('sqlite:///'):
            db_path = db_uri.replace('sqlite:///', '')
            if os.name == 'nt':
                db_path = db_path.replace('/', '\\')
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(procurement_item_requests)")
            existing_columns = [row[1] for row in cursor.fetchall()]
            if 'requestor_evidence_upload_path' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN requestor_evidence_upload_path TEXT")
                conn.commit()
                print("‚úì Added 'requestor_evidence_upload_path' column to procurement_item_requests table (startup)")
            conn.close()
    except Exception as e:
        # Non-fatal - app can run and show a warning
        print(f"Warning: Could not ensure procurement_item_requests new columns: {e}")

# Run migration immediately at import time so running `python app.py` works on older Flask versions
try:
    ensure_procurement_item_request_columns_exist()
except Exception as _err:
    print(f"Warning: ensure_procurement_item_request_columns_exist failed at startup: {_err}")

# Reduce noisy print output by routing stdout/stderr into Flask logger and raising default log level to INFO.
import logging, sys
class StreamToLogger(object):
    """File-like object that redirects writes to a logger instance."""
    def __init__(self, logger, level):
        self.logger = logger
        self.level = level
        self._buffer = ''
    def write(self, buf):
        # Buffer and emit complete lines
        self._buffer += str(buf)
        while '\n' in self._buffer:
            line, self._buffer = self._buffer.split('\n', 1)
            line = line.rstrip()
            if line:
                try:
                    self.logger.log(self.level, line)
                except Exception:
                    pass
    def flush(self):
        if self._buffer:
            try:
                self.logger.log(self.level, self._buffer)
            except Exception:
                pass
            self._buffer = ''

# Save original stdout/stderr BEFORE redirecting
_original_stdout = sys.stdout
_original_stderr = sys.stderr

# Configure logging with console handler using ORIGINAL stdout
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(_original_stdout)  # Use original stdout, not redirected one
    ],
    force=True  # Override any existing configuration
)

# Set default logger level to INFO so debug prints don't flood the console.
app.logger.setLevel(logging.INFO)

# Ensure Flask logger has a console handler using ORIGINAL stdout
if not any(isinstance(h, logging.StreamHandler) for h in app.logger.handlers):
    console_handler = logging.StreamHandler(_original_stdout)
    console_handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    app.logger.addHandler(console_handler)

# NOW redirect STDOUT/STDERR to the logger (INFO/ERROR respectively)
sys.stdout = StreamToLogger(app.logger, logging.INFO)
sys.stderr = StreamToLogger(app.logger, logging.ERROR)

# Initialize maintenance and feature flags paths now that app is created
try:
    MAINTENANCE_FILE_PATH = os.path.join(app.instance_path, 'maintenance.json')
    FEATURE_FLAGS_FILE_PATH = os.path.join(app.instance_path, 'feature_flags.json')
except Exception:
    # Fallback to default path if app.instance_path not available
    MAINTENANCE_FILE_PATH = os.path.join(DEFAULT_INSTANCE_DIR, 'maintenance.json')
    FEATURE_FLAGS_FILE_PATH = os.path.join(DEFAULT_INSTANCE_DIR, 'feature_flags.json')

# Make timedelta available in templates
from datetime import timedelta
app.jinja_env.globals.update(timedelta=timedelta)

# Timezone conversion function
def utc_to_local(utc_datetime):
    """Convert UTC datetime to Oman time (UTC+4)"""
    if utc_datetime is None:
        return None
    return utc_datetime + timedelta(hours=4)

# Make timezone conversion available in templates
app.jinja_env.globals.update(utc_to_local=utc_to_local)

# Add JSON filter for templates
import json
@app.template_filter('from_json')
def from_json_filter(value):
    """Parse JSON string to Python object"""
    try:
        return json.loads(value) if value else []
    except (json.JSONDecodeError, TypeError):
        return value if value else []

@app.template_filter('format_currency')
def format_currency_filter(value):
    """Format number with commas and 3 decimal places"""
    try:
        num = float(value)
        return f"{num:,.3f}"
    except (ValueError, TypeError):
        return str(value) if value else "0.000"


@app.context_processor
def inject_feature_flags():
    """Expose IT-only feature flags to all templates."""
    flags = read_feature_flags()
    return {
        # Always enable item requests UI (do not hide). Toggle removed from IT settings.
        'show_item_requests_flag': True,
        'show_test_login_flag': bool(flags.get('show_test_login')),
    }


@app.context_processor
def inject_flask_request():
    """Expose the Flask request proxy to templates under `flask_request` to avoid
    shadowing when a view passes a variable named `request` into a template."""
    from flask import request as _flask_request
    return {'flask_request': _flask_request}

def format_recurring_schedule(interval, payment_schedule=None):
    """Format recurring interval into human-readable text"""
    try:
        parts = interval.split(':')
        frequency = parts[0]
        interval_value = int(parts[1])
        
        # Handle the new single date format
        if frequency == 'monthly' and len(parts) > 2 and parts[2] == 'date':
            # Extract the date (format: YYYY-MM-DD)
            date_str = parts[3]
            
            try:
                from datetime import datetime
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                formatted_date = date_obj.strftime('%B %d, %Y')
            except ValueError:
                formatted_date = date_str
            
            # Create the base schedule text
            if interval_value == 1:
                schedule_text = f"Every month starting on {formatted_date}"
            else:
                schedule_text = f"Every {interval_value} months starting on {formatted_date}"
            
            # Check for end date
            end_date_index = parts.index('end') if 'end' in parts else -1
            if end_date_index != -1 and end_date_index + 1 < len(parts):
                end_date = parts[end_date_index + 1]
                try:
                    end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')
                    formatted_end_date = end_date_obj.strftime('%B %d, %Y')
                    schedule_text += f" until {formatted_end_date}"
                except ValueError:
                    schedule_text += f" until {end_date}"
            
            # Add payment schedule information if available
            if payment_schedule:
                try:
                    import json
                    schedule_data = json.loads(payment_schedule)
                    if schedule_data:
                        payment_details = []
                        for payment in schedule_data:
                            date = payment.get('date', '')
                            amount = payment.get('amount', 0)
                            if date and amount > 0:
                                payment_details.append(f"{date}: {amount:.3f} OMR")
                        
                        if payment_details:
                            schedule_text += f"\n\nPayment Schedule:\n" + "\n".join(payment_details)
                except (json.JSONDecodeError, TypeError):
                    pass
            
            return schedule_text
        
        # Handle the old format with specific days (for backward compatibility)
        elif frequency == 'monthly' and len(parts) > 2 and parts[2] == 'days':
            # Extract specific days and dates
            days = parts[3].split(',')
            year = parts[4] if len(parts) > 4 else None
            month = parts[5] if len(parts) > 5 else None
            
            # Format the starting dates using the exact same logic as the preview
            if year and month:
                month_names = ['January', 'February', 'March', 'April', 'May', 'June', 
                             'July', 'August', 'September', 'October', 'November', 'December']
                # The stored month is 1-based (1-12), so convert to 0-based for array indexing
                month_int = int(month) - 1  # Convert 1-based to 0-based
                month_name = month_names[month_int] if 0 <= month_int <= 11 else str(month)
                starting_dates = [f"{month_name} {day}, {year}" for day in days]
                starting_text = ", ".join(starting_dates)
            else:
                starting_text = f"days {', '.join(days)}"
            
            # Create the base schedule text using the exact same format as the preview
            if interval_value == 1:
                schedule_text = f"Every month starting on {starting_text}"
            else:
                schedule_text = f"Every {interval_value} months starting on {starting_text}"
            
            # Check for end date
            end_date_index = parts.index('end') if 'end' in parts else -1
            if end_date_index != -1 and end_date_index + 1 < len(parts):
                end_date = parts[end_date_index + 1]
                try:
                    from datetime import datetime
                    end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')
                    formatted_end_date = end_date_obj.strftime('%B %d, %Y')
                    schedule_text += f" until {formatted_end_date}"
                except ValueError:
                    schedule_text += f" until {end_date}"
            
            # Add payment schedule information if available
            if payment_schedule:
                try:
                    import json
                    schedule_data = json.loads(payment_schedule)
                    if schedule_data:
                        payment_details = []
                        for payment in schedule_data:
                            date = payment.get('date', '')
                            amount = payment.get('amount', 0)
                            if date and amount > 0:
                                payment_details.append(f"{date}: {amount:.3f} OMR")
                        
                        if payment_details:
                            schedule_text += f"\n\nPayment Schedule:\n" + "\n".join(payment_details)
                except (json.JSONDecodeError, TypeError):
                    pass
            
            return schedule_text
        
        # Handle legacy formats
        if frequency == 'daily':
            if interval_value == 1:
                return "Daily"
            else:
                return f"Every {interval_value} days"
        elif frequency == 'weekly':
            if interval_value == 1:
                return "Weekly"
            else:
                return f"Every {interval_value} weeks"
        elif frequency == 'monthly':
            if interval_value == 1:
                return "Monthly"
            else:
                return f"Every {interval_value} months"
        elif frequency == 'quarterly':
            if interval_value == 1:
                return "Quarterly"
            else:
                return f"Every {interval_value} quarters"
        elif frequency == 'yearly':
            if interval_value == 1:
                return "Yearly"
            else:
                return f"Every {interval_value} years"
    except (ValueError, IndexError):
        return "Invalid schedule"

# Make the function available in templates
app.jinja_env.globals.update(format_recurring_schedule=format_recurring_schedule)

# Initialize database
db.init_app(app)

# Initialize Flask-Mail
mail = Mail(app)

# Initialize SocketIO for real-time updates
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading')

@socketio.on('connect')
def handle_connect():
    """Handle client connection"""
    print(f'Client connected: {request.sid}')

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    print(f'Client disconnected: {request.sid}')

@socketio.on('join_room')
def handle_join_room(data):
    """Handle client joining a room"""
    room = data.get('room')
    if room and current_user.is_authenticated:
        if room == 'finance_admin' and current_user.role in ['Finance Staff', 'Finance Admin']:
            join_room(room)
            print(f'User {current_user.username} joined room: {room}')
        elif room == 'all_users':
            join_room(room)
            print(f'User {current_user.username} joined room: {room}')

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

# Create upload folder if it doesn't exist
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
os.makedirs(app.config['CHEQUE_UPLOAD_FOLDER'], exist_ok=True)


@login_manager.user_loader
def load_user(user_id):
    """Load user for Flask-Login"""
    return User.query.get(int(user_id))

# --- Idle timeout enforcement ---
@app.before_request
def enforce_idle_timeout():
    try:
        # Skip static files, socket traffic, and login/logout routes
        if request.path.startswith('/static') or request.path.startswith('/socket.io'):
            return None
        if request.endpoint in ['login', 'logout', 'check_tab_session']:
            return None
        # Allow maintenance endpoints and health checks to pass through
        if request.path.startswith('/maintenance') or request.path.startswith('/health'):
            return None

        if current_user.is_authenticated:
            now_ts = datetime.utcnow().timestamp()
            last_activity = session.get('last_activity')
            session_start = session.get('session_start')
            tab_session_id = session.get('tab_session_id')
            
            # If session doesn't have last_activity, session_start, or tab_session_id, it's a stale session
            # This can happen if Flask-Login restored a user from an old session cookie or a new tab was opened
            # Log them out immediately and clear all session data
            if last_activity is None or session_start is None or tab_session_id is None:
                try:
                    logout_user()
                except Exception:
                    pass
                # Clear all session data including Flask-Login's user_id
                session.clear()
                flash('Your session has expired. Please log in again.', 'warning')
                return redirect(url_for('login'))
            
            idle_seconds = now_ts - float(last_activity)
            # 10 minutes = 600 seconds
            if idle_seconds > 600:
                # Invalidate session and force logout
                try:
                    logout_user()
                except Exception:
                    pass
                session.clear()
                flash('You were logged out due to inactivity.', 'warning')
                return redirect(url_for('login'))
            # Update last activity timestamp for active user
            session['last_activity'] = now_ts
    except Exception:
        # Fail-open: do not block the request on any error here
        return None

# --- Maintenance gate ---
@app.before_request
def maintenance_gate():
    try:
        state = read_maintenance_state()
        if not state.get('enabled'):
            return None

        # Allow static and socket endpoints
        if request.path.startswith('/static') or request.path.startswith('/socket.io'):
            return None

        # Allow maintenance endpoints so IT can toggle and for public status
        if request.path.startswith('/maintenance'):
            return None

        # Allow health checks if any
        if request.path.startswith('/health'):
            return None

        # CRITICAL: Allow login-related routes so IT users can log in to disable maintenance
        # This prevents the lockout scenario where maintenance is enabled and no one can log in
        if request.path in ['/login', '/logout', '/validate_credentials', '/verify_pin']:
            return None

        # Allow IT department users or the user named "Super Admin" to proceed
        if current_user.is_authenticated and (getattr(current_user, 'department', None) == 'IT' or getattr(current_user, 'name', None) == 'Super Admin'):
            return None

        # For everyone else, show maintenance page
        message = state.get('message') or 'The system is undergoing maintenance. Please try again later.'
        return render_template('maintenance.html', message=message), 503
    except Exception:
        # Fail-open on any error to avoid locking out IT unintentionally
        return None

# --- Maintenance endpoints (IT only) ---
def it_department_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if not current_user.is_authenticated:
            return redirect(url_for('login'))
        # Allow actions by IT department users or the user named "Super Admin"
        if not (getattr(current_user, 'department', None) == 'IT' or getattr(current_user, 'name', None) == 'Super Admin'):
            flash('Only IT department or Super Admin can perform this action.', 'danger')
            return redirect(url_for('dashboard'))
        return f(*args, **kwargs)
    return wrapper

@app.route('/maintenance/status')
@login_required
@it_department_required
def maintenance_status():
    return jsonify(read_maintenance_state())

@app.route('/maintenance/public_status')
def maintenance_public_status():
    state = read_maintenance_state()
    return jsonify({ 'enabled': bool(state.get('enabled')) })

@app.route('/maintenance/enable', methods=['POST'])
@login_required
@it_department_required
def maintenance_enable():
    message = request.form.get('message') or request.json.get('message') if request.is_json else None
    write_maintenance_state(True, message)
    log_action('Enabled maintenance mode')
    try:
        socketio.emit('maintenance_update', { 'enabled': True, 'message': message or '' }, broadcast=True)
    except Exception:
        pass
    flash('Maintenance mode enabled.', 'warning')
    return redirect(request.referrer or url_for('dashboard'))

@app.route('/maintenance/disable', methods=['POST'])
@login_required
@it_department_required
def maintenance_disable():
    write_maintenance_state(False)
    log_action('Disabled maintenance mode')
    try:
        socketio.emit('maintenance_update', { 'enabled': False }, broadcast=True)
    except Exception:
        pass
    flash('Maintenance mode disabled.', 'success')
    return redirect(request.referrer or url_for('dashboard'))


@app.route('/it/tools/toggle_item_requests', methods=['POST'])
@login_required
@it_department_required
def it_toggle_item_requests():
    """IT-only toggle for showing/hiding Item Requests buttons and New Item Request."""
    flags = read_feature_flags()
    current = bool(flags.get('show_item_requests'))
    new_value = not current
    write_feature_flags(show_item_requests=new_value)
    message = (
        'Item Requests buttons are now visible for testing.'
        if new_value else
        'Item Requests buttons are now hidden.'
    )
    if request.is_json or request.headers.get('X-Requested-With') == 'fetch':
        return jsonify({'success': True, 'enabled': new_value, 'message': message})
    flash(message, 'success')
    return redirect(request.referrer or url_for('it_dashboard'))


@app.route('/it/tools/toggle_login_testing', methods=['POST'])
@login_required
@it_department_required
def it_toggle_login_testing():
    """IT-only toggle for showing/hiding the Login for Testing button on the login page."""
    flags = read_feature_flags()
    current = bool(flags.get('show_test_login'))
    new_value = not current
    write_feature_flags(show_test_login=new_value)
    message = (
        'Login for Testing button is now visible on the login page.'
        if new_value else
        'Login for Testing button is now hidden on the login page.'
    )
    if request.is_json or request.headers.get('X-Requested-With') == 'fetch':
        return jsonify({'success': True, 'enabled': new_value, 'message': message})
    flash(message, 'success')
    return redirect(request.referrer or url_for('it_dashboard'))


def role_required(*roles):
    """Decorator to check if user has required role"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                return redirect(url_for('login'))
            if current_user.role not in roles:
                # Do not flash here to avoid duplicate/stale alerts.
                # Abort with 403 so a single, central handler can present a clear message.
                abort(403)
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def log_action(action):
    """Helper function to log user actions"""
    if current_user.is_authenticated:
        log = AuditLog(
            user_id=current_user.user_id, 
            action=action,
            username_snapshot=current_user.username
        )
        db.session.add(log)
        db.session.commit()


def get_status_priority_order():
    """
    Returns SQLAlchemy case expression for ordering payment requests by status priority.
    Priority order:
    1. Returned to Requestor
    2. Returned to Manager
    3. Pending Manager Approval
    4. On Hold
    5. Pending Finance Approval
    6. Proof Pending
    7. Proof Sent
    8. Proof Rejected
    9. Recurring
    10. Completed
    11. Rejected (Rejected by Manager, Rejected by Finance, Proof Rejected)
    """
    return db.case(
        (PaymentRequest.status == 'Returned to Requestor', 1),
        (PaymentRequest.status == 'Returned to Manager', 2),
        (PaymentRequest.status == 'Pending Manager Approval', 3),
        (PaymentRequest.status == 'On Hold', 4),
        (PaymentRequest.status == 'Pending Finance Approval', 5),
        (PaymentRequest.status == 'Proof Pending', 6),
        (PaymentRequest.status == 'Proof Sent', 7),
        (PaymentRequest.status == 'Proof Rejected', 8),
        (PaymentRequest.status == 'Recurring', 9),
        (PaymentRequest.status == 'Completed', 10),
        (PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']), 11),
        else_=99  # Any other status goes to the end
    )


def get_all_tab_datetime_order():
    """
    Secondary ordering for the All Requests tab by per-status recency (most recent first):
    - Completed: finance_approval_end_time ‚Üí completion_date ‚Üí approval_date ‚Üí updated_at ‚Üí created_at
    - Pending Finance Approval: finance_approval_start_time ‚Üí manager_approval_end_time ‚Üí updated_at ‚Üí created_at
    - Pending Manager Approval: manager_approval_start_time ‚Üí updated_at ‚Üí created_at
    - Proof Pending: updated_at ‚Üí finance_approval_end_time ‚Üí created_at
    - Proof Sent: updated_at ‚Üí created_at
    - Proof Rejected: finance_rejection_date ‚Üí updated_at ‚Üí created_at
    - Recurring: updated_at ‚Üí created_at
    - Rejected by Manager: manager_rejection_date ‚Üí updated_at ‚Üí created_at
    - Rejected by Finance: finance_rejection_date ‚Üí updated_at ‚Üí created_at
    - Default: created_at
    """
    return db.case(
        (
            PaymentRequest.status == 'Completed',
            db.func.coalesce(
                PaymentRequest.finance_approval_end_time,
                PaymentRequest.completion_date,
                PaymentRequest.approval_date,
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Pending Finance Approval',
            db.func.coalesce(
                PaymentRequest.finance_approval_start_time,
                PaymentRequest.manager_approval_end_time,
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Pending Manager Approval',
            db.func.coalesce(
                PaymentRequest.manager_approval_start_time,
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'On Hold',
            db.func.coalesce(
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Proof Pending',
            db.func.coalesce(
                PaymentRequest.updated_at,
                PaymentRequest.finance_approval_end_time,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Proof Sent',
            db.func.coalesce(
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Proof Rejected',
            db.func.coalesce(
                PaymentRequest.finance_rejection_date,
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Recurring',
            db.func.coalesce(
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Rejected by Manager',
            db.func.coalesce(
                PaymentRequest.manager_rejection_date,
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        (
            PaymentRequest.status == 'Rejected by Finance',
            db.func.coalesce(
                PaymentRequest.finance_rejection_date,
                PaymentRequest.updated_at,
                PaymentRequest.created_at
            )
        ),
        else_=PaymentRequest.created_at
    ).desc()


def get_completed_datetime_order():
    """Ordering for completed requests: finance_approval_end_time ‚Üí completion_date ‚Üí approval_date ‚Üí updated_at ‚Üí created_at (desc)."""
    return db.func.coalesce(
        PaymentRequest.finance_approval_end_time,
        PaymentRequest.completion_date,
        PaymentRequest.approval_date,
        PaymentRequest.updated_at,
        PaymentRequest.created_at
    ).desc()


def get_rejected_datetime_order():
    """Ordering for rejected requests: pick manager/finance rejection date ‚Üí updated_at ‚Üí created_at (desc)."""
    return db.func.coalesce(
        PaymentRequest.finance_rejection_date,
        PaymentRequest.manager_rejection_date,
        PaymentRequest.updated_at,
        PaymentRequest.created_at
    ).desc()


def get_recurring_datetime_order():
    """Ordering for recurring requests: updated_at ‚Üí created_at (desc)."""
    return db.func.coalesce(
        PaymentRequest.updated_at,
        PaymentRequest.created_at
    ).desc()


def get_item_request_status_priority(req):
    """
    Returns priority number for item request status ordering.
    Priority order:
    1. Pending Manager Approval
    2. On Hold (same priority as Pending Manager Approval)
    3. Pending Procurement Manager Approval
    4. Assigned to Procurement
    5. Completed
    6. Rejected (Rejected by Manager, Rejected by Procurement Manager)
    """
    status_priority = {
        'Pending Manager Approval': 1,
        'On Hold': 1,  # Same priority as Pending Manager Approval
        'Pending Procurement Manager Approval': 2,
        'Assigned to Procurement': 3,
        'Completed': 4,
        'Rejected by Manager': 5,
        'Rejected by Procurement Manager': 5,
    }
    return status_priority.get(req.status, 99)


def get_item_request_datetime_for_sorting(req):
    """
    Returns datetime for sorting item requests by recency (most recent first).
    For each status, the request with the most recent update (most recently had that status) should be at the top.
    We prioritize updated_at since it's automatically updated whenever the status changes.
    """
    # Always prioritize updated_at first, as it reflects when the request last changed to this status
    # Fallback to status-specific dates, then created_at
    if req.updated_at:
        return req.updated_at
    
    # Fallback to status-specific dates if updated_at is not available
    if req.status == 'Completed':
        dt = req.completion_date
        if dt:
            return dt if isinstance(dt, datetime) else datetime.combine(dt, datetime.min.time())
        dt = req.procurement_manager_approval_date
        if dt:
            return datetime.combine(dt, datetime.min.time()) if isinstance(dt, date) else dt
    elif req.status == 'Pending Procurement Manager Approval':
        if req.manager_approval_end_time:
            return req.manager_approval_end_time
    elif req.status == 'Pending Manager Approval':
        if req.manager_approval_start_time:
            return req.manager_approval_start_time
    elif req.status == 'Assigned to Procurement':
        if req.assignment_date:
            return req.assignment_date
    elif req.status == 'Rejected by Manager':
        dt = req.manager_rejection_date
        if dt:
            return datetime.combine(dt, datetime.min.time()) if isinstance(dt, date) else dt
    elif req.status == 'Rejected by Procurement Manager':
        dt = req.procurement_manager_rejection_date
        if dt:
            return datetime.combine(dt, datetime.min.time()) if isinstance(dt, date) else dt
    
    # Final fallback to created_at
    return req.created_at


def send_pin_email(user_email, user_name, pin):
    """Send PIN to user's email"""
    try:
        sender_name = app.config.get('PIN_SENDER_NAME', 'Payment System - PIN')
        msg = Message(
            subject='Your Login PIN - Payment Request System',
            sender=(sender_name, app.config['MAIL_DEFAULT_SENDER']),
            recipients=[user_email]
        )
        
        msg.html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body {{
                    font-family: Arial, sans-serif;
                    line-height: 1.6;
                    color: #333;
                }}
                .container {{
                    max-width: 600px;
                    margin: 0 auto;
                    padding: 20px;
                    background-color: #f9f9f9;
                }}
                .header {{
                    background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
                    color: white;
                    padding: 30px;
                    text-align: center;
                    border-radius: 10px 10px 0 0;
                }}
                .content {{
                    background-color: white;
                    padding: 30px;
                    border-radius: 0 0 10px 10px;
                }}
                .pin-box {{
                    background-color: #f0f0f0;
                    border: 2px solid #2c3e50;
                    border-radius: 10px;
                    padding: 20px;
                    text-align: center;
                    margin: 20px 0;
                }}
                .pin {{
                    font-size: 36px;
                    font-weight: bold;
                    color: #2c3e50;
                    letter-spacing: 10px;
                }}
                .warning {{
                    background-color: #fff3cd;
                    border-left: 4px solid #ffc107;
                    padding: 15px;
                    margin: 20px 0;
                }}
                .footer {{
                    text-align: center;
                    color: #666;
                    margin-top: 20px;
                    font-size: 12px;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üîê Login PIN</h1>
                    <p>Payment Request Management System</p>
                </div>
                <div class="content">
                    <p>Hello <strong>{user_name}</strong>,</p>
                    <p>Your login PIN has been generated. Please use this PIN to complete your login:</p>
                    
                    <div class="pin-box">
                        <div class="pin">{pin}</div>
                    </div>
                    
                    <div class="warning">
                        <strong>‚ö†Ô∏è Important:</strong>
                        <ul>
                            <li>This PIN is valid for <strong>2 minutes</strong></li>
                            <li>Do not share this PIN with anyone</li>
                            <li>If you didn't request this PIN, please contact IT immediately</li>
                        </ul>
                    </div>
                    
                    <p>If you're having trouble logging in, please contact the IT department for assistance.</p>
                </div>
                <div class="footer">
                    <p>This is an automated message. Please do not reply to this email.</p>
                    <p>&copy; 2024 Payment Request Management System</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        msg.body = f"""
        Hello {user_name},

        Your login PIN has been generated. Please use this PIN to complete your login:

        PIN: {pin}

        IMPORTANT:
        - This PIN is valid for 2 minutes
        - Do not share this PIN with anyone
        - If you didn't request this PIN, please contact IT immediately

        If you're having trouble logging in, please contact the IT department for assistance.

        This is an automated message. Please do not reply to this email.
        
        ¬© 2024 Payment Request Management System
        """
        
        mail.send(msg)
        return True, "PIN sent successfully"
    except Exception as e:
        app.logger.error(f"Failed to send PIN email: {str(e)}")
        return False, f"Failed to send email: {str(e)}"


def send_notification_email(user, title, message, request_id=None):
    """Send status/approval notification emails (non-PIN)."""
    if not user or not user.email:
        return False, "User has no email"
    
    sender_name = app.config.get('NOTIFICATION_SENDER_NAME', 'Payment System - Notifications')
    subject = title
    
    # Minimal HTML with request reference when available
    html_body = f"""
    <html>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
        <h3 style="margin-bottom: 8px;">{title}</h3>
        <p style="margin-top: 0; white-space: pre-line;">{message}</p>
        {'<p style="color: #555;">Request #: ' + str(request_id) + '</p>' if request_id else ''}
        <p style="font-size: 12px; color: #777;">This is an automated message. Please do not reply.</p>
    </body>
    </html>
    """
    
    text_body = f"""{title}

{message}
{f"Request #: {request_id}" if request_id else ""}

This is an automated message. Please do not reply."""
    
    try:
        msg = Message(
            subject=subject,
            sender=(sender_name, app.config['MAIL_DEFAULT_SENDER']),
            recipients=[user.email]
        )
        msg.body = text_body
        msg.html = html_body
        mail.send(msg)
        return True, "Notification email sent"
    except Exception as e:
        app.logger.error(f"Failed to send notification email to {user.email}: {str(e)}")
        return False, f"Failed to send email: {str(e)}"


def create_notification(user_id, title, message, notification_type, request_id=None, item_request_id=None):
    """Helper function to create notifications"""
    print(f"DEBUG: Creating notification for user_id: {user_id}")
    print(f"   - title: {title}")
    print(f"   - message: {message}")
    print(f"   - notification_type: {notification_type}")
    print(f"   - request_id: {request_id}")
    print(f"   - item_request_id: {item_request_id}")
    
    notification = Notification(
        user_id=user_id,
        title=title,
        message=message,
        notification_type=notification_type,
        request_id=request_id,
        item_request_id=item_request_id
    )
    db.session.add(notification)
    db.session.commit()
    
    print(f"DEBUG: Notification created successfully with ID: {notification.notification_id}")
    
    # Emit real-time socket events for the specific user (or all users if user_id is None)
    try:
        payload = {
            'title': notification.title,
            'message': notification.message,
            'type': notification.notification_type,
            'request_id': notification.request_id,
            'item_request_id': notification.item_request_id,
            'notification_id': notification.notification_id
        }
        if user_id:
            # Emit to the specific user's room so their unread count updates immediately
            socketio.emit('new_notification', payload, room=f'user_{user_id}')
            socketio.emit('notification_update', {
                'action': 'new_notification',
                'type': notification.notification_type,
                'user_id': user_id
            }, room=f'user_{user_id}')
        else:
            # Broadcast to all users when there is no specific user target
            socketio.emit('new_notification', payload, room='all_users')
            socketio.emit('notification_update', {
                'action': 'new_notification',
                'type': notification.notification_type
            }, room='all_users')
    except Exception as e:
        # Don't let socket errors break notification creation
        try:
            app.logger.error(f"Failed to emit WebSocket for notification {notification.notification_id}: {e}")
        except:
            pass
    
    # Email sending disabled globally except for PIN emails (handled separately).
    # Keep the set here in case we re-enable specific types in the future.
    email_notification_types = set()
    if notification_type in email_notification_types:
        user = User.query.get(user_id)
        if user and user.email:
            # For request_returned, only notify managers (avoid emailing requestor)
            if notification_type == 'request_returned':
                manager_roles = {'Department Manager', 'GM', 'Operation Manager'}
                if user.role not in manager_roles:
                    return notification
            # For new_submission, email only manager-level recipients (skip submitter)
            if notification_type == 'new_submission':
                manager_roles = {'Department Manager', 'GM', 'Operation Manager'}
                if user.role not in manager_roles:
                    # Allow IT Department Manager (same role, IT dept) via role check above
                    return notification
            success, email_msg = send_notification_email(user, title, message, request_id)
            if not success:
                app.logger.error(f"Failed to send notification email for user_id={user_id}, type={notification_type}: {email_msg}")
    
    return notification

def check_and_notify_low_balance(available_balance):
    """Check if balance is low and send notification to procurement managers"""
    LOW_BALANCE_THRESHOLD = 2500.0
    
    if available_balance is None:
        return
    
    if available_balance <= LOW_BALANCE_THRESHOLD:
        # Get all Procurement Department Managers
        procurement_managers = User.query.filter(
            User.department == 'Procurement',
            User.role == 'Department Manager'
        ).all()
        
        # Check if notification was already sent in the last 24 hours to avoid spam
        yesterday = datetime.utcnow() - timedelta(hours=24)
        
        for manager in procurement_managers:
            # Check if a low balance notification was already sent recently
            existing_notification = Notification.query.filter(
                Notification.user_id == manager.user_id,
                Notification.notification_type == 'low_balance_alert',
                Notification.created_at >= yesterday
            ).first()
            
            if not existing_notification:
                # Send notification
                notification = create_notification(
                    user_id=manager.user_id,
                    title="‚ö†Ô∏è Low Balance Alert",
                    message=f"Your available balance is running low (OMR {available_balance:.3f}). Please request money from the Finance Department as soon as possible to avoid service interruptions.",
                    notification_type='low_balance_alert',
                    request_id=None,
                    item_request_id=None
                )
                log_action(f"Low balance notification sent to Procurement Manager: {manager.name} (Balance: OMR {available_balance:.3f})")
                
                # Broadcast real-time notification via WebSocket
                try:
                    socketio.emit('new_notification', {
                        'title': notification.title,
                        'message': notification.message,
                        'type': notification.notification_type,
                        'user_id': manager.user_id
                    }, room=f'user_{manager.user_id}')
                    
                    # Also emit a general update event to trigger notification count updates
                    socketio.emit('notification_update', {
                        'action': 'new_notification',
                        'type': notification.notification_type,
                        'user_id': manager.user_id
                    }, room=f'user_{manager.user_id}')
                except Exception as e:
                    # Silently handle WebSocket errors - don't log to audit
                    pass

def get_department_text_for_notification(request):
    """Generate department text for notification messages.
    If request.department differs from request.user.department, mention both.
    Otherwise, just mention the requestor's department."""
    requestor_dept = request.user.department if request.user else 'Unknown'
    request_dept = request.department if request.department else requestor_dept
    
    if requestor_dept.lower() != request_dept.lower():
        return f"from {requestor_dept} and created for {request_dept}"
    else:
        return f"from {requestor_dept}"

def get_authorized_manager_approvers(request):
    """Get all users who are authorized to approve this request at the manager stage.
    This mirrors the authorization logic in manager_approve_request."""
    authorized_users = []
    
    # If per-request temporary manager is assigned (IT feature), only that user is authorized
    if request.temporary_manager_id:
        temp_manager = User.query.get(request.temporary_manager_id)
        if temp_manager:
            authorized_users.append(temp_manager)
            print(f"DEBUG: Found per-request temporary manager: {temp_manager.name} (ID: {temp_manager.user_id})")
        return authorized_users

    # If a department-level temporary manager is assigned, include that user among authorized approvers
    # Only include temporary managers assigned for "Finance Payment Request" or "Both Payment and Item Request"
    # NOT those assigned only for "Procurement Item Request"
    try:
        req_dept = (request.department or '').strip()
        if req_dept:
            # Query all temporary managers for payment requests, then filter by department (case-insensitive)
            dept_temp = None
            for dt in DepartmentTemporaryManager.query.filter(
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all():
                dt_dept = (dt.department or '').strip()
                if dt_dept.lower() == req_dept.lower():
                    dept_temp = dt
                    break
        else:
            dept_temp = None
    except Exception:
        dept_temp = None
    if dept_temp:
        temp_manager = User.query.get(dept_temp.temporary_manager_id)
        if temp_manager:
            authorized_users.append(temp_manager)
            print(f"DEBUG: Added department-level temporary manager for payment request (dept: {req_dept}, request_type: {dept_temp.request_type}): {temp_manager.name} (ID: {temp_manager.user_id})")
    
    # No temporary manager, use standard authorization checks
    
    # Hard rule: Requests submitted by GM/CEO/Operation Manager can ONLY be approved by Abdalaziz
    # Abdalaziz is their assigned manager and should receive notifications
    if request.user.role in ['GM', 'CEO', 'Operation Manager']:
        abdalaziz = User.query.filter_by(name='Abdalaziz Al-Brashdi').first()
        if abdalaziz:
            authorized_users.append(abdalaziz)
            print(f"DEBUG: Added Abdalaziz for GM/CEO/Operation Manager submitter (assigned manager)")
    else:
        # General Manager - can approve all requests (except GM/CEO/Operation Manager)
        gm_users = User.query.filter_by(role='GM').all()
        for user in gm_users:
            if user.user_id != request.user_id:  # Can't approve own request
                authorized_users.append(user)
                print(f"DEBUG: Added GM: {user.name}")
        
        # Operation Manager - can approve all requests (except GM/CEO/Operation Manager)
        op_manager_users = User.query.filter_by(role='Operation Manager').all()
        for user in op_manager_users:
            if user.user_id != request.user_id:  # Can't approve own request
                authorized_users.append(user)
                print(f"DEBUG: Added Operation Manager: {user.name}")
        
        # Check if submitter has a manager_id (direct manager relationship)
        if request.user.manager_id:
            manager = User.query.get(request.user.manager_id)
            if manager and manager.user_id != request.user_id:
                if manager not in authorized_users:
                    authorized_users.append(manager)
                    print(f"DEBUG: Added direct manager: {manager.name} (ID: {manager.user_id})")
        
        # Special case: General Manager can approve Department Manager requests
        if request.user.role == 'Department Manager':
            gm_users = User.query.filter_by(role='GM').all()
            for user in gm_users:
                if user not in authorized_users:
                    authorized_users.append(user)
                    print(f"DEBUG: Added GM for Department Manager request: {user.name}")
            
            # Operation Manager can also approve Department Manager requests
            op_manager_users = User.query.filter_by(role='Operation Manager').all()
            for user in op_manager_users:
                if user not in authorized_users:
                    authorized_users.append(user)
                    print(f"DEBUG: Added Operation Manager for Department Manager request: {user.name}")
        
        # Special case: Abdalaziz can approve GM, CEO, Finance Staff, and Operation Manager requests
        # (But GM/CEO/Operation Manager requests are handled above, so this covers Finance Staff)
        # Abdalaziz is the assigned manager for Finance Staff and should receive notifications
        if request.user.role == 'Finance Staff':
            abdalaziz = User.query.filter_by(name='Abdalaziz Al-Brashdi').first()
            if abdalaziz and abdalaziz not in authorized_users:
                authorized_users.append(abdalaziz)
                print(f"DEBUG: Added Abdalaziz for Finance Staff request (assigned manager)")
        
        # Special case: Operation Manager can approve Operation department and Project requests
        if (request.user.department == 'Operation' or request.user.department == 'Project') and \
           request.user.role != 'Operation Manager':
            op_manager_users = User.query.filter_by(role='Operation Manager').all()
            for user in op_manager_users:
                if user.user_id != request.user_id and user not in authorized_users:
                    authorized_users.append(user)
                    print(f"DEBUG: Added Operation Manager for Operation/Project department: {user.name}")
        
        # Special case: Finance Admin can approve Finance department requests
        if request.user.department == 'Finance' and request.user.role != 'Finance Admin':
            finance_admins = User.query.filter_by(role='Finance Admin').all()
            for user in finance_admins:
                if user.user_id != request.user_id and user not in authorized_users:
                    authorized_users.append(user)
                    print(f"DEBUG: Added Finance Admin for Finance department: {user.name}")
        
        # Special case: Department Manager can approve same department requests
        dept_managers = User.query.filter_by(
            role='Department Manager',
            department=request.user.department
        ).all()
        for user in dept_managers:
            if user.user_id != request.user_id and user not in authorized_users:
                authorized_users.append(user)
                print(f"DEBUG: Added Department Manager for same department: {user.name}")
    
    # Remove duplicates (in case a user was added multiple times)
    seen = set()
    unique_authorized = []
    for user in authorized_users:
        if user.user_id not in seen:
            seen.add(user.user_id)
            unique_authorized.append(user)
    
    print(f"DEBUG: Total authorized manager approvers: {len(unique_authorized)}")
    return unique_authorized

def get_authorized_manager_approvers_for_item_request(item_request):
    """Get all users who are authorized to approve this item request at the manager stage."""
    authorized_users = []
    
    # If a department-level temporary manager is assigned for this item_request.department, include that user among authorized approvers
    # Only include temporary managers assigned for "Procurement Item Request" or "Both Payment and Item Request"
    # NOT those assigned only for "Finance Payment Request"
    try:
        req_dept = (item_request.department or '').strip()
        if req_dept:
            # Query all temporary managers for item requests, then filter by department (case-insensitive)
            dept_temp = None
            for dt in DepartmentTemporaryManager.query.filter(
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all():
                dt_dept = (dt.department or '').strip()
                if dt_dept.lower() == req_dept.lower():
                    dept_temp = dt
                    break
        else:
            dept_temp = None
    except Exception:
        dept_temp = None
    if dept_temp:
        temp_manager = User.query.get(dept_temp.temporary_manager_id)
        if temp_manager:
            authorized_users.append(temp_manager)
            print(f"DEBUG: Added department-level temporary manager for item request (dept: {req_dept}, request_type: {dept_temp.request_type}): {temp_manager.name} (ID: {temp_manager.user_id})")
    
    # Get the requestor user - explicitly load from database if needed
    if not item_request.user_id:
        return authorized_users
    
    requestor = User.query.get(item_request.user_id)
    if not requestor:
        log_action(f"WARNING: User not found for item request #{item_request.id} with user_id {item_request.user_id}")
        return authorized_users
    
    # Special rule: If a Branch Manager or Supervisor (in Branch department) submits an item request,
    # include Branch Inventory Officer(s) among the authorized manager approvers.
    # Do NOT short-circuit other approvers ‚Äî GM and Operation Manager should still be included.
    try:
        if requestor.role in ['Branch Manager', 'Supervisor'] and (requestor.department or '').strip().lower() == 'branch':
            branch_inventory_officers = User.query.filter_by(role='Branch Inventory Officer').all()
            for bio in branch_inventory_officers:
                if bio.user_id != requestor.user_id:
                    authorized_users.append(bio)
            # Intentionally do NOT return here; allow GM/Operation Manager and other fallbacks to be added below.
    except Exception as e:
        app.logger.warning(f"Error applying Branch Inventory Officer special case for item request approvers: {e}")
    
    # Hard rule: Requests submitted by GM/CEO/Operation Manager can ONLY be approved by Abdalaziz
    if requestor.role in ['GM', 'CEO', 'Operation Manager']:
        abdalaziz = User.query.filter_by(name='Abdalaziz Al-Brashdi').first()
        if abdalaziz:
            authorized_users.append(abdalaziz)
    else:
        # General Manager - can approve all requests (except GM/CEO/Operation Manager)
        gm_users = User.query.filter_by(role='GM').all()
        for user in gm_users:
            if user.user_id != requestor.user_id:
                authorized_users.append(user)
        
        # Operation Manager - can approve all requests (except GM/CEO/Operation Manager)
        op_manager_users = User.query.filter_by(role='Operation Manager').all()
        for user in op_manager_users:
            if user.user_id != requestor.user_id:
                authorized_users.append(user)
        
        # Check if submitter has a manager_id (direct manager relationship)
        if requestor.manager_id:
            manager = User.query.get(requestor.manager_id)
            if manager and manager.user_id != requestor.user_id:
                if manager not in authorized_users:
                    authorized_users.append(manager)
        
        # Special case: General Manager can approve Department Manager requests
        if requestor.role == 'Department Manager':
            gm_users = User.query.filter_by(role='GM').all()
            for user in gm_users:
                if user not in authorized_users:
                    authorized_users.append(user)
            
            op_manager_users = User.query.filter_by(role='Operation Manager').all()
            for user in op_manager_users:
                if user not in authorized_users:
                    authorized_users.append(user)
        
        # Special case: Abdalaziz can approve Finance Staff requests
        if requestor.role == 'Finance Staff':
            abdalaziz = User.query.filter_by(name='Abdalaziz Al-Brashdi').first()
            if abdalaziz and abdalaziz not in authorized_users:
                authorized_users.append(abdalaziz)
        
        # Special case: Operation Manager can approve Operation department and Project requests
        if (requestor.department == 'Operation' or requestor.department == 'Project') and \
           requestor.role != 'Operation Manager':
            op_manager_users = User.query.filter_by(role='Operation Manager').all()
            for user in op_manager_users:
                if user.user_id != requestor.user_id and user not in authorized_users:
                    authorized_users.append(user)
        
        # Special case: Finance Admin can approve Finance department requests
        if requestor.department == 'Finance' and requestor.role != 'Finance Admin':
            finance_admins = User.query.filter_by(role='Finance Admin').all()
            for user in finance_admins:
                if user.user_id != requestor.user_id and user not in authorized_users:
                    authorized_users.append(user)
        
        # Special case: IT Department Manager can approve IT department requests
        if requestor.department == 'IT' and requestor.role != 'Department Manager':
            it_managers = User.query.filter_by(
                role='Department Manager',
                department='IT'
            ).all()
            for user in it_managers:
                if user.user_id != requestor.user_id and user not in authorized_users:
                    authorized_users.append(user)
        
        # Special case: Department Manager can approve same department requests
        dept_managers = User.query.filter_by(
            role='Department Manager',
            department=requestor.department
        ).all()
        for user in dept_managers:
            if user.user_id != requestor.user_id and user not in authorized_users:
                authorized_users.append(user)
    
    # Remove duplicates
    seen = set()
    unique_authorized = []
    for user in authorized_users:
        if user.user_id not in seen:
            seen.add(user.user_id)
            unique_authorized.append(user)
    
    return unique_authorized

def notify_users_by_role(request, notification_type, title, message, request_id=None):
    """Notify users based on RBAC notification permissions"""
    
    # Handle user management notifications (no request object)
    if notification_type in ['user_created', 'user_updated', 'user_deleted']:
        it_staff_users = User.query.filter_by(role='IT Staff').all()
        for user in it_staff_users:
            create_notification(user.user_id, title, message, notification_type, request_id)
        return
    
    # Get the requestor's role and department
    requestor_role = request.user.role
    requestor_department = request.department
    
    print(f"DEBUG: notify_users_by_role called")
    print(f"   - notification_type: {notification_type}")
    print(f"   - requestor_role: {requestor_role}")
    print(f"   - requestor_department: {requestor_department}")
    print(f"   - title: {title}")
    
    # Finance Admin and Finance Staff - get notifications when requests reach Pending Finance Approval
    if notification_type in ['ready_for_finance_review']:
        finance_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
        for user in finance_users:
            create_notification(user.user_id, title, message, notification_type, request_id)
    
    # Handle new_submission notifications
    elif notification_type == 'new_submission':
        print(f"DEBUG: Processing new_submission for role: {requestor_role}, department: {requestor_department}")
        
        # First, notify the submitting user (request creator)
        submitter_notification_title = "Payment Request Submitted"
        request_type_name = getattr(request, 'request_type', 'payment request')
        if hasattr(request, 'amount') and request.amount is not None:
            try:
                amount_str = f"{float(request.amount):.3f}"
            except (ValueError, TypeError):
                amount_str = str(request.amount)
        else:
            amount_str = 'N/A'
        submitter_notification_message = f"Your {request_type_name} request for OMR {amount_str} has been submitted successfully and is awaiting manager approval."
        create_notification(request.user_id, submitter_notification_title, submitter_notification_message, notification_type, request_id)
        print(f"DEBUG: Notified submitting user: {request.user.name} (ID: {request.user_id})")
        
        # Get all authorized manager approvers using the helper function
        authorized_approvers = get_authorized_manager_approvers(request)

        # Ensure department-level temporary manager (if any) is included even if department casing differs
        try:
            req_dept = (requestor_department or '').strip()
            if req_dept:
                dept_temp = None
                for dt in DepartmentTemporaryManager.query.filter(
                    db.or_(
                        DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                        DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                    )
                ).all():
                    if (dt.department or '').strip().lower() == req_dept.lower():
                        dept_temp = dt
                        break
                if dept_temp:
                    temp_user = User.query.get(dept_temp.temporary_manager_id)
                    if temp_user and temp_user not in authorized_approvers:
                        authorized_approvers.append(temp_user)
                        print(f"DEBUG: Added department-level temporary manager for department '{req_dept}' to authorized_approvers: {temp_user.name} (ID: {temp_user.user_id})")
        except Exception:
            # Don't fail notification flow on lookup errors
            pass
        
        # Notify all authorized manager approvers
        for approver in authorized_approvers:
            create_notification(approver.user_id, title, message, notification_type, request_id)
            print(f"DEBUG: Notified authorized approver: {approver.name} (ID: {approver.user_id}, Role: {approver.role})")
        
        # General Manager - receives notifications from ALL requests (regardless of role/department)
        gm_users = User.query.filter_by(role='GM').all()
        for user in gm_users:
            # Only notify if not already in authorized_approvers (avoid duplicates)
            if user not in authorized_approvers:
                create_notification(user.user_id, title, message, notification_type, request_id)
                print(f"DEBUG: Notified GM {user.username} about new_submission")
        
        # Operation Manager - receives notifications from ALL requests (regardless of role/department)
        op_manager_users = User.query.filter_by(role='Operation Manager').all()
        for user in op_manager_users:
            # Only notify if not already in authorized_approvers (avoid duplicates)
            if user not in authorized_approvers:
                create_notification(user.user_id, title, message, notification_type, request_id)
                print(f"DEBUG: Notified Operation Manager {user.username} about new_submission")
        
        # IT Department Manager - only from IT Staff submissions (explicitly notify even if not in authorized_approvers)
        if requestor_role == 'IT Staff' or requestor_department == 'IT':
            it_manager_users = User.query.filter_by(role='Department Manager', department='IT').all()
            for user in it_manager_users:
                # Only notify if not already in authorized_approvers (avoid duplicates)
                if user not in authorized_approvers:
                    create_notification(user.user_id, title, message, notification_type, request_id)
                    print(f"DEBUG: Notified IT Department Manager {user.username} about IT Staff request")
        
        print(f"DEBUG: Total notifications sent for new_submission: 1 to submitter + {len(authorized_approvers)} to authorized approvers + GM/Operation Manager/IT Manager")
    
    # Requestor - for updates on their own requests
    elif notification_type in ['request_rejected', 'request_approved', 'proof_uploaded', 'status_changed']:
        create_notification(request.user_id, title, message, notification_type, request_id)
        
        # For proof_uploaded, also notify Finance Admin
        if notification_type == 'proof_uploaded':
            print(f"DEBUG: Also notifying Finance Admin about proof upload")
            finance_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
            for user in finance_users:
                create_notification(
                    user_id=user.user_id,
                    title=title,
                    message=message,
                    notification_type=notification_type,
                    request_id=request_id
                )
                print(f"DEBUG: Notified Finance user {user.username} about proof upload")
        
        # For request_approved, also notify Finance Admin if they didn't approve it
        elif notification_type == 'request_approved':
            print(f"DEBUG: Also notifying Finance Admin about request approval")
            finance_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
            for user in finance_users:
                create_notification(
                    user_id=user.user_id,
                    title=title,
                    message=message,
                    notification_type=notification_type,
                    request_id=request_id
                )
                print(f"DEBUG: Notified Finance user {user.username} about request approval")
    
    # Emit real-time notification to all users after creating database notifications
    try:
        socketio.emit('new_notification', {
            'title': title,
            'message': message,
            'type': notification_type,
            'request_id': request_id
        }, room='all_users')
        
        # Also emit a general update event to trigger notification count updates
        socketio.emit('notification_update', {
            'action': 'new_notification',
            'type': notification_type
        }, room='all_users')
        
        print(f"DEBUG: WebSocket events emitted for {notification_type}")
    except Exception as e:
        print(f"Error emitting WebSocket notification: {e}")

def notify_recurring_payment_due(request_id, user_id, title, message):
    """Notify specific user about recurring payment due"""
    create_notification(user_id, title, message, 'recurring_due', request_id)


def notify_system_wide(title, message, notification_type):
    """Notify all users who should receive system-wide notifications"""
    # Roles that receive system-wide notifications
    system_roles = ['Finance Admin', 'Finance Staff', 'GM', 'CEO', 'Operation Manager', 'IT Staff', 'Department Manager']
    
    for role in system_roles:
        users = User.query.filter_by(role=role).all()
        for user in users:
            create_notification(user.user_id, title, message, notification_type)

def create_recurring_payment_schedule(request_id, total_amount, payment_schedule_data):
    """Create a recurring payment schedule with variable amounts"""
    try:
        # Clear any existing schedule for this request
        RecurringPaymentSchedule.query.filter_by(request_id=request_id).delete()
        
        # Create new schedule entries
        for i, payment_data in enumerate(payment_schedule_data, 1):
            schedule_entry = RecurringPaymentSchedule(
                request_id=request_id,
                payment_date=datetime.strptime(payment_data['date'], '%Y-%m-%d').date(),
                amount=payment_data['amount'],
                payment_order=i
            )
            db.session.add(schedule_entry)
        
        db.session.commit()
        return True
    except Exception as e:
        db.session.rollback()
        print(f"Error creating payment schedule: {e}")
        return False

def redirect_with_return_url(endpoint, **kwargs):
    """Helper function to redirect to an endpoint while preserving return_url parameter"""
    return_url = request.form.get('return_url') or request.args.get('return_url')
    if return_url:
        kwargs['return_url'] = return_url
    return redirect(url_for(endpoint, **kwargs))

def get_payment_schedule(request_id):
    """Get the payment schedule for a specific request"""
    schedules = RecurringPaymentSchedule.query.filter_by(request_id=request_id).order_by(RecurringPaymentSchedule.payment_order).all()
    return [schedule.to_dict() for schedule in schedules]

def get_recurring_scheduled_dates(req):
    """Get scheduled dates for a recurring payment request as a semicolon-separated string
    For Cheque + Recurring requests, includes day calculations"""
    if not req or req.recurring != 'Recurring':
        return ''
    
    dates = []
    date_objects = []  # Store date objects for day calculation
    
    # Check if it has custom dates stored in RecurringPaymentSchedule
    schedules = RecurringPaymentSchedule.query.filter_by(request_id=req.request_id).order_by(RecurringPaymentSchedule.payment_order).all()
    if schedules:
        # Custom dates - get all payment dates
        for schedule in schedules:
            date_objects.append(schedule.payment_date)
            dates.append(schedule.payment_date.strftime('%Y-%m-%d'))
    elif req.recurring_interval:
        # Monthly recurring - parse recurring_interval to extract dates
        try:
            parts = req.recurring_interval.split(':')
            if len(parts) >= 2 and parts[0] == 'monthly':
                interval = int(parts[1])
                # Check for date format: monthly:1:date:2025-10-11:end:2025-11-11
                if len(parts) > 2 and parts[2] == 'date':
                    start_date_str = parts[3]
                    start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
                    date_objects.append(start_date)
                    dates.append(start_date_str)
                    
                    # Check if there's an end date
                    if 'end' in parts:
                        end_index = parts.index('end')
                        if end_index + 1 < len(parts):
                            end_date_str = parts[end_index + 1]
                            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
                            
                            # Generate all dates from start to end based on interval
                            current_date = add_months(start_date, interval)
                            while current_date <= end_date:
                                date_objects.append(current_date)
                                dates.append(current_date.strftime('%Y-%m-%d'))
                                current_date = add_months(current_date, interval)
                                # Safety check to prevent infinite loop
                                if len(dates) > 100:
                                    break
                # Check for days format: monthly:1:days:11,15:2025:10
                elif len(parts) > 2 and parts[2] == 'days':
                    # Extract specific days
                    days = parts[3].split(',')
                    year = int(parts[4]) if len(parts) > 4 else (req.date.year if req.date else date.today().year)
                    month = int(parts[5]) if len(parts) > 5 else (req.date.month if req.date else date.today().month)
                    
                    for day in days:
                        try:
                            day_int = int(day)
                            payment_date = date(year, month, day_int)
                            date_objects.append(payment_date)
                            dates.append(payment_date.strftime('%Y-%m-%d'))
                        except (ValueError, TypeError):
                            continue
                # Simple monthly format: monthly:1 (use request date as start)
                else:
                    if req.date:
                        date_objects.append(req.date)
                        dates.append(req.date.strftime('%Y-%m-%d'))
        except (ValueError, IndexError, AttributeError) as e:
            # If parsing fails, return empty
            pass
    
    # If no dates found, return empty
    if not dates:
        return ''
    
    # Check if this is a Cheque + Recurring request
    if req.payment_method == 'Cheque' and req.recurring == 'Recurring':
        # Calculate days for each date
        result_parts = []
        for i, date_obj in enumerate(date_objects):
            if i == 0:
                # First date: count from date to end of month (exclusive of start date)
                last_day = calendar.monthrange(date_obj.year, date_obj.month)[1]
                days = last_day - date_obj.day
            else:
                # Subsequent dates: count from first day of month to date (exclusive of start date)
                days = date_obj.day - 1
            
            result_parts.append(f"{dates[i]} ({days} days)")
        
        return '\n'.join(result_parts)
    else:
        # Regular format: just return dates without day calculations
        return '\n'.join(dates)

# Add filter for getting recurring scheduled dates (must be after function definition)
@app.template_filter('get_recurring_dates')
def get_recurring_dates_filter(req):
    """Get scheduled dates for recurring payment request"""
    return get_recurring_scheduled_dates(req)

def get_authorized_users_for_recurring_due(request):
    """Get all authorized users who should receive recurring payment due notifications"""
    authorized_user_ids = set()
    
    # Finance Admin (all)
    finance_admins = User.query.filter_by(role='Finance Admin').all()
    for user in finance_admins:
        authorized_user_ids.add(user.user_id)
    
    # Finance Staff (all)
    finance_staff = User.query.filter_by(role='Finance Staff').all()
    for user in finance_staff:
        authorized_user_ids.add(user.user_id)
    
    # Project Staff (on their own requests only)
    if request.user.role == 'Project Staff':
        authorized_user_ids.add(request.user_id)
    
    # Department Managers (for their department's requests)
    dept_managers = User.query.filter_by(
        role='Department Manager',
        department=request.department
    ).all()
    for user in dept_managers:
        authorized_user_ids.add(user.user_id)
    
    # Department Staff (on their own requests only)
    # Check if requestor is a department staff member (not Project Staff, not Finance, not GM, etc.)
    if request.user.role not in ['Project Staff', 'Finance Admin', 'Finance Staff', 'GM', 'CEO', 'Operation Manager', 'IT Staff', 'Department Manager']:
        authorized_user_ids.add(request.user_id)
    
    return list(authorized_user_ids)


def check_recurring_payments_due():
    """Check for recurring payments due today and create notifications"""
    today = date.today()
    
    # Get all recurring payment requests with Payment Type "Recurring" and status in allowed list
    recurring_requests = PaymentRequest.query.filter(
        PaymentRequest.recurring == 'Recurring',  # Payment Type must be "Recurring"
        PaymentRequest.status.in_([
            'Pending Finance Approval',
            'Proof Pending',
            'Proof Sent',
            'Proof Rejected',
            'Completed',
            'Recurring'
        ]),
        PaymentRequest.is_archived == False
    ).all()
    
    for request in recurring_requests:
        # Check if this request has a custom payment schedule
        payment_schedules = RecurringPaymentSchedule.query.filter_by(
            request_id=request.request_id,
            is_paid=False
        ).order_by(RecurringPaymentSchedule.payment_order).all()
        
        if payment_schedules:
            # Handle variable amount recurring payments
            for schedule in payment_schedules:
                if schedule.payment_date == today:
                    # Check if payment was already marked as paid today
                    paid_today = PaidNotification.query.filter_by(
                        request_id=request.request_id,
                        paid_date=today
                    ).first()
                    
                    if paid_today:
                        continue  # Skip this payment - already marked as paid today
                    
                    # Check if notification already exists for today
                    start_of_day = datetime.combine(today, datetime.min.time())
                    end_of_day = datetime.combine(today, datetime.max.time())
                    
                    existing_notification = Notification.query.filter_by(
                        request_id=request.request_id,
                        notification_type='recurring_due'
                    ).filter(
                        Notification.created_at >= start_of_day,
                        Notification.created_at <= end_of_day
                    ).first()
                    
                    if not existing_notification:
                        # Get all authorized users for this request
                        authorized_user_ids = get_authorized_users_for_recurring_due(request)
                        
                        # Create notifications for all authorized users
                        for user_id in authorized_user_ids:
                            create_notification(
                                user_id=user_id,
                                title="Recurring Payment Due",
                                message=f'Recurring payment due today for {request.request_type} - {request.purpose} (Amount: {schedule.amount} OMR)',
                                notification_type='recurring_due',
                                request_id=request.request_id
                            )
                        
                        # Log the action
                        log_action(f"Recurring payment due notification created for request #{request.request_id} - Payment {schedule.payment_order} - Notified {len(authorized_user_ids)} users")
        else:
            # Handle traditional recurring payments (single amount)
            if is_payment_due_today(request, today):
                # Check if payment was already marked as paid today
                paid_today = PaidNotification.query.filter_by(
                    request_id=request.request_id,
                    paid_date=today
                ).first()
                
                if paid_today:
                    continue  # Skip this payment - already marked as paid today
                
                # Check if notification already exists for today (more robust check)
                start_of_day = datetime.combine(today, datetime.min.time())
                end_of_day = datetime.combine(today, datetime.max.time())
                
                existing_notification = Notification.query.filter_by(
                    request_id=request.request_id,
                    notification_type='recurring_due'
                ).filter(
                    Notification.created_at >= start_of_day,
                    Notification.created_at <= end_of_day
                ).first()
                
                if not existing_notification:
                    # Get all authorized users for this request
                    authorized_user_ids = get_authorized_users_for_recurring_due(request)
                    
                    # Create notifications for all authorized users
                    for user_id in authorized_user_ids:
                        create_notification(
                            user_id=user_id,
                            title="Recurring Payment Due",
                            message=f'Recurring payment due today for {request.request_type} - {request.purpose}',
                            notification_type='recurring_due',
                            request_id=request.request_id
                        )
                    
                    # Log the action
                    log_action(f"Recurring payment due notification created for request #{request.request_id} - Notified {len(authorized_user_ids)} users")


def get_overdue_requests_count():
    """Get count of overdue finance approval requests"""
    try:
        current_time = datetime.utcnow()
        
        # Get ALL requests that have started finance approval timing but haven't ended
        # Finance approval is still moving if finance_approval_start_time is set
        # and finance_approval_end_time is None
        # Exclude archived requests
        pending_requests = PaymentRequest.query.filter(
            PaymentRequest.finance_approval_start_time.isnot(None),
            PaymentRequest.finance_approval_end_time.is_(None),  # Finance approval still moving
            PaymentRequest.is_archived == False  # Exclude archived requests
        ).all()
        
        overdue_count = 0
        for request in pending_requests:
            # EXCLUDE requests with status "Completed" or "Recurring"
            # These statuses mean the request is no longer in finance approval stage
            if request.status in ['Completed', 'Recurring']:
                continue
            
            # Calculate time elapsed since finance approval started
            time_elapsed = current_time - request.finance_approval_start_time
            
            # Determine alert thresholds based on urgency
            if request.is_urgent:
                # Urgent requests: 2 hours or more
                alert_threshold = timedelta(hours=2)
            else:
                # Non-urgent requests: 24 hours or more (includes days)
                alert_threshold = timedelta(hours=24)
            
            # Check if this request is overdue
            # If time elapsed >= threshold, it MUST be counted
            # This includes requests showing "days" since 1 day = 24 hours
            if time_elapsed >= alert_threshold:
                overdue_count += 1
        
        return overdue_count
        
    except Exception as e:
        print(f"Error getting overdue requests count: {e}")
        import traceback
        traceback.print_exc()
        return 0


def get_overdue_requests():
    """Get all overdue finance approval requests"""
    try:
        current_time = datetime.utcnow()
        
        # Get ALL requests that have started finance approval timing but haven't ended
        # Finance approval is still moving if finance_approval_start_time is set
        # and finance_approval_end_time is None
        # Exclude archived requests
        pending_requests = PaymentRequest.query.filter(
            PaymentRequest.finance_approval_start_time.isnot(None),
            PaymentRequest.finance_approval_end_time.is_(None),  # Finance approval still moving
            PaymentRequest.is_archived == False  # Exclude archived requests
        ).all()
        
        overdue_requests = []
        for request in pending_requests:
            # EXCLUDE requests with status "Completed" or "Recurring"
            # These statuses mean the request is no longer in finance approval stage
            if request.status in ['Completed', 'Recurring']:
                continue
            
            # Calculate time elapsed since finance approval started
            time_elapsed = current_time - request.finance_approval_start_time
            
            # Determine alert thresholds based on urgency
            if request.is_urgent:
                # Urgent requests: 2 hours or more
                alert_threshold = timedelta(hours=2)
            else:
                # Non-urgent requests: 24 hours or more (includes days)
                alert_threshold = timedelta(hours=24)
            
            # Check if this request is overdue
            # If time elapsed >= threshold, it MUST appear on overdue page
            # This includes requests showing "days" since 1 day = 24 hours
            if time_elapsed >= alert_threshold:
                # Format time elapsed for display (show days, hours, and minutes)
                total_seconds = int(time_elapsed.total_seconds())
                days = total_seconds // 86400
                hours = (total_seconds % 86400) // 3600
                minutes = (total_seconds % 3600) // 60
                
                # Build time display string with appropriate units
                time_parts = []
                if days > 0:
                    time_parts.append(f"{days} day{'s' if days != 1 else ''}")
                if hours > 0:
                    time_parts.append(f"{hours} hour{'s' if hours != 1 else ''}")
                if minutes > 0 or len(time_parts) == 0:  # Show minutes if no days/hours, or if there are minutes
                    time_parts.append(f"{minutes} minute{'s' if minutes != 1 else ''}")
                
                time_display = " and ".join(time_parts)
                
                overdue_requests.append({
                    'request': request,
                    'time_elapsed': time_elapsed,
                    'time_display': time_display,
                    'threshold': alert_threshold
                })
        
        # Sort by time elapsed (most overdue first)
        overdue_requests.sort(key=lambda x: x['time_elapsed'], reverse=True)
        
        return overdue_requests
        
    except Exception as e:
        print(f"Error getting overdue requests: {e}")
        import traceback
        traceback.print_exc()
        return []


def check_finance_approval_timing_alerts():
    """Check for finance approval timing alerts and send notifications"""
    try:
        current_time = datetime.utcnow()
        
        # Get all requests that are pending finance approval and have started timing
        # Exclude archived requests
        pending_requests = PaymentRequest.query.filter(
            PaymentRequest.status == 'Pending Finance Approval',
            PaymentRequest.finance_approval_start_time.isnot(None),
            PaymentRequest.finance_approval_end_time.is_(None),  # Not yet completed
            PaymentRequest.is_archived == False  # Exclude archived requests
        ).all()
        
        for request in pending_requests:
            # Calculate time elapsed since finance approval started
            time_elapsed = current_time - request.finance_approval_start_time
            
            # Determine alert thresholds based on urgency
            if request.is_urgent:
                # Urgent requests: 2 hours
                alert_threshold = timedelta(hours=2)
                recurring_threshold = timedelta(hours=2)
            else:
                # Non-urgent requests: 24 hours
                alert_threshold = timedelta(hours=24)
                recurring_threshold = timedelta(hours=24)
            
            # Check if we should send an alert
            should_send_alert = False
            alert_type = None
            
            if time_elapsed >= alert_threshold:
                # Check if this is the first alert or a recurring alert
                # Look for existing timing alerts for this request
                existing_alerts = Notification.query.filter(
                    Notification.request_id == request.request_id,
                    Notification.notification_type.in_(['finance_approval_timing_alert', 'finance_approval_timing_recurring'])
                ).order_by(Notification.created_at.desc()).all()
                
                if not existing_alerts:
                    # First alert
                    should_send_alert = True
                    alert_type = 'finance_approval_timing_alert'
                else:
                    # Check if enough time has passed for a recurring alert
                    last_alert = existing_alerts[0]
                    time_since_last_alert = current_time - last_alert.created_at
                    
                    if time_since_last_alert >= recurring_threshold:
                        should_send_alert = True
                        alert_type = 'finance_approval_timing_recurring'
            
            if should_send_alert:
                # Format time elapsed for display
                hours = int(time_elapsed.total_seconds() // 3600)
                minutes = int((time_elapsed.total_seconds() % 3600) // 60)
                
                if hours > 0:
                    time_display = f"{hours} hour{'s' if hours != 1 else ''} and {minutes} minute{'s' if minutes != 1 else ''}"
                else:
                    time_display = f"{minutes} minute{'s' if minutes != 1 else ''}"
                
                # Create alert message
                urgency_text = "URGENT" if request.is_urgent else "NON-URGENT"
                threshold_text = "2 hours" if request.is_urgent else "24 hours"
                
                if alert_type == 'finance_approval_timing_alert':
                    title = f"Finance Approval Overdue - {urgency_text} Request"
                    message = f"Payment request #{request.request_id} has been pending finance approval for {time_display} (limit: {threshold_text}). Please take action immediately."
                else:  # finance_approval_timing_recurring
                    title = f"Finance Approval Still Overdue - {urgency_text} Request"
                    message = f"Payment request #{request.request_id} is still pending finance approval after {time_display} (limit: {threshold_text}). This is a recurring alert - please take action immediately."
                
                # Send notification to all Finance Admin users
                finance_admin_users = User.query.filter_by(role='Finance Admin').all()
                for user in finance_admin_users:
                    create_notification(
                        user_id=user.user_id,
                        title=title,
                        message=message,
                        notification_type=alert_type,
                        request_id=request.request_id
                    )
                
                # Log the action
                log_action(f"Finance approval timing alert sent for request #{request.request_id} - {time_display} elapsed")
                
                print(f"Sent {alert_type} for request #{request.request_id} - {time_display} elapsed")
        
        print(f"Checked {len(pending_requests)} pending finance approval requests for timing alerts")
        
    except Exception as e:
        print(f"Error checking finance approval timing alerts: {e}")


def background_scheduler():
    """Background scheduler that runs timing checks every hour"""
    while True:
        try:
            with app.app_context():
                check_finance_approval_timing_alerts()
                check_recurring_payments_due()
        except Exception as e:
            print(f"Error in background scheduler: {e}")
        
        # Sleep for 1 hour (3600 seconds)
        time.sleep(3600)


def is_payment_due_today(request, today):
    """Check if a recurring payment is due today based on its configuration"""
    if not request.recurring_interval:
        return False
    
    try:
        # Parse the recurring interval configuration
        parts = request.recurring_interval.split(':')
        frequency = parts[0]
        interval = int(parts[1])
        
        if frequency == 'daily':
            # Daily payments - check if it's been the right number of days AND time has passed
            days_since_created = (today - request.date).days
            
            # Parse the time from the recurring interval
            time_parts = request.recurring_interval.split(':')
            if len(time_parts) >= 5 and time_parts[2] == 'time':
                try:
                    scheduled_hour = int(time_parts[3])
                    scheduled_minute = int(time_parts[4])
                    
                    # Use local time instead of UTC
                    from datetime import datetime
                    current_time = datetime.now()
                    scheduled_time = datetime.combine(today, datetime.min.time().replace(hour=scheduled_hour, minute=scheduled_minute))
                    
                    
                    # Check if it's the right day and time has passed
                    if interval == 1:
                        # Every day - due if it's the same day or later AND time has passed
                        if days_since_created >= 0:
                            return current_time >= scheduled_time
                    else:
                        # Every X days - due if it's been X days since creation AND time has passed
                        if days_since_created > 0 and days_since_created % interval == 0:
                            return current_time >= scheduled_time
                except (ValueError, IndexError):
                    # If time parsing fails, fall back to day-only logic
                    pass
            
            # Fallback to day-only logic if time parsing fails
            if interval == 1:
                return days_since_created >= 0
            else:
                return days_since_created > 0 and days_since_created % interval == 0
            
        elif frequency == 'weekly':
            # Weekly payments - check if it's the right day of week
            if len(parts) > 2 and parts[2] == 'days':
                selected_days = parts[3].split(',')
                weekday_names = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                today_weekday = weekday_names[today.weekday()]
                return today_weekday in selected_days
            else:
                # Default to same day of week as created
                return today.weekday() == request.date.weekday()
                
        elif frequency == 'monthly':
            # Monthly payments - check if it's the right day of month and enough months have passed
            if len(parts) > 2 and parts[2] == 'days':
                selected_days = [int(d) for d in parts[3].split(',')]
                if today.day in selected_days:
                    # Check if enough months have passed since creation
                    months_since_created = (today.year - request.date.year) * 12 + (today.month - request.date.month)
                    # Always require at least 1 month to pass (never due on creation day)
                    return months_since_created > 0 and months_since_created % interval == 0
            else:
                # Default to same day of month as created
                if today.day == request.date.day:
                    months_since_created = (today.year - request.date.year) * 12 + (today.month - request.date.month)
                    # Always require at least 1 month to pass (never due on creation day)
                    return months_since_created > 0 and months_since_created % interval == 0
            return False
                
        elif frequency == 'quarterly':
            # Quarterly payments - check if it's the right month and day
            if len(parts) > 2 and parts[2] == 'months':
                # Convert month names to numbers
                month_names = ['January', 'February', 'March', 'April', 'May', 'June',
                             'July', 'August', 'September', 'October', 'November', 'December']
                selected_month_names = [m.strip() for m in parts[3].split(',')]
                selected_months = [month_names.index(m) + 1 for m in selected_month_names if m in month_names]
                
                if today.month in selected_months:
                    if len(parts) > 4 and parts[4] == 'days':
                        selected_days = [int(d) for d in parts[5].split(',')]
                        if today.day in selected_days:
                            # Check if enough quarters have passed
                            months_since_created = (today.year - request.date.year) * 12 + (today.month - request.date.month)
                            return months_since_created > 0 and months_since_created % (interval * 3) == 0
                    else:
                        if today.day == request.date.day:
                            months_since_created = (today.year - request.date.year) * 12 + (today.month - request.date.month)
                            return months_since_created > 0 and months_since_created % (interval * 3) == 0
            return False
            
        elif frequency == 'yearly':
            # Yearly payments - check if it's the right month and day
            if len(parts) > 2 and parts[2] == 'months':
                # Convert month names to numbers
                month_names = ['January', 'February', 'March', 'April', 'May', 'June',
                             'July', 'August', 'September', 'October', 'November', 'December']
                selected_month_names = [m.strip() for m in parts[3].split(',')]
                selected_months = [month_names.index(m) + 1 for m in selected_month_names if m in month_names]
                
                if today.month in selected_months:
                    if len(parts) > 4 and parts[4] == 'days':
                        selected_days = [int(d) for d in parts[5].split(',')]
                        if today.day in selected_days:
                            # Check if enough years have passed
                            years_since_created = today.year - request.date.year
                            return years_since_created > 0 and years_since_created % interval == 0
                    else:
                        if today.day == request.date.day:
                            years_since_created = today.year - request.date.year
                            return years_since_created > 0 and years_since_created % interval == 0
            return False
            
    except (ValueError, IndexError, AttributeError):
        # If parsing fails, don't create notification
        return False
    
    return False


def calculate_finance_approval_duration(request):
    """Calculate and set finance approval duration if not already set"""
    if (request.finance_approval_start_time and 
        request.finance_approval_end_time and 
        not request.finance_approval_duration_minutes):
        duration = request.finance_approval_end_time - request.finance_approval_start_time
        # Store duration in seconds for more precision (consistent with template logic)
        request.finance_approval_duration_minutes = int(duration.total_seconds())
        return True
    return False

def check_recurring_payment_completion(request_id):
    """Check if all installments for a recurring payment are paid and mark as completed"""
    try:
        # Get the payment request
        req = PaymentRequest.query.get(request_id)
        if not req or req.status != 'Recurring' or req.recurring != 'Recurring':
            return False
        
        # Get all installments for this request
        installments = RecurringPaymentSchedule.query.filter_by(request_id=request_id).all()
        
        if not installments:
            return False
        
        # Check if all installments are paid
        all_paid = all(installment.is_paid for installment in installments)
        
        if all_paid:
            # Calculate total paid amount
            total_paid = sum(float(installment.amount) for installment in installments)
            total_requested = float(req.amount)
            
            # Check if there's no remaining amount (allowing for small floating point differences)
            remaining_amount = total_requested - total_paid
            if abs(remaining_amount) < 0.001:  # Less than 0.001 OMR difference
                # Mark the request as completed
                req.status = 'Completed'
                req.completion_date = datetime.utcnow().date()
                req.approval_date = datetime.utcnow().date()  # Set approval_date when status becomes Completed
                req.updated_at = datetime.utcnow()
                
                # End finance approval timing when completed
                if req.finance_approval_start_time and not req.finance_approval_end_time:
                    current_time = datetime.utcnow()
                    req.finance_approval_end_time = current_time
                    duration = current_time - req.finance_approval_start_time
                    req.finance_approval_duration_minutes = int(duration.total_seconds())
                
                db.session.commit()
                
                # Create completion notification
                create_notification(
                    user_id=req.user_id,
                    title="Recurring Payment Completed",
                    message=f'All installments for recurring payment request #{request_id} have been paid. Request marked as completed.',
                    notification_type="recurring_completed",
                    request_id=request_id
                )
                
                # Notify Auditing Staff and Auditing Department Manager
                auditing_users = User.query.filter(
                    db.and_(
                        User.department == 'Auditing',
                        User.role.in_(['Auditing Staff', 'Department Manager'])
                    )
                ).all()
                for auditing_user in auditing_users:
                    dept_text = get_department_text_for_notification(req)
                    create_notification(
                        user_id=auditing_user.user_id,
                        title="Recurring Payment Completed",
                        message=f'All installments for recurring payment request #{request_id} {dept_text} department have been paid. Request marked as completed.',
                        notification_type="recurring_completed",
                        request_id=request_id
                    )
                
                # Log the action
                log_action(f"Recurring payment request #{request_id} automatically marked as completed - all installments paid")
                
                # Emit real-time update
                socketio.emit('request_updated', {
                    'request_id': request_id,
                    'status': 'Completed',
                    'recurring': True,
                    'completed': True
                })
                
                return True
        
        return False
        
    except Exception as e:
        print(f"Error checking recurring payment completion: {e}")
        return False


def get_notifications_for_user(user, limit=5, page=None, per_page=None):
    """Get notifications for a user based on RBAC.
    - If limit is provided, return limited results (for dropdowns)
    - If page and per_page are provided, return paginated results
    - Otherwise return all results
    """

    query = None

    if user.role == 'Project Staff':
        # Project Staff: Updates on their own requests + recurring payment due on their own requests only
        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    Notification.notification_type == 'recurring_due',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                        'installment_paid', 'finance_note_added', 'one_time_payment_scheduled', 'request_returned',
                        'request_on_hold', 'item_request_updated'
                    ])
                )
            )
        ).order_by(Notification.created_at.desc())

    elif user.role in ['Finance Staff', 'Finance Admin']:
        # Finance roles: New submissions when requests reach Pending Finance Approval + proof uploaded + recurring payment due + system-wide
        # Finance Staff additionally get updates on their own requests
        if user.role == 'Finance Staff':
            query = Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    db.or_(
                        Notification.notification_type.in_([
                            'ready_for_finance_review', 'proof_uploaded', 'recurring_due', 'installment_edited',
                            'finance_approval_timing_alert', 'finance_approval_timing_recurring',
                            'system_maintenance', 'system_update', 'security_alert', 'system_error',
                            'admin_announcement'
                        ]),
                        Notification.notification_type.in_([
                            'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                            'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                            'installment_paid', 'finance_note_added', 'one_time_payment_scheduled', 'request_returned',
                            'request_on_hold', 'item_request_updated'
                        ])
                    )
                )
            ).order_by(Notification.created_at.desc())
        elif user.name == 'Abdalaziz Al-Brashdi':
            # Abdalaziz gets finance notifications + new_submission from GM/Operation Manager/Finance Staff + updates on Finance Staff, GM, and Operation Manager requests
            query = Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    db.or_(
                        Notification.notification_type.in_([
                            'ready_for_finance_review', 'proof_uploaded', 'recurring_due', 'installment_edited',
                            'finance_approval_timing_alert', 'finance_approval_timing_recurring',
                            'system_maintenance', 'system_update', 'security_alert', 'system_error',
                            'admin_announcement'
                        ]),
                        Notification.notification_type.in_([
                            'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                            'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                            'installment_paid', 'finance_note_added', 'one_time_payment_scheduled', 'request_returned',
                            'request_on_hold'
                        ]),
                        # new_submission only for GM, Operation Manager, Finance Staff, or CEO (his assigned managers)
                        db.and_(
                            Notification.notification_type == 'new_submission',
                            Notification.request_id.isnot(None),
                            db.exists().where(
                                db.and_(
                                    PaymentRequest.request_id == Notification.request_id,
                                    PaymentRequest.user_id == User.user_id,
                                    User.role.in_(['GM', 'CEO', 'Operation Manager', 'Finance Staff'])
                                )
                            )
                        )
                    )
                )
            ).order_by(Notification.created_at.desc())
        else:  # Other Finance Admin
            query = Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.notification_type.in_([
                        'ready_for_finance_review', 'proof_uploaded', 'recurring_due', 'installment_edited',
                        'finance_approval_timing_alert', 'finance_approval_timing_recurring',
                        'system_maintenance', 'system_update', 'security_alert', 'system_error',
                            'admin_announcement', 'one_time_payment_scheduled', 'request_returned', 'request_on_hold', 'item_request_updated'
                    ])
                )
            ).order_by(Notification.created_at.desc())

    elif user.role in ['GM', 'CEO']:
        # GM: New submissions from ALL requests (all roles/departments) + updates on their own requests + system-wide + temporary manager assignments + item requests
        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                        'installment_paid', 'finance_note_added', 'one_time_payment_scheduled', 'request_returned',
                        'request_on_hold', 'item_request_updated', 'item_request_assigned'
                    ]),
                    Notification.notification_type.in_([
                        'system_maintenance', 'system_update', 'security_alert', 'system_error',
                        'admin_announcement'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).order_by(Notification.created_at.desc())

    elif user.role == 'Operation Manager':
        # Operation Manager: New submissions from ALL requests (all roles/departments) + updates on their own requests + system-wide + item requests
        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                        'installment_paid', 'one_time_payment_scheduled', 'request_returned', 'request_on_hold', 'item_request_updated', 'item_request_assigned'
                    ]),
                    Notification.notification_type.in_([
                        'system_maintenance', 'system_update', 'security_alert', 'system_error',
                        'admin_announcement'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).order_by(Notification.created_at.desc())

    elif user.role == 'Branch Inventory Officer':
        # Branch Inventory Officer: should receive item request submissions and related updates (same visibility as Operation Manager for item requests)
        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                        'installment_paid', 'one_time_payment_scheduled', 'request_returned', 'request_on_hold', 'item_request_updated', 'item_request_assigned'
                    ]),
                    Notification.notification_type.in_([
                        'system_maintenance', 'system_update', 'security_alert', 'system_error',
                        'admin_announcement'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).order_by(Notification.created_at.desc())

    elif user.role == 'Department Manager' and user.department == 'IT':
        # IT Department Manager: New submissions from IT Staff only + updates on their own requests + system-wide + user management + temporary manager assignments
        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    # Item request submissions (for procurement item requests)
                    Notification.notification_type == 'item_request_submission',
                    # new_submission only if it's from IT Staff (join with PaymentRequest to check)
                    db.and_(
                        Notification.notification_type == 'new_submission',
                        Notification.request_id.isnot(None),
                        db.or_(
                            # Request created by IT Staff (check user role)
                            db.exists().where(
                                db.and_(
                                    PaymentRequest.request_id == Notification.request_id,
                                    PaymentRequest.department == 'IT',
                                    User.user_id == PaymentRequest.user_id,
                                    User.role == 'IT Staff'
                                )
                            ),
                            # Or request from IT department with IT Staff role in message (fallback for existing notifications)
                            Notification.message.contains('IT')
                        )
                    ),
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'status_changed',
                        'proof_required', 'recurring_approved', 'request_completed', 'installment_paid',
                        'user_created', 'user_updated', 'user_deleted', 'finance_note_added',
                        'request_archived', 'request_restored', 'request_permanently_deleted', 'one_time_payment_scheduled', 'request_returned',
                        'request_on_hold', 'item_request_updated'
                    ]),
                    Notification.notification_type.in_([
                        'system_maintenance', 'system_update', 'security_alert', 'system_error',
                        'admin_announcement'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).order_by(Notification.created_at.desc())

    elif user.role == 'IT Staff':
        # IT Staff: Updates on their own requests + system-wide + user management + request archives + item request submissions
        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    # Item request submissions (for procurement item requests)
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'status_changed',
                        'proof_required', 'recurring_approved', 'request_completed', 'installment_paid',
                        'user_created', 'user_updated', 'user_deleted', 'finance_note_added',
                        'request_archived', 'request_restored', 'request_permanently_deleted', 'one_time_payment_scheduled', 'request_returned',
                        'request_on_hold', 'item_request_updated'
                    ]),
                    Notification.notification_type.in_([
                        'system_maintenance', 'system_update', 'security_alert', 'system_error',
                        'admin_announcement'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).order_by(Notification.created_at.desc())

    elif user.role == 'Department Manager':
        # Other Department Managers: New submissions from their own department staff only + recurring payment due for their department + updates on their own requests + temporary manager assignments + item requests
        print(f"DEBUG: Getting notifications for Department Manager {user.username} from {user.department}")

        # Get all notifications for this user first
        all_user_notifications = Notification.query.filter_by(user_id=user.user_id).all()
        print(f"DEBUG: Total notifications for user {user.username}: {len(all_user_notifications)}")
        for notif in all_user_notifications:
            print(f"DEBUG: Notification {notif.notification_id}: {notif.notification_type} - {notif.title}")

        query = Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',
                    Notification.notification_type == 'recurring_due',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                        'installment_paid', 'finance_note_added', 'one_time_payment_scheduled',
                        'item_request_assigned', 'item_request_updated', 'request_returned', 'request_on_hold',
                        'request_pending_approval'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).order_by(Notification.created_at.desc())

    else:
        # Department Staff: Updates on their own requests only + recurring payment due for their own requests + item request assignments
        # Also allow 'new_submission' and 'item_request_submission' types for users who were explicitly targeted
        # Check if user is a temporary manager for item requests - if so, include all item request notifications
        is_temp_manager_for_items = False
        try:
            temp_item_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).first()
            is_temp_manager_for_items = temp_item_assignments is not None
        except Exception:
            pass
        
        if is_temp_manager_for_items:
            # Temporary managers for item requests should see all item request notifications
            # Get departments they're assigned to
            temp_item_depts = set()
            try:
                temp_assignments = DepartmentTemporaryManager.query.filter(
                    DepartmentTemporaryManager.temporary_manager_id == user.user_id,
                    db.or_(
                        DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                        DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                    )
                ).all()
                for ta in temp_assignments:
                    if ta.department:
                        temp_item_depts.add(ta.department.strip().lower())
            except Exception:
                pass
            
            # Include all item request notifications, plus filter by department if needed
            query = Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    db.or_(
                        # All item request related notifications
                        Notification.notification_type.in_([
                            'item_request_submission', 'item_request_assigned', 'item_request_updated',
                            'request_approved', 'request_rejected', 'request_pending_approval',
                            'request_on_hold', 'request_returned'
                        ]),
                        # Other standard notifications
                        Notification.notification_type.in_([
                            'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                            'status_changed', 'recurring_due', 'proof_required', 'recurring_approved',
                            'request_completed', 'installment_paid', 'finance_note_added', 'one_time_payment_scheduled',
                            'temporary_manager_assignment', 'temporary_manager_unassigned',
                            'new_submission'
                        ])
                    )
                )
            ).order_by(Notification.created_at.desc())
        else:
            query = Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'recurring_due', 'proof_required', 'recurring_approved',
                        'request_completed', 'installment_paid', 'finance_note_added', 'one_time_payment_scheduled',
                            'item_request_assigned', 'item_request_updated', 'request_returned', 'request_on_hold',
                        'request_pending_approval', 'temporary_manager_assignment', 'temporary_manager_unassigned',
                        'new_submission', 'item_request_submission'
                    ])
                )
            ).order_by(Notification.created_at.desc())

    # Handle pagination, limit, or return all
    if page is not None and per_page is not None:
        return query.paginate(page=page, per_page=per_page, error_out=False)
    elif limit:
        return query.limit(limit).all()
    return query.all()

def get_unread_count_for_user(user):
    """Get unread notification count for a user based on their role per RBAC"""
    
    if user.role == 'Project Staff':
        # Project Staff: Updates on their own requests + recurring payment due on their own requests only
        return Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                Notification.is_read == False,
                db.or_(
                    Notification.notification_type == 'recurring_due',
                    Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'request_returned', 'request_on_hold'])
                )
            )
        ).count()
    
    elif user.role in ['Finance Staff', 'Finance Admin']:
        # Finance roles: New submissions when requests reach Pending Finance Approval + proof uploaded + recurring payment due + system-wide
        # Finance Staff additionally get updates on their own requests
        if user.role == 'Finance Staff':
            return Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.is_read == False,
                    db.or_(
                        Notification.notification_type.in_(['ready_for_finance_review', 'proof_uploaded', 'recurring_due', 'installment_edited', 'finance_approval_timing_alert', 'finance_approval_timing_recurring', 'system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement']),
                        Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'request_returned', 'request_on_hold'])
                    )
                )
            ).count()
        elif user.name == 'Abdalaziz Al-Brashdi':
            # Abdalaziz gets finance notifications + new_submission from GM/Operation Manager/Finance Staff + updates on Finance Staff, GM, and Operation Manager requests
            return Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.is_read == False,
                    db.or_(
                        Notification.notification_type.in_(['ready_for_finance_review', 'proof_uploaded', 'recurring_due', 'installment_edited', 'finance_approval_timing_alert', 'finance_approval_timing_recurring', 'system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement']),
                        Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'request_returned', 'request_on_hold']),
                        # new_submission only for GM, Operation Manager, Finance Staff, or CEO (his assigned managers)
                        db.and_(
                            Notification.notification_type == 'new_submission',
                            Notification.request_id.isnot(None),
                            db.exists().where(
                                db.and_(
                                    PaymentRequest.request_id == Notification.request_id,
                                    PaymentRequest.user_id == User.user_id,
                                    User.role.in_(['GM', 'CEO', 'Operation Manager', 'Finance Staff'])
                                )
                            )
                        )
                    )
                )
            ).count()
        else:  # Other Finance Admin
            return Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.is_read == False,
                    db.or_(
                        Notification.notification_type.in_(['ready_for_finance_review', 'proof_uploaded', 'recurring_due', 'installment_edited', 'finance_approval_timing_alert', 'finance_approval_timing_recurring', 'system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement', 'request_on_hold']),
                        Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'request_returned', 'request_on_hold'])
                    )
                )
            ).count()
    
    elif user.role in ['GM', 'CEO']:
        # GM: New submissions from ALL requests (all roles/departments) + updates on their own requests + system-wide + item requests
        return Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                Notification.is_read == False,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',
                    Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'finance_note_added', 'one_time_payment_scheduled', 'request_returned', 'request_on_hold', 'item_request_updated', 'item_request_assigned']),
                    Notification.notification_type.in_(['system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement']),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).count()
    
    elif user.role == 'Operation Manager':
        # Operation Manager: New submissions from ALL requests (all roles/departments) + updates on their own requests + system-wide + item requests
        return Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                Notification.is_read == False,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',
                    Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'request_returned', 'request_on_hold', 'item_request_updated', 'item_request_assigned']),
                    Notification.notification_type.in_(['system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement']),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).count()
    
    elif user.role == 'Department Manager' and user.department == 'IT':
        # IT Department Manager: New submissions from IT Staff only + updates on their own requests + system-wide + user management + temporary manager assignments + item requests
        return Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                Notification.is_read == False,
                db.or_(
                    # Item request submissions (for procurement item requests)
                    Notification.notification_type == 'item_request_submission',
                    # new_submission only if it's from IT Staff (join with PaymentRequest to check)
                    db.and_(
                        Notification.notification_type == 'new_submission',
                        Notification.request_id.isnot(None),
                        db.or_(
                            # Request created by IT Staff (check user role)
                            db.exists().where(
                                db.and_(
                                    PaymentRequest.request_id == Notification.request_id,
                                    PaymentRequest.department == 'IT',
                                    User.user_id == PaymentRequest.user_id,
                                    User.role == 'IT Staff'
                                )
                            ),
                            # Or request from IT department (fallback for existing notifications)
                            Notification.message.contains('IT')
                        )
                    ),
                    Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'user_created', 'user_updated', 'user_deleted', 'finance_note_added', 'request_archived', 'request_restored', 'request_permanently_deleted', 'one_time_payment_scheduled', 'request_returned', 'request_on_hold', 'item_request_updated']),
                    Notification.notification_type.in_(['system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement']),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).count()
    
    elif user.role == 'IT Staff':
        # IT Staff: Updates on their own requests + system-wide + user management + request archives + item request submissions
        return Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                Notification.is_read == False,
                db.or_(
                    # Item request submissions (for procurement item requests)
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'status_changed', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'user_created', 'user_updated', 'user_deleted', 'finance_note_added', 'request_archived', 'request_restored', 'request_permanently_deleted', 'one_time_payment_scheduled', 'request_returned', 'request_on_hold', 'item_request_updated']),
                    Notification.notification_type.in_(['system_maintenance', 'system_update', 'security_alert', 'system_error', 'admin_announcement']),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).count()
    
    elif user.role == 'Department Manager':
        # Other Department Managers: New submissions from their own department staff only + recurring payment due for their department + updates on their own requests + item requests
        return Notification.query.filter(
            db.and_(
                Notification.user_id == user.user_id,
                Notification.is_read == False,
                db.or_(
                    Notification.notification_type == 'item_request_submission',
                    Notification.notification_type == 'new_submission',  # Simplified - same as get_notifications_for_user
                    Notification.notification_type == 'recurring_due',
                    Notification.notification_type.in_([
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'proof_required', 'recurring_approved', 'request_completed',
                        'installment_paid', 'one_time_payment_scheduled', 'item_request_assigned', 'item_request_updated',
                        'request_returned', 'request_on_hold', 'request_pending_approval'
                    ]),
                    Notification.notification_type.in_(['temporary_manager_assignment', 'temporary_manager_unassigned'])
                )
            )
        ).count()
    
    else:
        # Department Staff: Updates on their own requests only + recurring payment due for their own requests + item request assignments
        # Also include temporary_manager_assignment so department users see when a temp manager is set/removed
        # Check if user is a temporary manager for item requests - if so, include all item request notifications
        is_temp_manager_for_items = False
        try:
            temp_item_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).first()
            is_temp_manager_for_items = temp_item_assignments is not None
        except Exception:
            pass
        
        if is_temp_manager_for_items:
            # Temporary managers for item requests should see all item request notifications
            return Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.is_read == False,
                    Notification.notification_type.in_([
                        'item_request_submission', 'item_request_assigned', 'item_request_updated',
                        'request_approved', 'request_rejected', 'request_pending_approval',
                        'request_on_hold', 'request_returned',
                        'request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected',
                        'status_changed', 'recurring_due', 'proof_required', 'recurring_approved',
                        'request_completed', 'installment_paid', 'finance_note_added', 'one_time_payment_scheduled',
                        'temporary_manager_assignment', 'temporary_manager_unassigned',
                        'new_submission'
                    ])
                )
            ).count()
        else:
            return Notification.query.filter(
                db.and_(
                    Notification.user_id == user.user_id,
                    Notification.is_read == False,
                    Notification.notification_type.in_(['request_rejected', 'request_approved', 'proof_uploaded', 'proof_rejected', 'status_changed', 'recurring_due', 'proof_required', 'recurring_approved', 'request_completed', 'installment_paid', 'one_time_payment_scheduled', 'item_request_assigned', 'item_request_updated', 'request_returned', 'request_on_hold', 'request_pending_approval', 'temporary_manager_assignment', 'temporary_manager_unassigned', 'new_submission', 'item_request_submission'])
                )
            ).count()

def notify_finance_and_admin(title, message, notification_type, request_id=None):
    """Notify Finance and Admin users about new submissions"""
    # Get all Finance and Admin users
    finance_admin_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
    
    for user in finance_admin_users:
        create_notification(
            user_id=user.user_id,
            title=title,
            message=message,
            notification_type=notification_type,
            request_id=request_id
        )
    
    # Emit real-time notification to all users
    socketio.emit('new_notification', {
        'title': title,
        'message': message,
        'type': notification_type,
        'request_id': request_id
    }, room='all_users')
    
    # Also emit a general update event to trigger notification count updates
    socketio.emit('notification_update', {
        'action': 'new_notification',
        'type': notification_type
    }, room='all_users')
    
    # Emit to specific role rooms based on notification type
    if notification_type == 'ready_for_finance_review':
        socketio.emit('notification_update', {
            'action': 'new_notification',
            'type': notification_type
        }, room='finance_admin')
    elif notification_type == 'new_submission':
        # Emit to appropriate role rooms based on requestor role
        if request and hasattr(request, 'user'):
            requestor_role = request.user.role
            if requestor_role == 'Department Manager':
                socketio.emit('notification_update', {
                    'action': 'new_notification',
                    'type': notification_type
                }, room='gm')
            elif requestor_role in ['Operation Staff', 'Branch Inventory Officer']:
                socketio.emit('notification_update', {
                    'action': 'new_notification',
                    'type': notification_type
                }, room='operation_manager')
            elif requestor_role == 'IT Staff':
                socketio.emit('notification_update', {
                    'action': 'new_notification',
                    'type': notification_type
                }, room='it_staff')
            elif requestor_role.endswith(' Staff'):
                socketio.emit('notification_update', {
                    'action': 'new_notification',
                    'type': notification_type
                }, room='department_managers')


def emit_request_update_to_all_rooms(event_name, data):
    """Helper function to emit request updates to all relevant rooms"""
    try:
        # Emit to all users
        socketio.emit(event_name, data, room='all_users')
        
        # Emit to specific role rooms
        socketio.emit(event_name, data, room='finance_admin')
        socketio.emit(event_name, data, room='department_staff')
        socketio.emit(event_name, data, room='department_managers')
        socketio.emit(event_name, data, room='gm')
        socketio.emit(event_name, data, room='operation_manager')
        socketio.emit(event_name, data, room='it_staff')
        socketio.emit(event_name, data, room='project_staff')
        
        print(f"DEBUG: Emitted {event_name} to all relevant rooms")
    except Exception as e:
        print(f"Error emitting {event_name} to all rooms: {e}")

def allowed_file(filename):
    """Check if file extension is allowed"""
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']


# ==================== AUTHENTICATION ROUTES ====================

@app.route('/')
def index():
    """Redirect to login or dashboard"""
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    return redirect(url_for('login'))


@app.route('/verify_pin', methods=['POST'])
def verify_pin():
    """Verify PIN via AJAX - returns JSON response"""
    try:
        data = request.get_json()
        username = data.get('username')
        pin = data.get('pin')
        
        if not username or not pin:
            return jsonify({
                'success': False,
                'message': 'Username and PIN are required.'
            })
        
        user = User.query.filter_by(username=username).first()
        
        if not user:
            return jsonify({
                'success': False,
                'message': 'User not found.'
            })
        
        # Check if account is locked
        if user.is_account_locked():
            return jsonify({
                'success': False,
                'message': 'Your account has been locked due to too many failed login attempts. Please contact IT Staff to unlock your account.',
                'account_locked': True
            })
        
        # Check if PIN exists in session
        stored_pin = session.get('temp_login_pin')
        stored_username = session.get('temp_pin_username')
        pin_expires = session.get('temp_pin_expires')
        
        if not stored_pin or stored_username != username:
            return jsonify({
                'success': False,
                'message': 'No PIN generated or session expired. Please try logging in again.',
                'session_expired': True
            })
        
        # Check if PIN is expired
        if datetime.utcnow().timestamp() > pin_expires:
            # Clear expired session data
            session.pop('temp_login_pin', None)
            session.pop('temp_pin_username', None)
            session.pop('temp_pin_expires', None)
            return jsonify({
                'success': False,
                'message': 'PIN has expired. Please request a new one by logging in again.',
                'pin_expired': True
            })
        
        # Verify PIN
        if check_password_hash(stored_pin, pin):
            # Clear session PIN data
            session.pop('temp_login_pin', None)
            session.pop('temp_pin_username', None)
            session.pop('temp_pin_expires', None)
            
            # Reset failed login attempts on successful login
            user.reset_failed_login()
            login_user(user, remember=False)  # Session-only: expires when browser closes
            # Set activity timestamp and session start time (session is non-permanent, expires on browser close)
            # Generate unique tab session ID for tab-specific session tracking
            try:
                session.permanent = False  # Session cookie expires when browser closes
                now_ts = datetime.utcnow().timestamp()
                session['last_activity'] = now_ts
                session['session_start'] = now_ts  # Track when this session started
                # Generate unique tab session ID
                tab_session_id = f"{random.randint(100000, 999999)}{now_ts}{random.randint(100000, 999999)}"
                session['tab_session_id'] = tab_session_id
            except Exception:
                pass
            log_action(f"User {username} logged in successfully with email PIN")
            
            return jsonify({
                'success': True,
                'message': f'Welcome back, {user.name}!',
                'redirect_url': url_for('dashboard'),
                'tab_session_id': session.get('tab_session_id')
            })
        else:
            # Invalid PIN - increment failed attempts
            user.increment_failed_login()
            remaining_attempts = 5 - user.failed_login_attempts
            
            if user.is_account_locked():
                # Clear session data
                session.pop('temp_login_pin', None)
                session.pop('temp_pin_username', None)
                session.pop('temp_pin_expires', None)
                log_action(f"Account locked due to failed PIN attempts: {username}")
                return jsonify({
                    'success': False,
                    'message': 'Too many failed login attempts. Your account has been locked. Please contact IT Staff to unlock your account.',
                    'account_locked': True
                })
            else:
                log_action(f"Failed PIN attempt for user: {username} ({remaining_attempts} attempts remaining)")
                return jsonify({
                    'success': False,
                    'message': f'Wrong PIN. You have {remaining_attempts} attempt(s) remaining before your account is locked.',
                    'remaining_attempts': remaining_attempts
                })
    
    except Exception as e:
        app.logger.error(f"PIN verification error: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'message': 'An error occurred. Please try again.'
        })


@app.route('/login', methods=['GET', 'POST'])
def login():
    """Login page"""
    # Ensure a default IT user exists if database is empty
    try:
        if User.query.count() == 0:
            default_it = User(
                name='Default IT',
                username='it@system.local',
                department='IT',
                role='IT Staff',
                email='it@system.local'
            )
            default_it.set_password('admin123')
            db.session.add(default_it)
            db.session.commit()
            app.logger.info('Default IT user created: it@system.local / admin123')
    except Exception as _e:
        # If DB not ready or other issue, continue to login page without blocking
        pass
    # If user is authenticated but session doesn't have last_activity or session_start, it's a stale session
    # Clear it and force re-login
    if current_user.is_authenticated:
        if 'last_activity' not in session or 'session_start' not in session:
            try:
                logout_user()
                # Clear only the session keys we care about, not the entire session
                # This prevents issues with Flask's session initialization
                session.pop('last_activity', None)
                session.pop('session_start', None)
                session.pop('user_id', None)  # Flask-Login's session key
                session.pop('_permanent', None)  # Flask's permanent session flag
            except Exception as e:
                app.logger.error(f"Error clearing stale session: {str(e)}", exc_info=True)
            flash('Your session has expired. Please log in again.', 'info')
        else:
            # If already authenticated, Branch Manager / Supervisor should go to Item Requests
            try:
                if getattr(current_user, 'department', None) == 'Branch' and getattr(current_user, 'role', None) in ['Branch Manager', 'Supervisor']:
                    try:
                        session.pop('_flashes', None)
                        session['suppress_flashes_once'] = True
                        session.modified = True
                    except Exception:
                        pass
                    return redirect(url_for('procurement_item_requests'))
            except Exception:
                pass
            return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        pin = request.form.get('pin')
        bypass_pin = request.form.get('bypass_pin') == 'true'  # Development testing bypass
        
        # Debug logging
        app.logger.info(f"Login attempt: username={username}, pin_provided={bool(pin)}, bypass_pin={bypass_pin}")
        
        user = User.query.filter_by(username=username).first()
        
        # Debug user found
        app.logger.info(f"User found: {user is not None}, user_id: {user.user_id if user else 'None'}")
        
        # Check if account is locked
        if user and user.is_account_locked():
            flash('Your account has been locked due to too many failed login attempts. Please contact IT Staff to unlock your account.', 'danger')
            log_action(f"Login attempt for locked account: {username}")
            return render_template('login.html')
        
        # Verify password and temporary PIN
        if user and user.check_password(password):
            # Development testing bypass - skip PIN verification
            if bypass_pin:
                app.logger.warning(f"‚ö†Ô∏è DEVELOPMENT MODE: PIN bypassed for {username} - THIS SHOULD NOT BE IN PRODUCTION!")
                # Reset failed login attempts on successful login
                user.reset_failed_login()
                login_user(user, remember=False)  # Session-only: expires when browser closes
                # Set activity timestamp and session start time (session is non-permanent, expires on browser close)
                # Generate unique tab session ID for tab-specific session tracking
                try:
                    session.permanent = False  # Session cookie expires when browser closes
                    now_ts = datetime.utcnow().timestamp()
                    session['last_activity'] = now_ts
                    session['session_start'] = now_ts  # Track when this session started
                    # Generate unique tab session ID
                    tab_session_id = f"{random.randint(100000, 999999)}{now_ts}{random.randint(100000, 999999)}"
                    session['tab_session_id'] = tab_session_id
                except Exception:
                    pass
                app.logger.warning(f"‚ö†Ô∏è User {username} logged in via DEVELOPMENT TESTING MODE (PIN bypassed)")
                log_action(f"‚ö†Ô∏è DEVELOPMENT: User {username} logged in successfully (PIN bypassed via testing button)")
                flash(f'‚ö†Ô∏è DEVELOPMENT MODE: Welcome back, {user.name}! (PIN bypassed)', 'warning')
                try:
                    if getattr(user, 'department', None) == 'Branch' and getattr(user, 'role', None) in ['Branch Manager', 'Supervisor']:
                        try:
                            session.pop('_flashes', None)
                            session['suppress_flashes_once'] = True
                            session.modified = True
                        except Exception:
                            pass
                        return redirect(url_for('procurement_item_requests'))
                except Exception:
                    pass
                return redirect(url_for('dashboard'))
            
            # Special case: IT system account and test admin bypass PIN requirement
            if username in ['it@system.local', 'testadmin@maagroup.om']:
                app.logger.info(f"System account bypass triggered for {username}")
                # Reset failed login attempts on successful login
                user.reset_failed_login()
                login_user(user, remember=False)  # Session-only: expires when browser closes
                # Set activity timestamp and session start time (session is non-permanent, expires on browser close)
                # Generate unique tab session ID for tab-specific session tracking
                try:
                    session.permanent = False  # Session cookie expires when browser closes
                    now_ts = datetime.utcnow().timestamp()
                    session['last_activity'] = now_ts
                    session['session_start'] = now_ts  # Track when this session started
                    # Generate unique tab session ID
                    tab_session_id = f"{random.randint(100000, 999999)}{now_ts}{random.randint(100000, 999999)}"
                    session['tab_session_id'] = tab_session_id
                except Exception:
                    pass
                app.logger.info(f"System user logged in successfully, redirecting to dashboard")
                log_action(f"System account {username} logged in successfully (PIN bypassed)")
                flash(f'Welcome back, {user.name}!', 'success')
                try:
                    if getattr(user, 'department', None) == 'Branch' and getattr(user, 'role', None) in ['Branch Manager', 'Supervisor']:
                        try:
                            session.pop('_flashes', None)
                            session['suppress_flashes_once'] = True
                            session.modified = True
                        except Exception:
                            pass
                        return redirect(url_for('procurement_item_requests'))
                except Exception:
                    pass
                return redirect(url_for('dashboard'))
            
            # Check if PIN exists in session
            stored_pin = session.get('temp_login_pin')
            stored_username = session.get('temp_pin_username')
            pin_expires = session.get('temp_pin_expires')
            
            if not stored_pin or stored_username != username:
                flash('No PIN generated or session expired. Please try logging in again.', 'danger')
                return render_template('login.html')
            
            # Check if PIN is expired
            if datetime.utcnow().timestamp() > pin_expires:
                # Clear expired session data
                session.pop('temp_login_pin', None)
                session.pop('temp_pin_username', None)
                session.pop('temp_pin_expires', None)
                flash('PIN has expired. Please request a new one by logging in again.', 'danger')
                return render_template('login.html')
            
            # Verify PIN
            if check_password_hash(stored_pin, pin):
                # Clear session PIN data
                session.pop('temp_login_pin', None)
                session.pop('temp_pin_username', None)
                session.pop('temp_pin_expires', None)
                
                # Reset failed login attempts on successful login
                user.reset_failed_login()
                login_user(user, remember=False)  # Session-only: expires when browser closes
                # Set activity timestamp and session start time (session is non-permanent, expires on browser close)
                # Generate unique tab session ID for tab-specific session tracking
                try:
                    session.permanent = False  # Session cookie expires when browser closes
                    now_ts = datetime.utcnow().timestamp()
                    session['last_activity'] = now_ts
                    session['session_start'] = now_ts  # Track when this session started
                    # Generate unique tab session ID
                    tab_session_id = f"{random.randint(100000, 999999)}{now_ts}{random.randint(100000, 999999)}"
                    session['tab_session_id'] = tab_session_id
                except Exception:
                    pass
                log_action(f"User {username} logged in successfully with email PIN")
                flash(f'Welcome back, {user.name}!', 'success')
                return redirect(url_for('dashboard'))
            else:
                # Invalid PIN - increment failed attempts but stay in modal
                user.increment_failed_login()
                remaining_attempts = 5 - user.failed_login_attempts
                
                if user.is_account_locked():
                    # Clear session data and redirect to login with error
                    session.pop('temp_login_pin', None)
                    session.pop('temp_pin_username', None)
                    session.pop('temp_pin_expires', None)
                    flash(f'Too many failed login attempts. Your account has been locked. Please contact IT Staff to unlock your account.', 'danger')
                    log_action(f"Account locked due to failed PIN attempts: {username}")
                    return render_template('login.html')
                else:
                    # Return error message that will be handled by JavaScript
                    flash(f'Invalid PIN. You have {remaining_attempts} attempt(s) remaining before your account is locked.', 'danger')
                    log_action(f"Failed PIN attempt for user: {username} ({remaining_attempts} attempts remaining)")
                    return render_template('login.html')
        else:
            # Invalid password
            if user:
                user.increment_failed_login()
                remaining_attempts = 5 - user.failed_login_attempts
                
                if user.is_account_locked():
                    flash(f'Too many failed login attempts. Your account has been locked. Please contact IT Staff to unlock your account.', 'danger')
                    log_action(f"Account locked due to failed login attempts: {username}")
                elif remaining_attempts > 0:
                    flash(f'Invalid email address or password. You have {remaining_attempts} attempt(s) remaining before your account is locked.', 'danger')
                    log_action(f"Failed login attempt for user: {username} ({remaining_attempts} attempts remaining)")
            else:
                flash('Invalid email address or password', 'danger')
                log_action(f"Failed login attempt for non-existent user: {username}")
    
    return render_template('login.html')


@app.route('/validate_credentials', methods=['POST'])
def validate_credentials():
    """Validate email and password before showing PIN modal"""
    try:
        data = request.get_json()
        username = data.get('username')
        password = data.get('password')
        
        if not username or not password:
            return jsonify({
                'success': False,
                'message': 'Email and password are required.'
            })
        
        user = User.query.filter_by(username=username).first()
        
        # Check if account is locked
        if user and user.is_account_locked():
            return jsonify({
                'success': False,
                'message': 'Your account has been locked due to too many failed login attempts. Please contact IT Staff to unlock your account.'
            })
        
        # Verify password only (not PIN yet)
        if user and user.check_password(password):
            # Special case: IT system account, test admin, or the user named "Super Admin" bypass PIN requirement
            if username in ['it@system.local', 'testadmin@maagroup.om'] or (user and getattr(user, 'name', None) == 'Super Admin'):
                return jsonify({
                    'success': True,
                    'message': 'System account or Super Admin - PIN bypassed. Redirecting to dashboard.',
                    'bypass_pin': True
                })
            
            # Check if user has email
            if not user.email:
                return jsonify({
                    'success': False,
                    'message': 'Your account does not have an email address set. Please contact IT Staff.'
                })
            
            # Generate a random 4-digit PIN
            pin = str(random.randint(1000, 9999))
            
            # Ensure session is properly initialized before storing data
            try:
                # Store PIN in session (not database)
                session['temp_login_pin'] = generate_password_hash(pin)
                session['temp_pin_username'] = username
                session['temp_pin_expires'] = (datetime.utcnow() + timedelta(minutes=app.config.get('PIN_EXPIRY_MINUTES', 5))).timestamp()
                # Mark session as modified to ensure it's saved
                session.modified = True
            except Exception as session_error:
                app.logger.error(f"Error storing PIN in session: {str(session_error)}", exc_info=True)
                return jsonify({
                    'success': False,
                    'message': 'Failed to initialize login session. Please try again.'
                })
            
            # Send PIN via email
            success, message = send_pin_email(user.email, user.name, pin)
            
            if success:
                log_action(f"Login PIN sent to {username}")
                return jsonify({
                    'success': True,
                    'message': f'A 4-digit PIN has been sent to your email ({user.email}). Please check your email and enter the PIN to continue.'
                })
            else:
                # Clear session data if email fails
                session.pop('temp_login_pin', None)
                session.pop('temp_pin_username', None)
                session.pop('temp_pin_expires', None)
                return jsonify({
                    'success': False,
                    'message': f'Failed to send PIN to your email. Please try again or contact IT Staff. Error: {message}'
                })
        else:
            # Invalid credentials - increment failed attempts
            if user:
                user.increment_failed_login()
                remaining_attempts = 5 - user.failed_login_attempts
                
                if user.is_account_locked():
                    log_action(f"Account locked due to failed login attempts: {username}")
                    return jsonify({
                        'success': False,
                        'message': 'Too many failed login attempts. Your account has been locked. Please contact IT Staff to unlock your account.'
                    })
                elif remaining_attempts > 0:
                    log_action(f"Failed login attempt for user: {username} ({remaining_attempts} attempts remaining)")
                    return jsonify({
                        'success': False,
                        'message': f'Invalid email address or password. You have {remaining_attempts} attempt(s) remaining before your account is locked.'
                    })
            else:
                log_action(f"Failed login attempt for non-existent user: {username}")
                return jsonify({
                    'success': False,
                    'message': 'Invalid email address or password.'
                })
    
    except Exception as e:
        app.logger.error(f"Validate credentials error: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'message': 'An error occurred. Please try again.'
        })


@app.route('/check_tab_session', methods=['POST'])
def check_tab_session():
    """Check if the client's tab session ID matches the server's session"""
    try:
        if not current_user.is_authenticated:
            return jsonify({'valid': False, 'message': 'Not authenticated'})
        
        data = request.get_json()
        client_tab_session_id = data.get('tab_session_id')
        server_tab_session_id = session.get('tab_session_id')
        
        if not server_tab_session_id:
            # Server doesn't have a tab session ID - invalidate
            try:
                logout_user()
            except Exception:
                pass
            session.clear()
            return jsonify({'valid': False, 'message': 'Session expired'})
        
        if client_tab_session_id != server_tab_session_id:
            # Tab session IDs don't match - this is a different tab, invalidate
            try:
                logout_user()
            except Exception:
                pass
            session.clear()
            return jsonify({'valid': False, 'message': 'Tab session mismatch'})
        
        return jsonify({'valid': True, 'tab_session_id': server_tab_session_id})
    except Exception as e:
        app.logger.error(f"Tab session check error: {str(e)}", exc_info=True)
        return jsonify({'valid': False, 'message': 'Error checking session'})


@app.route('/logout')
def logout():
    """Logout current user - allow logout even if not authenticated (for tab session cleanup)"""
    try:
        if current_user.is_authenticated:
            log_action(f"User {current_user.username} logged out")
            logout_user()
    except Exception:
        pass
    # Clear all session data including tab_session_id
    session.clear()
    flash('You have been logged out successfully.', 'info')
    return redirect(url_for('login'))


# ==================== DASHBOARD ROUTES ====================

@app.route('/dashboard')
@login_required
def dashboard():
    """Main dashboard - routes to appropriate dashboard based on role"""
    role = current_user.role
    
    if role == 'Finance Admin':
        return redirect(url_for('admin_dashboard'))
    elif role == 'Finance Staff':
        return redirect(url_for('finance_dashboard'))
    elif role == 'GM':
        return redirect(url_for('gm_dashboard'))
    elif role == 'CEO':
        return redirect(url_for('ceo_dashboard'))
    elif role == 'IT Staff':
        return redirect(url_for('it_dashboard'))
    elif role == 'Department Manager':
        # Route department managers to their specific dashboards
        # Normalize department value (strip whitespace and handle case)
        dept = current_user.department.strip() if current_user.department else ''
        
        if dept == 'IT':
            return redirect(url_for('it_dashboard'))
        elif dept.lower() == 'procurement':
            return redirect(url_for('procurement_dashboard'))
        elif dept.lower() in ['project', 'projects']:
            return redirect(url_for('project_dashboard'))
        else:
            return redirect(url_for('department_dashboard'))
    elif role == 'Project Staff':
        return redirect(url_for('project_dashboard'))
    elif role == 'Operation Manager':
        return redirect(url_for('operation_dashboard'))
    elif role == 'Procurement Staff':
        return redirect(url_for('procurement_dashboard'))
    elif role in ['HR Staff', 'PR Staff', 'Auditing Staff', 
                  'Customer Service Staff', 'Marketing Staff', 'Operation Staff', 'Branch Inventory Officer',
                  'Quality Control Staff', 'Research and Development Staff', 
                  'Office Staff', 'Maintenance Staff', 'Logistic Staff']:
        return redirect(url_for('department_dashboard'))
    else:
        # Check if user has Procurement department - route all Procurement users to their dashboard
        # Normalize department value (strip whitespace and handle case)
        dept = current_user.department.strip() if current_user.department else ''
        if dept.lower() == 'procurement':
            return redirect(url_for('procurement_dashboard'))
        # Fallback for any unrecognized roles
        # For Branch Manager/Supervisor, redirect to Item Requests instead of flashing
        try:
            if getattr(current_user, 'department', None) == 'Branch' and getattr(current_user, 'role', None) in ['Branch Manager', 'Supervisor']:
                session.pop('_flashes', None)
                session['suppress_flashes_once'] = True
                session.modified = True
                return redirect(url_for('procurement_item_requests'))
        except Exception:
            pass
        flash('Your role is not properly configured. Please contact IT.', 'warning')
        return redirect(url_for('department_dashboard'))


@app.route('/department/dashboard')
@login_required
def department_dashboard():
    """Dashboard for department users, finance, and project users"""
    # Access control: allow the same static roles as before OR any user who is currently
    # assigned as a department-level temporary manager for at least one department.
    allowed_roles = {
        'HR Staff', 'PR Staff', 'Auditing Staff',
        'Customer Service Staff', 'Marketing Staff', 'Operation Staff', 'Branch Inventory Officer', 'Quality Control Staff',
        'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Logistic Staff',
        'Department Manager', 'Operation Manager'
    }
    try:
        # Check if user is a temporary manager for payment requests (Finance Payment Request or Both)
        is_temp_manager_any = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
            db.or_(
                DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).first() is not None
    except Exception:
        is_temp_manager_any = False
    # Compute list of departments the current user temporarily manages for PAYMENT REQUESTS (for UI filters)
    # Only include departments where user is assigned for "Finance Payment Request" or "Both Payment and Item Request"
    try:
        temp_departments = [
            dt.department.strip() 
            for dt in DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all() 
            if dt.department
        ]
    except Exception:
        temp_departments = []

    if current_user.role not in allowed_roles and not is_temp_manager_any:
        # keep existing behavior of denying access to unauthorized roles
        abort(403)
    """Dashboard for department users, finance, and project users"""
    # Redirect Procurement Department Managers to their dedicated dashboard
    dept = current_user.department.strip() if current_user.department else ''
    if current_user.role == 'Department Manager' and dept.lower() == 'procurement':
        return redirect(url_for('procurement_dashboard'))
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search_query = request.args.get('search', None)
    status_filter = request.args.get('status', None)
    tab = request.args.get('tab', 'all')
    # For Auditing Staff, allow access to all relevant tabs; 'all' is filtered to Completed/Recurring
    if current_user.department == 'Auditing' and current_user.role == 'Auditing Staff' and tab not in ['all', 'completed', 'my_requests', 'rejected', 'recurring']:
        tab = 'all'
    # Enforce visibility: only Auditing department users can access 'my_requests' tab
    if tab == 'my_requests' and (not current_user.department or current_user.department != 'Auditing'):
        tab = 'all'
    urgent_filter = request.args.get('urgent', None)
    department_filter = request.args.get('department', None)
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # For Department Managers and Operation Managers, show requests from their departments
    if current_user.role in ['Department Manager', 'Operation Manager']:
        # Get requests from their department(s) (including completed/paid ones)
        if current_user.role == 'Operation Manager':
            # Operation Manager can see ALL departments (exclude archived and drafts)
            base_query = PaymentRequest.query.filter(
                PaymentRequest.is_archived == False,
                PaymentRequest.is_draft == False
            )
        elif current_user.department == 'Auditing':
            # Auditing Department Manager can see:
            # 1. All their own requests (regardless of status or department)
            # 2. All requests from Auditing department (as department manager)
            # 3. Completed and Recurring requests from OTHER departments (view-only)
            # 4. Any request where they are the temporary manager
            # 5. Any request where they are an authorized manager approver (even if department changed)
            # Exclude archived requests and drafts
            all_non_archived = PaymentRequest.query.filter(
                PaymentRequest.is_archived == False,
                PaymentRequest.is_draft == False
            ).all()
            
            visible_request_ids = set()
            
            for req in all_non_archived:
                # Their own requests
                if req.user_id == current_user.user_id:
                    visible_request_ids.add(req.request_id)
                
                # Auditing department requests - only if BOTH request department AND requestor's department match
                # This prevents showing requests where department was changed but requestor is from different department
                req_dept = (req.department or '').strip()
                requestor_dept = (req.user.department or '').strip() if req.user else ''
                if req_dept.lower() == 'auditing' and requestor_dept.lower() == 'auditing':
                    visible_request_ids.add(req.request_id)
                
                # Temporary manager (per-request)
                if req.temporary_manager_id == current_user.user_id:
                    visible_request_ids.add(req.request_id)
                # Department-level temporary manager (assignment in settings) - include requests from departments
                try:
                    dt = DepartmentTemporaryManager.query.filter(
                        DepartmentTemporaryManager.department == (req.department or ''),
                        db.or_(
                            DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                            DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                        )
                    ).first()
                except Exception:
                    dt = None
                if dt and getattr(dt, 'temporary_manager_id', None) == current_user.user_id:
                    visible_request_ids.add(req.request_id)
                
                # Completed/Recurring and proof-related statuses from other departments (view-only)
                if req_dept.lower() != 'auditing' and req.status in [
                    'Completed', 'Recurring', 'Proof Pending', 'Proof Sent', 'Proof Rejected'
                ]:
                    visible_request_ids.add(req.request_id)
                
                # Authorized approver (handles cases where department was edited)
                authorized_approvers = get_authorized_manager_approvers(req)
                if current_user in authorized_approvers:
                    visible_request_ids.add(req.request_id)
            
            # Build query with all visible request IDs
            if visible_request_ids:
                base_query = PaymentRequest.query.filter(
                    PaymentRequest.request_id.in_(visible_request_ids),
                    PaymentRequest.is_archived == False,
                    PaymentRequest.is_draft == False
                )
            else:
                # No requests visible - return empty query
                base_query = PaymentRequest.query.filter(
                    PaymentRequest.request_id == -1  # Impossible condition
                )
        else:
            # Other Department Managers can see:
            # 1. Requests where BOTH the request department AND requestor's department match (normal case)
            # 2. Requests where they are the temporary manager
            # 3. Requests where they are an authorized manager approver (even if department was changed)
            # Exclude archived requests
            user_dept = current_user.department.strip() if current_user.department else ''
            
            # First, get all non-archived requests to check for authorized approver status
            all_non_archived = PaymentRequest.query.filter(
                PaymentRequest.is_archived == False
            ).all()
            
            # Find requests where user is an authorized approver (handles cases where department was edited)
            authorized_request_ids = set()
            department_match_ids = set()
            temp_manager_ids = set()
            
            # First, get all departments where current user is a temporary manager for payment requests
            temp_manager_payment_depts = set()
            try:
                temp_assignments = DepartmentTemporaryManager.query.filter(
                    DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                    db.or_(
                        DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                        DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                    )
                ).all()
                for ta in temp_assignments:
                    if ta.department:
                        temp_manager_payment_depts.add(ta.department.strip().lower())
                print(f"DEBUG: User is temp manager for payment requests in departments: {temp_manager_payment_depts}")
            except Exception as e:
                print(f"DEBUG: Error getting temp manager departments: {e}")
            
            for req in all_non_archived:
                # Check if requestor's department matches (this ensures we only show requests from their department)
                requestor_dept = (req.user.department or '').strip() if req.user else ''
                req_dept = (req.department or '').strip()
                
                # Only include if BOTH request department AND requestor's department match
                # This prevents showing requests where department was changed but requestor is from different department
                if req_dept.lower() == user_dept.lower() and requestor_dept.lower() == user_dept.lower():
                    department_match_ids.add(req.request_id)
                
                # Check per-request temporary manager
                if req.temporary_manager_id == current_user.user_id:
                    temp_manager_ids.add(req.request_id)
                
                # Check department-level temporary manager assignment for this request's department
                # For PAYMENT REQUESTS, check for "Finance Payment Request" or "Both Payment and Item Request"
                # Use case-insensitive matching to include ALL requests (old and new) from assigned departments
                req_dept_normalized = req_dept.lower().strip() if req_dept else ''
                if req_dept_normalized and req_dept_normalized in temp_manager_payment_depts:
                    # User is assigned as temp manager for this department - include ALL requests from this department
                    temp_manager_ids.add(req.request_id)
                    print(f"DEBUG: Added payment request {req.request_id} to temp_manager_ids (dept: {req_dept}, normalized: {req_dept_normalized})")
                
                # Check if user is an authorized approver (based on requestor, not request department)
                authorized_approvers = get_authorized_manager_approvers(req)
                if current_user in authorized_approvers:
                    authorized_request_ids.add(req.request_id)
            
            # Combine all request IDs
            all_visible_ids = department_match_ids | temp_manager_ids | authorized_request_ids
            
            # Build query with all visible request IDs
            if all_visible_ids:
                base_query = PaymentRequest.query.filter(
                    PaymentRequest.request_id.in_(all_visible_ids),
                    PaymentRequest.is_archived == False,
                    PaymentRequest.is_draft == False
                )
            else:
                # No requests visible - return empty query
                base_query = PaymentRequest.query.filter(
                    PaymentRequest.request_id == -1  # Impossible condition
                )
    elif current_user.department == 'Auditing' and current_user.role == 'Auditing Staff':
        # Auditing Staff can see:
        # 1. All their own requests (regardless of status or department)
        # 2. Completed and Recurring requests from OTHER departments (view-only)
        # Exclude archived requests and drafts
        base_query = PaymentRequest.query.filter(
            db.or_(
                PaymentRequest.user_id == current_user.user_id,
                db.and_(
                    PaymentRequest.department != 'Auditing',
                    PaymentRequest.status.in_(['Completed', 'Recurring', 'Proof Pending', 'Proof Sent', 'Proof Rejected'])
                )
            ),
            PaymentRequest.is_archived == False,
            PaymentRequest.is_draft == False
        )
    else:
        # For regular users, show their own requests (exclude archived and drafts)
        # If the user is currently assigned as a department-level temporary manager,
        # include requests for the departments they temporarily manage (only when assignment exists).
        if is_temp_manager_any:
            try:
                # Only include departments where user is assigned for "Finance Payment Request" or "Both Payment and Item Request"
                temp_departments = [
                    dt.department.strip() 
                    for dt in DepartmentTemporaryManager.query.filter(
                        DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                        db.or_(
                            DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                            DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                        )
                    ).all() 
                    if dt.department
                ]
            except Exception:
                temp_departments = []
            if temp_departments:
                print(f"DEBUG: Building base_query for temp manager. temp_departments: {temp_departments}")
                # Build case-insensitive department filter using OR conditions
                # Include ALL requests from assigned departments (both old and new), regardless of requestor's department
                dept_conditions = []
                for dept in temp_departments:
                    dept_normalized = dept.strip().lower()
                    # Match by request department only (case-insensitive) - include ALL requests from this department
                    dept_conditions.append(
                        db.func.lower(db.func.trim(PaymentRequest.department)) == dept_normalized
                    )
                
                if dept_conditions:
                    dept_filter = db.or_(*dept_conditions)
                else:
                    dept_filter = db.false()  # No departments, no matches
                
                base_query = PaymentRequest.query.outerjoin(User, PaymentRequest.user_id == User.user_id).filter(
                    db.and_(
                        db.or_(
                            dept_filter,  # All requests from assigned departments
                            PaymentRequest.temporary_manager_id == current_user.user_id,  # Per-request temp manager
                            PaymentRequest.user_id == current_user.user_id  # Own requests
                        ),
                        PaymentRequest.is_archived == False,
                        PaymentRequest.is_draft == False
                    )
                )
                print(f"DEBUG: base_query built with {len(temp_departments)} temp_departments - will show ALL requests from these departments")
            else:
                base_query = PaymentRequest.query.filter(
                    PaymentRequest.user_id == current_user.user_id,
                    PaymentRequest.is_archived == False,
                    PaymentRequest.is_draft == False
                )
        else:
            base_query = PaymentRequest.query.filter(
                PaymentRequest.user_id == current_user.user_id,
                PaymentRequest.is_archived == False,
                PaymentRequest.is_draft == False
            )
    
    # Exclude CEO-submitted requests for non-authorized roles (visibility hardening)
    if current_user.role not in ['Finance Admin', 'GM', 'Operation Manager']:
        base_query = base_query.filter(~PaymentRequest.user.has(User.role == 'CEO'))

    # Apply urgent filter if provided (before tab filtering)
    if urgent_filter == 'urgent':
        base_query = base_query.filter(PaymentRequest.is_urgent == True)
    elif urgent_filter == 'not_urgent':
        base_query = base_query.filter(PaymentRequest.is_urgent == False)
    
    # Apply search filter if provided (before tab filtering)
    if search_query:
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            base_query = base_query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            base_query = base_query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = base_query.filter(PaymentRequest.status == 'Completed')
    elif tab == 'rejected':
        query = base_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = base_query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        # For 'my_requests' tab, show only the current user's requests
        query = base_query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        # 'all' tab - show ALL requests, but apply status filter if provided
        # For Auditing Staff, only show Completed and Recurring requests
        if current_user.department == 'Auditing' and current_user.role == 'Auditing Staff':
            query = base_query.filter(
                db.or_(
                    PaymentRequest.status.in_(['Completed', 'Proof Pending', 'Proof Sent', 'Proof Rejected']),
                    PaymentRequest.recurring == 'Recurring'
                )
            )
        else:
            query = base_query
            if status_filter:
                query = query.filter(PaymentRequest.status == status_filter)
    else:  # default - show ALL requests
        query = base_query
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    
    # Get separate queries for each tab content
    # For Auditing department users (Staff and Department Manager), include their own requests + other department's Completed/Recurring
    if current_user.department == 'Auditing' and (current_user.role == 'Auditing Staff' or current_user.role == 'Department Manager'):
        if current_user.role == 'Department Manager':
            # Auditing Department Manager can see:
            # 1. All their own requests
            # 2. All Auditing department requests (as manager)
            # 3. Completed/Recurring from other departments
            # Exclude archived requests
            completed_query = PaymentRequest.query.filter(
                db.or_(
                    PaymentRequest.user_id == current_user.user_id,
                    PaymentRequest.department == 'Auditing',
                    db.and_(
                        PaymentRequest.department != 'Auditing',
                        PaymentRequest.status.in_(['Completed', 'Proof Pending', 'Proof Sent', 'Proof Rejected'])
                    )
                ),
                PaymentRequest.is_archived == False
            )
            recurring_query = PaymentRequest.query.filter(
                db.or_(
                    PaymentRequest.user_id == current_user.user_id,
                    PaymentRequest.department == 'Auditing',
                    db.and_(
                        PaymentRequest.department != 'Auditing',
                        PaymentRequest.recurring == 'Recurring'
                    )
                ),
                PaymentRequest.is_archived == False
            )
            # Rejected query - their own rejected + Auditing department rejected (exclude archived)
            rejected_query = PaymentRequest.query.filter(
                db.or_(
                    db.and_(
                        PaymentRequest.user_id == current_user.user_id,
                        PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected'])
                    ),
                    db.and_(
                        PaymentRequest.department == 'Auditing',
                        PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected'])
                    )
                ),
                PaymentRequest.is_archived == False
            )
        else:
            # Auditing Staff (exclude archived)
            completed_query = PaymentRequest.query.filter(
                db.or_(
                    PaymentRequest.user_id == current_user.user_id,
                    db.and_(
                        PaymentRequest.department != 'Auditing',
                        PaymentRequest.status.in_(['Completed', 'Proof Pending', 'Proof Sent', 'Proof Rejected'])
                    )
                ),
                PaymentRequest.is_archived == False
            )
            recurring_query = PaymentRequest.query.filter(
                db.or_(
                    PaymentRequest.user_id == current_user.user_id,
                    db.and_(
                        PaymentRequest.department != 'Auditing',
                        PaymentRequest.recurring == 'Recurring'
                    )
                ),
                PaymentRequest.is_archived == False
            )
            # Rejected query - only their own rejected requests (not other departments' rejected) (exclude archived)
            rejected_query = PaymentRequest.query.filter(
                db.and_(
                    PaymentRequest.user_id == current_user.user_id,
                    PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']),
                    PaymentRequest.is_archived == False
                )
            )
    else:
        completed_query = base_query.filter(PaymentRequest.status == 'Completed')
        rejected_query = base_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
        recurring_query = base_query.filter(PaymentRequest.recurring == 'Recurring')
    
    # Apply urgent filter to separate queries
    if urgent_filter == 'urgent':
        completed_query = completed_query.filter(PaymentRequest.is_urgent == True)
        rejected_query = rejected_query.filter(PaymentRequest.is_urgent == True)
        recurring_query = recurring_query.filter(PaymentRequest.is_urgent == True)
    elif urgent_filter == 'not_urgent':
        completed_query = completed_query.filter(PaymentRequest.is_urgent == False)
        rejected_query = rejected_query.filter(PaymentRequest.is_urgent == False)
        recurring_query = recurring_query.filter(PaymentRequest.is_urgent == False)
    
    # Apply search filter to separate queries
    if search_query:
        try:
            search_id = int(search_query)
            completed_query = completed_query.filter(PaymentRequest.request_id == search_id)
            rejected_query = rejected_query.filter(PaymentRequest.request_id == search_id)
            recurring_query = recurring_query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            search_term = f'%{search_query}%'
            completed_query = completed_query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
            rejected_query = rejected_query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
            recurring_query = recurring_query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
    
    # Get data for each tab
    # For completed tab, paginate it instead of getting all records
    completed_pagination = None
    if tab == 'completed':
        completed_pagination = completed_query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        completed_requests = completed_pagination.items
    else:
        completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    
    rejected_requests = rejected_query.order_by(get_rejected_datetime_order()).all()
    recurring_requests = recurring_query.order_by(PaymentRequest.created_at.desc()).all()
    
    # Paginate the main query
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        # Completed tab sorted by approval_date (most recent first) - use completed_pagination
        requests_pagination = completed_pagination
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    # Get notifications for department managers and regular users
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('department_dashboard.html', 
                         requests=requests_pagination.items, 
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         completed_pagination=completed_pagination if tab == 'completed' else None,
                         user=current_user,
                         notifications=notifications,
                         unread_count=unread_count,
                         status_filter=status_filter,
                         department_filter=department_filter,
                         is_temp_manager_any=is_temp_manager_any,
                         temp_departments=temp_departments,
                         search_query=search_query,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         recurring_requests=recurring_requests,
                         urgent_filter=urgent_filter,
                         my_requests=my_requests_pagination.items,
                         active_tab=tab)


@app.route('/procurement/dashboard')
@login_required
def procurement_dashboard():
    """Dashboard for Procurement department users"""
    # Migrate: Add amount, receipt_path, and procurement_quantities columns to procurement_item_requests if they don't exist
    try:
        import sqlite3
        db_path = app.config['SQLALCHEMY_DATABASE_URI'].replace('sqlite:///', '')
        if os.name == 'nt':  # Windows
            db_path = db_path.replace('/', '\\')
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Check if columns exist
        cursor.execute("PRAGMA table_info(procurement_item_requests)")
        existing_columns = [row[1] for row in cursor.fetchall()]
        
        if 'amount' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN amount NUMERIC(10, 3)")
            conn.commit()
            print("‚úì Added 'amount' column to procurement_item_requests table")
        
        if 'receipt_path' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN receipt_path VARCHAR(255)")
            conn.commit()
            print("‚úì Added 'receipt_path' column to procurement_item_requests table")

        if 'procurement_quantities' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_quantities TEXT")
            conn.commit()
            print("‚úì Added 'procurement_quantities' column to procurement_item_requests table")
        
        conn.close()
    except Exception as e:
        print(f"Warning: Could not migrate columns: {e}")
    
    # Allow ALL users with Procurement department OR temporary managers for Procurement to access this dashboard
    # Normalize department value (strip whitespace and handle case)
    dept = current_user.department.strip() if current_user.department else ''
    is_procurement_user = dept.lower() == 'procurement'
    
    # Check if user is a temporary manager for Procurement department (payment requests)
    is_temp_manager_for_procurement = False
    try:
        temp_procurement = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
            db.func.lower(db.func.trim(DepartmentTemporaryManager.department)) == 'procurement',
            db.or_(
                DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).first()
        is_temp_manager_for_procurement = temp_procurement is not None
        print(f"DEBUG: procurement_dashboard - is_procurement_user: {is_procurement_user}, is_temp_manager_for_procurement: {is_temp_manager_for_procurement}")
    except Exception as e:
        print(f"DEBUG: Error checking temp manager for procurement: {e}")
    
    if not is_procurement_user and not is_temp_manager_for_procurement:
        session['permission_denied'] = 'You do not have permission to access this page. This dashboard is only for Procurement department users or temporary managers for Procurement.'
        return redirect(url_for('dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    search_query = request.args.get('search', None)
    status_filter = request.args.get('status', None)
    tab = request.args.get('tab', 'all')
    urgent_filter = request.args.get('urgent', None)
    department_filter = request.args.get('department', None)
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # For Department Managers, show requests from their departments
    if current_user.role == 'Department Manager':
        # Procurement Department Managers can see ALL their department's requests
        # plus any request where they are the temporary manager
        # plus any request where they are an authorized manager approver (even if department changed)
        # Exclude archived requests
        user_dept = current_user.department.strip() if current_user.department else ''
        
        # First, get all non-archived non-draft requests to check for authorized approver status
        all_non_archived = PaymentRequest.query.filter(
            PaymentRequest.is_archived == False,
            PaymentRequest.is_draft == False
        ).all()
        
        # Find requests where user is an authorized approver (handles cases where department was edited)
        authorized_request_ids = set()
        department_match_ids = set()
        temp_manager_ids = set()
        
        # Get all departments where current user is a temporary manager for payment requests
        temp_manager_payment_depts = set()
        try:
            temp_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            for ta in temp_assignments:
                if ta.department:
                    temp_manager_payment_depts.add(ta.department.strip().lower())
            print(f"DEBUG: procurement_dashboard (Dept Manager) - User is temp manager for payment requests in departments: {temp_manager_payment_depts}")
        except Exception as e:
            print(f"DEBUG: Error getting temp manager departments (Dept Manager): {e}")
        
        for req in all_non_archived:
            # Check if requestor's department matches (this ensures we only show requests from their department)
            requestor_dept = (req.user.department or '').strip() if req.user else ''
            req_dept = (req.department or '').strip()
            
            # Only include if BOTH request department AND requestor's department match
            # This prevents showing requests where department was changed but requestor is from different department
            if req_dept.lower() == user_dept.lower() and requestor_dept.lower() == user_dept.lower():
                department_match_ids.add(req.request_id)
            
            # Check per-request temporary manager
            if req.temporary_manager_id == current_user.user_id:
                temp_manager_ids.add(req.request_id)
            
            # Check department-level temporary manager assignment for this request's department
            # Use case-insensitive matching to include ALL requests (old and new) from assigned departments
            req_dept_normalized = req_dept.lower().strip() if req_dept else ''
            if req_dept_normalized and req_dept_normalized in temp_manager_payment_depts:
                # User is assigned as temp manager for this department - include ALL requests from this department
                temp_manager_ids.add(req.request_id)
                print(f"DEBUG: procurement_dashboard (Dept Manager) - Added payment request {req.request_id} to temp_manager_ids (dept: {req_dept}, normalized: {req_dept_normalized})")
            
            # Check if user is an authorized approver (based on requestor, not request department)
            authorized_approvers = get_authorized_manager_approvers(req)
            if current_user in authorized_approvers:
                authorized_request_ids.add(req.request_id)
        
        # Combine all request IDs
        all_visible_ids = department_match_ids | temp_manager_ids | authorized_request_ids
        
        # Build query with all visible request IDs
        if all_visible_ids:
            base_query = PaymentRequest.query.filter(
                PaymentRequest.request_id.in_(all_visible_ids),
                PaymentRequest.is_archived == False
            )
        else:
            # No requests visible - return empty query
            base_query = PaymentRequest.query.filter(
                PaymentRequest.request_id == -1  # Impossible condition
            )
    else:
        # For regular Procurement Staff users OR temporary managers for Procurement
        # Show their own requests + all requests from departments they're assigned to as temp manager
        temp_manager_payment_depts = set()
        try:
            temp_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            for ta in temp_assignments:
                if ta.department:
                    temp_manager_payment_depts.add(ta.department.strip().lower())
            print(f"DEBUG: procurement_dashboard (regular user) - User is temp manager for payment requests in departments: {temp_manager_payment_depts}")
        except Exception as e:
            print(f"DEBUG: Error getting temp manager departments (regular user): {e}")
        
        if temp_manager_payment_depts:
            # Build case-insensitive department filter
            dept_conditions = []
            for dept in temp_manager_payment_depts:
                dept_conditions.append(
                    db.func.lower(db.func.trim(PaymentRequest.department)) == dept
                )
            dept_filter = db.or_(*dept_conditions) if dept_conditions else db.false()
            
            base_query = PaymentRequest.query.filter(
                db.and_(
                    db.or_(
                        PaymentRequest.user_id == current_user.user_id,  # Own requests
                        dept_filter,  # All requests from assigned departments
                        PaymentRequest.temporary_manager_id == current_user.user_id  # Per-request temp manager
                    ),
                    PaymentRequest.is_archived == False,
                    PaymentRequest.is_draft == False
                )
            )
        else:
            # For regular Procurement Staff users, show their own requests (exclude archived)
            base_query = PaymentRequest.query.filter(
                PaymentRequest.user_id == current_user.user_id,
                PaymentRequest.is_archived == False,
                PaymentRequest.is_draft == False
            )
    
    # Exclude CEO-submitted requests for non-authorized roles (visibility hardening)
    if current_user.role not in ['Finance Admin', 'GM', 'Operation Manager']:
        base_query = base_query.filter(~PaymentRequest.user.has(User.role == 'CEO'))

    # Apply urgent filter if provided (before tab filtering)
    if urgent_filter == 'urgent':
        base_query = base_query.filter(PaymentRequest.is_urgent == True)
    elif urgent_filter == 'not_urgent':
        base_query = base_query.filter(PaymentRequest.is_urgent == False)
    
    # Apply search filter if provided (before tab filtering)
    if search_query:
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            base_query = base_query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            base_query = base_query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = base_query.filter(PaymentRequest.status == 'Completed')
    elif tab == 'rejected':
        query = base_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = base_query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        # For 'my_requests' tab, show only the current user's requests
        query = base_query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        # 'all' tab - show ALL requests, but apply status filter if provided
        query = base_query
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    else:  # default - show ALL requests
        query = base_query
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    
    # Get separate queries for each tab content
    completed_query = base_query.filter(PaymentRequest.status == 'Completed')
    rejected_query = base_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    recurring_query = base_query.filter(PaymentRequest.recurring == 'Recurring')
    
    # Apply urgent filter to separate queries
    if urgent_filter == 'urgent':
        completed_query = completed_query.filter(PaymentRequest.is_urgent == True)
        rejected_query = rejected_query.filter(PaymentRequest.is_urgent == True)
        recurring_query = recurring_query.filter(PaymentRequest.is_urgent == True)
    elif urgent_filter == 'not_urgent':
        completed_query = completed_query.filter(PaymentRequest.is_urgent == False)
        rejected_query = rejected_query.filter(PaymentRequest.is_urgent == False)
        recurring_query = recurring_query.filter(PaymentRequest.is_urgent == False)
    
    # Apply search filter to separate queries
    if search_query:
        try:
            search_id = int(search_query)
            completed_query = completed_query.filter(PaymentRequest.request_id == search_id)
            rejected_query = rejected_query.filter(PaymentRequest.request_id == search_id)
            recurring_query = recurring_query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            search_term = f'%{search_query}%'
            completed_query = completed_query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
            rejected_query = rejected_query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
            recurring_query = recurring_query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
    
    # Get data for each tab
    completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    rejected_requests = rejected_query.order_by(get_rejected_datetime_order()).all()
    recurring_requests = recurring_query.order_by(PaymentRequest.created_at.desc()).all()
    
    # Paginate the main query
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        # Completed tab sorted by approval_date (most recent first)
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    # Get notifications for department managers and regular users
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    # Calculate Bank Money statistics for Current Money Status section
    bank_money_requests = PaymentRequest.query.filter(
        PaymentRequest.department == 'Procurement',
        PaymentRequest.request_type == 'Bank money',
        PaymentRequest.is_archived == False
    ).all()
    
    # Calculate statistics
    total_amount = sum(float(r.amount) for r in bank_money_requests)
    completed_requests_bm = [r for r in bank_money_requests if r.status == 'Completed']
    pending_requests_bm = [r for r in bank_money_requests if r.status in ['Pending Manager Approval', 'Pending Finance Approval', 'Proof Pending', 'Proof Sent']]
    on_hold_requests_bm = [r for r in bank_money_requests if r.status == 'On Hold']
    completed_amount = sum(float(r.amount) for r in completed_requests_bm)
    pending_amount = sum(float(r.amount) for r in pending_requests_bm)
    on_hold_amount = sum(float(r.amount) for r in on_hold_requests_bm)
    
    # Get item requests with status "Assigned to Procurement" and their invoice amounts
    assigned_item_requests = ProcurementItemRequest.query.filter_by(status='Assigned to Procurement').all()
    item_requests_amount = sum(float(r.invoice_amount) for r in assigned_item_requests if r.invoice_amount is not None)
    
    # Get completed item requests and their invoice amounts
    completed_item_requests = ProcurementItemRequest.query.filter_by(status='Completed').all()
    completed_item_requests_amount = sum(float(r.invoice_amount) for r in completed_item_requests if r.invoice_amount is not None)
    
    # Adjust calculations: deduct from available balance, add to money spent
    # Money Spent = Assigned item requests + Completed item requests (only item requests, not payment requests)
    money_spent = item_requests_amount + completed_item_requests_amount
    # Available Balance = Completed payment requests - Completed item requests only
    # (Only completed item requests reduce available balance, not assigned/pending items)
    # Include reconciled/manual adjustments that have been marked to affect reports
    try:
        adjustments_sum = db.session.query(func.coalesce(func.sum(CurrentMoneyEntry.adjustment_amount), 0)).filter(
            CurrentMoneyEntry.department == 'Procurement',
            CurrentMoneyEntry.entry_kind == 'manual_adjustment',
            CurrentMoneyEntry.include_in_balance == True
        ).scalar() or 0
        adjustments_sum = float(adjustments_sum)
    except Exception:
        adjustments_sum = 0.0

    available_balance = completed_amount - completed_item_requests_amount + adjustments_sum
    
    # Check and notify if balance is low
    check_and_notify_low_balance(available_balance)

    # Persist a snapshot entry for Current Money Status (budget-sheet history)
    try:
        entry = CurrentMoneyEntry(
            department='Procurement',
            entry_kind='snapshot',
            completed_amount=completed_amount,
            item_requests_assigned_amount=item_requests_amount,
            completed_item_requests_amount=completed_item_requests_amount,
            money_spent=money_spent,
            available_balance=available_balance,
            source='view',
            created_by=current_user.user_id if current_user and hasattr(current_user, 'user_id') else None
        )
        db.session.add(entry)
        db.session.commit()
    except Exception:
        # Fail silently to avoid breaking the dashboard if DB write fails
        db.session.rollback()
    
    return render_template('procurement_dashboard.html', 
                         requests=requests_pagination.items, 
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         user=current_user,
                         notifications=notifications,
                         unread_count=unread_count,
                         status_filter=status_filter,
                         search_query=search_query,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         recurring_requests=recurring_requests,
                         urgent_filter=urgent_filter,
                         my_requests=my_requests_pagination.items,
                         active_tab=tab,
                         total_amount=total_amount,
                         completed_amount=money_spent,
                         available_balance=available_balance,
                         pending_amount=pending_amount,
                         on_hold_amount=on_hold_amount)


@app.route('/api/procurement/money-spent', methods=['GET'])
@login_required
def get_procurement_money_spent():
    """API endpoint to get the current Money Spent value for Procurement department"""
    # Only allow Procurement Department Managers to access this endpoint
    if current_user.department != 'Procurement' or current_user.role != 'Department Manager':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        # Get item requests with status "Assigned to Procurement" and their invoice amounts
        assigned_item_requests = ProcurementItemRequest.query.filter_by(status='Assigned to Procurement').all()
        item_requests_amount = sum(float(r.invoice_amount) for r in assigned_item_requests if r.invoice_amount is not None)
        
        # Get completed item requests and their invoice amounts
        completed_item_requests = ProcurementItemRequest.query.filter_by(status='Completed').all()
        completed_item_requests_amount = sum(float(r.invoice_amount) for r in completed_item_requests if r.invoice_amount is not None)
        
        # Money Spent = Assigned item requests + Completed item requests
        money_spent = item_requests_amount + completed_item_requests_amount
        
        return jsonify({'money_spent': money_spent})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/procurement/money-spent-history', methods=['GET'])
@login_required
def get_procurement_money_spent_history():
    """API endpoint to get the Money Spent history for Procurement department"""
    # Only allow Procurement Department Managers, GM, Operation Manager, IT, and Auditing to access this endpoint
    allowed_roles = ['Department Manager', 'GM', 'Operation Manager']
    allowed_departments = ['Procurement', 'IT', 'Auditing']
    
    # Check if user has access
    has_access = (
        (current_user.role in allowed_roles) or 
        (current_user.department in allowed_departments)
    )
    
    if not has_access:
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        # Get snapshot entries for Procurement department, ordered by date descending
        entries = CurrentMoneyEntry.query.filter(
            CurrentMoneyEntry.department == 'Procurement',
            CurrentMoneyEntry.entry_kind == 'snapshot',
            CurrentMoneyEntry.money_spent.isnot(None)  # Filter out entries with null money_spent
        ).order_by(CurrentMoneyEntry.entry_date.desc()).all()
        
        # Convert to list of dictionaries with the fields expected by the frontend
        history = []
        last_money_spent = None
        
        for entry in entries:
            money_spent_value = float(entry.money_spent) if entry.money_spent is not None else None
            
            # Skip entries with null money_spent (shouldn't happen due to filter, but double-check)
            if money_spent_value is None:
                continue
            
            # Skip duplicate consecutive entries (same money_spent value as previous entry)
            if last_money_spent is not None and abs(money_spent_value - last_money_spent) < 0.001:
                continue
            
            history.append({
                'entry_date': entry.entry_date.isoformat() if entry.entry_date else None,
                'money_spent': money_spent_value,
                'available_balance': float(entry.available_balance) if entry.available_balance is not None else None
            })
            
            last_money_spent = money_spent_value
        
        return jsonify({'history': history})
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/procurement/item-requests')
@login_required
def procurement_item_requests():
    """Item Requests page - shows requests based on user role"""
    # Get filter parameters
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    tab = request.args.get('tab', 'all')
    department_filter = request.args.get('department', None)
    status_filter = request.args.get('status', None)
    urgent_filter = request.args.get('urgent', None)
    search_query = request.args.get('search', None)
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Migrate: Add amount and procurement_quantities columns to procurement_item_requests if they don't exist
    try:
        import sqlite3
        db_path = app.config['SQLALCHEMY_DATABASE_URI'].replace('sqlite:///', '')
        if os.name == 'nt':  # Windows
            db_path = db_path.replace('/', '\\')
        
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Check if amount and related columns exist
        cursor.execute("PRAGMA table_info(procurement_item_requests)")
        existing_columns = [row[1] for row in cursor.fetchall()]
        
        if 'amount' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN amount NUMERIC(10, 3)")
            conn.commit()
            print("‚úì Added 'amount' column to procurement_item_requests table")

        if 'procurement_quantities' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_quantities TEXT")
            conn.commit()
            print("‚úì Added 'procurement_quantities' column to procurement_item_requests table")
        
        if 'payment_date' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN payment_date DATE")
            conn.commit()
            print("‚úì Added 'payment_date' column to procurement_item_requests table")

        # Check if receipt_reference_number column exists
        if 'receipt_reference_number' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN receipt_reference_number VARCHAR(100)")
            conn.commit()
            print("‚úì Added 'receipt_reference_number' column to procurement_item_requests table")

        # Separate receipt and invoice amounts for completion
        if 'receipt_amount' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN receipt_amount NUMERIC(10, 3)")
            conn.commit()
            print("‚úì Added 'receipt_amount' column to procurement_item_requests table")
        
        if 'invoice_amount' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN invoice_amount NUMERIC(10, 3)")
            conn.commit()
            print("‚úì Added 'invoice_amount' column to procurement_item_requests table")

        if 'procurement_manager_quantities' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_manager_quantities TEXT")
            conn.commit()
            print("‚úì Added 'procurement_manager_quantities' column to procurement_item_requests table")

        if 'manager_quantity_rejection_reason' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN manager_quantity_rejection_reason TEXT")
            conn.commit()
            print("‚úì Added 'manager_quantity_rejection_reason' column to procurement_item_requests table")

        if 'procurement_manager_quantity_rejection_reason' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_manager_quantity_rejection_reason TEXT")
            conn.commit()
            print("‚úì Added 'procurement_manager_quantity_rejection_reason' column to procurement_item_requests table")

        if 'procurement_quantity_rejection_reason' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_quantity_rejection_reason TEXT")
            conn.commit()
            print("‚úì Added 'procurement_quantity_rejection_reason' column to procurement_item_requests table")

        # Add requestor_item_upload_path for storing requestor-uploaded item files (JSON)
        if 'requestor_item_upload_path' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN requestor_item_upload_path TEXT")
            conn.commit()
            print("‚úì Added 'requestor_item_upload_path' column to procurement_item_requests table")
        # Add requestor_evidence_upload_path for storing requestor-uploaded evidence files (JSON)
        if 'requestor_evidence_upload_path' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN requestor_evidence_upload_path TEXT")
            conn.commit()
            print("‚úì Added 'requestor_evidence_upload_path' column to procurement_item_requests table")

        conn.close()
    except Exception as e:
        print(f"Warning: Could not migrate columns: {e}")
    
    # Update any old "Assigned" status to "Assigned to Procurement" (one-time migration)
    old_assigned = ProcurementItemRequest.query.filter_by(status='Assigned').all()
    if old_assigned:
        for req in old_assigned:
            req.status = 'Assigned to Procurement'
        db.session.commit()
    
    # Build base query for procurement item requests
    # Start with a query object that we can filter at database level
    base_query = ProcurementItemRequest.query
    
    # Exclude draft items - only show submitted requests
    base_query = base_query.filter(ProcurementItemRequest.is_draft == False)
    
    # Apply search filter at database level (same logic as dashboard)
    if search_query:
        try:
            # Try to parse as integer for request ID search
            search_id = int(search_query)
            base_query = base_query.filter(ProcurementItemRequest.id == search_id)
        except ValueError:
            # If not an integer, search in text fields using ilike (case-insensitive pattern matching)
            search_term = f'%{search_query}%'
            base_query = base_query.filter(
                db.or_(
                    ProcurementItemRequest.requestor_name.ilike(search_term),
                    ProcurementItemRequest.category.ilike(search_term),
                    ProcurementItemRequest.item_name.ilike(search_term),
                    ProcurementItemRequest.purpose.ilike(search_term),
                    ProcurementItemRequest.department.ilike(search_term),
                    ProcurementItemRequest.branch_name.ilike(search_term)
                )
            )
    
    # Apply department filter at database level
    if department_filter:
        base_query = base_query.filter(ProcurementItemRequest.department == department_filter)
    
    # Apply status filter at database level
    if status_filter:
        base_query = base_query.filter(ProcurementItemRequest.status == status_filter)
    
    # Apply urgent filter at database level
    if urgent_filter == 'urgent':
        base_query = base_query.filter(ProcurementItemRequest.is_urgent == True)
    elif urgent_filter == 'not_urgent':
        base_query = base_query.filter(ProcurementItemRequest.is_urgent == False)
    
    # Get all procurement item requests (after applying search and filters)
    # Use eager loading to avoid N+1 queries when accessing assigned_to_user
    all_requests = base_query.options(
        db.joinedload(ProcurementItemRequest.assigned_to_user)
    ).order_by(ProcurementItemRequest.created_at.desc()).all()

    # For Auditing "my_requests", ensure we include their own requests regardless of filters
    own_requests_unfiltered = []
    if current_user.department == 'Auditing' and tab == 'my_requests':
        own_requests_unfiltered = ProcurementItemRequest.query.filter_by(user_id=current_user.user_id).all()
    # For Procurement "my_requests", fetch own requests unfiltered so users can see all their submissions
    own_requests_unfiltered_procurement = []
    if current_user.department == 'Procurement' and tab == 'my_requests':
        own_requests_unfiltered_procurement = ProcurementItemRequest.query.filter_by(user_id=current_user.user_id).all()
    
    # Filter requests based on user role (after database-level filters)
    # Check if user is from Procurement OR is a temporary manager for Procurement
    is_procurement_user = current_user.department == 'Procurement'
    is_temp_manager_for_procurement_items = False
    try:
        temp_procurement_items = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
            db.func.lower(db.func.trim(DepartmentTemporaryManager.department)) == 'procurement',
            db.or_(
                DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).first()
        is_temp_manager_for_procurement_items = temp_procurement_items is not None
        print(f"DEBUG: procurement_item_requests - is_procurement_user: {is_procurement_user}, is_temp_manager_for_procurement_items: {is_temp_manager_for_procurement_items}")
    except Exception as e:
        print(f"DEBUG: Error checking temp manager for procurement items: {e}")
    
    if is_procurement_user or is_temp_manager_for_procurement_items:
        # Procurement Department Manager should see:
        # - All requests belonging to the Procurement department (any status)
        # - Requests from other departments ONLY when they are at procurement-manager level
        #   (e.g., 'Pending Procurement Manager Approval') or when the manager is an authorized approver
        # Procurement staff (non-manager) keep previous behaviour but always see their own requests.
        # For Procurement Department Managers OR temporary managers for Procurement
        # Show all Procurement department requests + external statuses + authorized approver requests
        if current_user.role == 'Department Manager' or is_temp_manager_for_procurement_items:
            authorized_approvers_ids = set()
            temp_manager_item_ids = set()
            
            # Get all departments where current user is a temporary manager for item requests
            temp_manager_item_depts = set()
            if is_temp_manager_for_procurement_items:
                try:
                    temp_item_assignments = DepartmentTemporaryManager.query.filter(
                        DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                        db.or_(
                            DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                            DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                        )
                    ).all()
                    for ta in temp_item_assignments:
                        if ta.department:
                            temp_manager_item_depts.add(ta.department.strip().lower())
                    print(f"DEBUG: procurement_item_requests - User is temp manager for item requests in departments: {temp_manager_item_depts}")
                except Exception as e:
                    print(f"DEBUG: Error getting temp manager item departments: {e}")
            
            for req in all_requests:
                # Check if user is a department-level temporary manager for this item request
                # Use case-insensitive matching to include ALL requests (old and new) from assigned departments
                req_dept_normalized = (req.department or '').strip().lower() if req.department else ''
                if req_dept_normalized and req_dept_normalized in temp_manager_item_depts:
                    # User is assigned as temp manager for this department - include ALL item requests from this department
                    temp_manager_item_ids.add(req.id)
                    print(f"DEBUG: procurement_item_requests - Added item request {req.id} to temp_manager_item_ids (dept: {req.department}, normalized: {req_dept_normalized})")
                
                # Also check via authorized approvers function
                approvers = get_authorized_manager_approvers_for_item_request(req)
                approver_ids = [a.user_id for a in approvers]
                if current_user.user_id in approver_ids:
                    authorized_approvers_ids.add(req.id)

            # External statuses that Procurement Manager should be able to see across departments
            external_statuses = {
                'Pending Procurement Manager Approval',
                'Final Approval',
                'Assigned to Procurement',
                'Completed'
            }

            base_item_requests = [
                r for r in all_requests
                if r.department == 'Procurement'  # All Procurement department requests
                or (r.department != 'Procurement' and r.status in external_statuses)  # External statuses
                or r.id in authorized_approvers_ids  # Authorized approver
                or r.id in temp_manager_item_ids  # Temporary manager for this department
                or r.user_id == current_user.user_id  # Own requests
            ]
        else:
            # Procurement staff (non-managers) visibility rules:
            # 1) Always include requests created by the current user (any status).
            # 2) Include requests from all departments only when their status is one of:
            #    'Assigned to Procurement', 'Final Approval', or 'Completed'.
            allowed_external_statuses = {'Assigned to Procurement', 'Final Approval', 'Completed'}
            base_item_requests = [
                r for r in all_requests
                if r.user_id == current_user.user_id or r.status in allowed_external_statuses
            ]
    elif current_user.role in ['GM', 'Operation Manager']:
        # General Manager and Operation Manager see all requests (view-only, same as Procurement Manager)
        base_item_requests = all_requests
    elif current_user.department == 'IT':
        # IT department can see all item requests (view-only, similar to payment requests visibility)
        base_item_requests = all_requests
    elif current_user.department == 'Auditing':
        # Auditing department can see all completed item requests for auditing purposes
        base_item_requests = [r for r in all_requests if r.status == 'Completed']
    else:
        # Managers see requests from their department or requests they created
        # Also includes temporary managers assigned for "Procurement Item Request" or "Both Payment and Item Request"
        authorized_approvers_ids = set()
        temp_manager_item_ids = set()
        
        # First, get all departments where current user is a temporary manager for item requests
        temp_manager_item_depts = set()
        try:
            temp_item_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            for ta in temp_item_assignments:
                if ta.department:
                    temp_manager_item_depts.add(ta.department.strip().lower())
            print(f"DEBUG: User is temp manager for item requests in departments: {temp_manager_item_depts}")
        except Exception as e:
            print(f"DEBUG: Error getting temp manager item departments: {e}")
        
        for req in all_requests:
            # Check if user is a department-level temporary manager for this item request
            # Use case-insensitive matching to include ALL requests (old and new) from assigned departments
            req_dept_normalized = (req.department or '').strip().lower() if req.department else ''
            if req_dept_normalized and req_dept_normalized in temp_manager_item_depts:
                # User is assigned as temp manager for this department - include ALL item requests from this department
                temp_manager_item_ids.add(req.id)
                print(f"DEBUG: Added item request {req.id} to temp_manager_item_ids (dept: {req.department}, normalized: {req_dept_normalized})")
            
            # Also check via authorized approvers function
            approvers = get_authorized_manager_approvers_for_item_request(req)
            approver_ids = [a.user_id for a in approvers]
            if current_user.user_id in approver_ids:
                authorized_approvers_ids.add(req.id)
        
        # Also show requests created by current user
        my_requests = [r.id for r in all_requests if r.user_id == current_user.user_id]
        visible_request_ids = authorized_approvers_ids.union(temp_manager_item_ids).union(my_requests)
        base_item_requests = [r for r in all_requests if r.id in visible_request_ids]
        print(f"DEBUG: Item requests visibility - authorized: {len(authorized_approvers_ids)}, temp_manager: {len(temp_manager_item_ids)}, my_requests: {len(my_requests)}, total visible: {len(visible_request_ids)}")
    
    # Build status options visible to current user (based on base_item_requests).
    # If user is viewing their 'My Requests' tab, compute from their own requests so all statuses appear.
    try:
        if current_user.department == 'Procurement' and tab == 'my_requests':
            visible_statuses_set = {r.status for r in own_requests_unfiltered_procurement}
        else:
            visible_statuses_set = {r.status for r in base_item_requests}
    except Exception:
        visible_statuses_set = set()

    # Ensure manager sees common external statuses in the filter even if none present yet
    if current_user.department == 'Procurement' and current_user.role == 'Department Manager':
        visible_statuses_set.update({
            'Pending Procurement Manager Approval',
            'Final Approval',
            'Assigned to Procurement',
            'Completed'
        })
        # Allow manager to filter by 'Rejected by Manager' but only procurement-department ones are visible
        visible_statuses_set.add('Rejected by Manager')

    # Preferred display order for statuses (manager-focused first)
    status_priority_order = [
        'Pending Procurement Manager Approval',
        'Final Approval',
        'Assigned to Procurement',
        'On Hold',
        'Completed',
        'Rejected by Procurement Manager',
        'Pending Manager Approval',
        'Rejected by Manager'
    ]

    status_options = [s for s in status_priority_order if s in visible_statuses_set]
    # Append any remaining statuses found dynamically in alphabetical order
    remaining_statuses = sorted([s for s in visible_statuses_set if s not in status_options])
    status_options.extend(remaining_statuses)
    
    # Apply tab-based filtering
    if current_user.department == 'Procurement':
        if tab == 'assigned_to_self':
            # Show requests assigned to current user
            item_requests = [r for r in base_item_requests if r.status == 'Assigned to Procurement' and r.assigned_to_user_id == current_user.user_id]
        elif tab == 'my_requests':
            # Show all requests created by the current procurement user (any status)
            item_requests = own_requests_unfiltered_procurement
        elif tab == 'completed':
            # Show completed requests
            item_requests = [r for r in base_item_requests if r.status == 'Completed']
        elif tab == 'returned':
            # Show returned/rejected items
            item_requests = [r for r in base_item_requests if r.status in ['Rejected by Procurement Manager']]
        else:  # tab == 'all'
            # Show all requests (default)
            item_requests = base_item_requests
    elif current_user.department == 'IT':
        if tab == 'my_requests':
            # IT: show only item requests created by the current IT user
            item_requests = [r for r in base_item_requests if r.user_id == current_user.user_id]
        elif tab == 'completed':
            # IT: show all completed item requests
            item_requests = [r for r in base_item_requests if r.status == 'Completed']
        else:  # tab == 'all' or any other value
            item_requests = base_item_requests
    elif current_user.department == 'Auditing':
        # Auditing: show all completed; always include own requests (any status) even if filters were applied
        merged = {r.id: r for r in base_item_requests}
        for r in own_requests_unfiltered:
            merged[r.id] = r
        base_for_audit = list(merged.values())
        if tab == 'my_requests':
            # Show all requests created by the auditing user (any status)
            item_requests = [r for r in base_for_audit if r.user_id == current_user.user_id]
        else:  # default/all completed
            item_requests = [r for r in base_for_audit if r.status == 'Completed']
    else:
        # For Department Managers (non-Procurement), provide a "My Item Requests" tab that shows
        # all requests belonging to their department. This allows department managers who do not
        # have full cross-department access to quickly view their department's item requests.
        if current_user.role == 'Department Manager' and tab == 'my_requests':
            # Use the original all_requests (after DB-level filters like search/status/urgent),
            # but scope to the manager's department to ensure they see department-wide requests.
            item_requests = [r for r in all_requests if r.department == current_user.department]
        else:
            # For other non-procurement users, default to previously-calculated visibility
            item_requests = base_item_requests
    
    # Sort item requests: first by status priority, then by datetime (most recent first)
    # This matches the sorting logic used in payment requests dashboard
    # Use a tuple key: (status_priority, -timestamp) where timestamp is negated for descending order
    
    # Check if user is a temporary manager for item requests
    is_temp_manager_for_items = False
    try:
        temp_item_assignments = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
            db.or_(
                DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).first()
        is_temp_manager_for_items = temp_item_assignments is not None
        print(f"DEBUG: sort_key - is_temp_manager_for_items: {is_temp_manager_for_items}")
    except Exception as e:
        print(f"DEBUG: Error checking temp manager for items in sort_key: {e}")
    
    def sort_key(req):
        # For temporary managers assigned for item requests, prioritize "Pending Manager Approval" first
        if is_temp_manager_for_items:
            # Custom priority order for temporary managers:
            # 1. Pending Manager Approval (highest priority - they need to approve these)
            # 2. Pending Procurement Manager Approval
            # 3. Final Approval
            # 4. Assigned to Procurement
            # 5. On Hold
            # 6. Completed
            # 7. Rejected by Manager
            # 8. Rejected by Procurement Manager
            temp_manager_status_priority = {
                'Pending Manager Approval': 1,  # Highest priority for temp managers
                'Pending Procurement Manager Approval': 2,
                'Final Approval': 3,
                'Assigned to Procurement': 4,
                'On Hold': 5,
                'Completed': 6,
                'Rejected by Manager': 7,
                'Rejected by Procurement Manager': 8,
            }
            status_priority = temp_manager_status_priority.get(req.status, 99)
        # For Procurement Department Manager, use specific priority order
        elif current_user.department == 'Procurement' and current_user.role == 'Department Manager':
            # Custom priority order for Procurement Department Manager:
            # 1. Pending Procurement Manager Approval
            # 2. Final Approval (after Pending Procurement Manager Approval)
            # 3. Assigned to Procurement
            # 4. On Hold
            # 5. Completed
            # 6. Rejected by Procurement Manager
            # For the Procurement Department Manager, prioritize requests awaiting manager-level decisions first.
            procurement_manager_status_priority = {
                'Pending Manager Approval': 1,
                'Pending Procurement Manager Approval': 2,
                'Final Approval': 3,
                'Assigned to Procurement': 4,
                'On Hold': 5,
                'Completed': 6,
                'Rejected by Procurement Manager': 7,
                'Rejected by Manager': 8,
            }
            status_priority = procurement_manager_status_priority.get(req.status, 99)
        # For other Procurement staff (not Department Manager), use different priority order
        elif current_user.department == 'Procurement':
            # Custom priority order for Procurement Staff:
            # 1. Assigned to Procurement
            # 2. Final Approval (after Assigned to Procurement)
            # 3. Pending Procurement Manager Approval
            # 4. On Hold
            # 5. Completed
            procurement_staff_status_priority = {
                'Assigned to Procurement': 1,
                'Final Approval': 2,
                'Pending Procurement Manager Approval': 3,
                'On Hold': 4,
                'Completed': 5,
                'Pending Manager Approval': 6,
                'Rejected by Manager': 7,
                'Rejected by Procurement Manager': 7,
            }
            status_priority = procurement_staff_status_priority.get(req.status, 99)
        else:
            # For other users (Manager Approval authorized users and view-only users), use standard priority order:
            # Pending Manager Approval
            # Pending Procurement Manager Approval
            # Assigned to Procurement
            # Final Approval
            # On Hold
            # Completed
            # Rejected by Manager
            # Rejected by Procurement Manager
            default_status_priority = {
                'Pending Manager Approval': 1,
                'Pending Procurement Manager Approval': 2,
                'Assigned to Procurement': 3,
                'Final Approval': 4,
                'On Hold': 5,
                'Completed': 6,
                'Rejected by Manager': 7,
                'Rejected by Procurement Manager': 8,
            }
            status_priority = default_status_priority.get(req.status, 99)
        
        dt = get_item_request_datetime_for_sorting(req)
        # Convert datetime to timestamp for negation (most recent = higher timestamp, so negate for descending)
        timestamp = dt.timestamp() if dt else 0
        return (status_priority, -timestamp)
    
    item_requests.sort(key=sort_key, reverse=False)
    
    # Apply pagination to the sorted list (similar behavior to payment requests pagination)
    total_requests_for_page = len(item_requests)
    
    # Clamp page within valid range
    if page < 1:
        page = 1
    total_pages = (total_requests_for_page + per_page - 1) // per_page if per_page > 0 else 0
    if total_pages and page > total_pages:
        page = total_pages
    
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    paginated_items = item_requests[start_idx:end_idx]
    
    class SimplePagination:
        def __init__(self, items, page, per_page, total):
            self.items = items
            self.page = page
            self.per_page = per_page
            self.total = total
            self.pages = (total + per_page - 1) // per_page if per_page > 0 else 0
            self.has_prev = self.page > 1
            self.has_next = self.page < self.pages
            self.prev_num = self.page - 1 if self.has_prev else None
            self.next_num = self.page + 1 if self.has_next else None
        
        def iter_pages(self, left_edge=2, left_current=2, right_current=5, right_edge=2):
            last = 0
            for num in range(1, self.pages + 1):
                if (
                    num <= left_edge
                    or (num > self.page - left_current - 1 and num < self.page + right_current)
                    or num > self.pages - right_edge
                ):
                    if last + 1 != num:
                        yield None
                    yield num
                    last = num
    
    pagination = SimplePagination(paginated_items, page, per_page, total_requests_for_page)
    
    # Calculate statistics (before filtering for display)
    all_item_requests_for_stats = ProcurementItemRequest.query.all()
    # Filter stats based on user role (same logic as above)
    if current_user.department == 'Procurement':
        # All Procurement staff (Manager and Staff) stats exclude "Pending Manager Approval" and "Rejected by Manager"
        stats_requests = [r for r in all_item_requests_for_stats if r.status not in ['Pending Manager Approval', 'Rejected by Manager']]
    elif current_user.role in ['GM', 'Operation Manager']:
        # General Manager and Operation Manager see all requests (view-only, same as Procurement Manager)
        stats_requests = all_item_requests_for_stats
    elif current_user.department == 'Auditing':
        # Auditing department stats show only completed requests
        stats_requests = [r for r in all_item_requests_for_stats if r.status == 'Completed']
    else:
        authorized_approvers_ids = set()
        for req in all_item_requests_for_stats:
            approvers = get_authorized_manager_approvers_for_item_request(req)
            approver_ids = [a.user_id for a in approvers]
            if current_user.user_id in approver_ids:
                authorized_approvers_ids.add(req.id)
        my_requests = [r.id for r in all_item_requests_for_stats if r.user_id == current_user.user_id]
        visible_request_ids = authorized_approvers_ids.union(my_requests)
        stats_requests = [r for r in all_item_requests_for_stats if r.id in visible_request_ids]
    
    total_requests = len(stats_requests)
    pending_requests = [r for r in stats_requests if r.status in ['Pending Manager Approval', 'Pending Procurement Manager Approval', 'Assigned to Procurement']]
    completed_requests = [r for r in stats_requests if r.status == 'Completed']
    rejected_requests = [r for r in stats_requests if r.status in ['Rejected by Manager', 'Rejected by Procurement Manager']]
    urgent_requests = [r for r in stats_requests if r.is_urgent]
    
    # Get all unique departments for filter dropdown
    all_departments = db.session.query(ProcurementItemRequest.department).distinct().order_by(ProcurementItemRequest.department).all()
    departments = [dept[0] for dept in all_departments]
    
    # Get procurement members for assignment dropdown (only for Procurement Manager)
    # Convert to dictionaries for JSON serialization
    procurement_members = []
    is_procurement_user = False
    if current_user.department == 'Procurement' and current_user.role == 'Department Manager':
        members = User.query.filter_by(department='Procurement').all()
        procurement_members = [{'user_id': m.user_id, 'name': m.name} for m in members]
        is_procurement_user = True
    elif current_user.department == 'Procurement':
        is_procurement_user = True
    elif current_user.role in ['GM', 'Operation Manager']:
        # GM and Operation Manager see statistics like Procurement Manager (view-only)
        is_procurement_user = True
    
    # Calculate Bank Money statistics for Current Money Status section (for Procurement Manager, GM, Operation Manager, IT, and Auditing)
    available_balance = None
    completed_amount = None
    pending_amount = None
    on_hold_amount = None
    if current_user.role in ['GM', 'Operation Manager'] or (current_user.department == 'Procurement' and current_user.role == 'Department Manager') or current_user.department in ['IT', 'Auditing']:
        # Calculate Bank Money statistics for Current Money Status section
        bank_money_requests = PaymentRequest.query.filter(
            PaymentRequest.department == 'Procurement',
            PaymentRequest.request_type == 'Bank money',
            PaymentRequest.is_archived == False
            ).all()
    
    # Calculate statistics
        completed_requests_bm = [r for r in bank_money_requests if r.status == 'Completed']
        pending_requests_bm = [r for r in bank_money_requests if r.status in ['Pending Manager Approval', 'Pending Finance Approval', 'Proof Pending', 'Proof Sent']]
        on_hold_requests_bm = [r for r in bank_money_requests if r.status == 'On Hold']
        completed_amount_bm = sum(float(r.amount) for r in completed_requests_bm)
        pending_amount = sum(float(r.amount) for r in pending_requests_bm)
        on_hold_amount = sum(float(r.amount) for r in on_hold_requests_bm)
        
        # Get item requests with status "Assigned to Procurement" and their invoice amounts
        assigned_item_requests = ProcurementItemRequest.query.filter_by(status='Assigned to Procurement').all()
        item_requests_amount = sum(float(r.invoice_amount) for r in assigned_item_requests if r.invoice_amount is not None)
        
        # Get completed item requests and their invoice amounts
        completed_item_requests = ProcurementItemRequest.query.filter_by(status='Completed').all()
        completed_item_requests_amount = sum(float(r.invoice_amount) for r in completed_item_requests if r.invoice_amount is not None)
        
        # Adjust calculations: deduct from available balance, add to money spent
        # Money Spent = Assigned item requests + Completed item requests (only item requests, not payment requests)
        completed_amount = item_requests_amount + completed_item_requests_amount
        # Available Balance = Completed payment requests - Completed item requests only
        # (Only completed item requests reduce available balance, not assigned/pending items)
        try:
            adjustments_sum = db.session.query(func.coalesce(func.sum(CurrentMoneyEntry.adjustment_amount), 0)).filter(
                CurrentMoneyEntry.department == 'Procurement',
                CurrentMoneyEntry.entry_kind == 'manual_adjustment',
                CurrentMoneyEntry.include_in_balance == True
            ).scalar() or 0
            adjustments_sum = float(adjustments_sum)
        except Exception:
            adjustments_sum = 0.0

        available_balance = completed_amount_bm - completed_item_requests_amount + adjustments_sum
        
        # Check and notify if balance is low
        check_and_notify_low_balance(available_balance)

        # Persist a snapshot entry for Current Money Status (budget-sheet history)
        try:
            entry = CurrentMoneyEntry(
                department='Procurement',
                entry_kind='snapshot',
                completed_amount=completed_amount_bm,
                item_requests_assigned_amount=item_requests_amount,
                completed_item_requests_amount=completed_item_requests_amount,
                money_spent=None,
                available_balance=available_balance,
                source='balance_check',
                created_by=current_user.user_id if current_user and hasattr(current_user, 'user_id') else None
            )
            db.session.add(entry)
            db.session.commit()
        except Exception:
            db.session.rollback()

        # Persist a snapshot entry for Current Money Status (budget-sheet history)
        try:
            entry = CurrentMoneyEntry(
                department='Procurement',
                entry_kind='snapshot',
                completed_amount=completed_amount_bm,
                item_requests_assigned_amount=item_requests_amount,
                completed_item_requests_amount=completed_item_requests_amount,
                money_spent=completed_amount,
                available_balance=available_balance,
                source='view',
                created_by=current_user.user_id if current_user and hasattr(current_user, 'user_id') else None
            )
            db.session.add(entry)
            db.session.commit()
        except Exception:
            db.session.rollback()
    
    return render_template('procurement_item_requests.html',
                         user=current_user,
                         item_requests=pagination.items,
                         total_requests=total_requests,
                         pending_requests=pending_requests,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         urgent_requests=urgent_requests,
                         procurement_members=procurement_members,
                         is_procurement_user=is_procurement_user,
                         active_tab=tab,
                         department_filter=department_filter,
                         status_filter=status_filter,
                         status_options=status_options,
                         urgent_filter=urgent_filter,
                         search_query=search_query,
                         departments=departments,
                         pagination=pagination,
                         available_balance=available_balance,
                         completed_amount=completed_amount,
                         pending_amount=pending_amount,
                         on_hold_amount=on_hold_amount)


@app.route('/procurement/item-request/<int:request_id>')
@login_required
def view_item_request(request_id):
    """View details of a specific item request"""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Check access permissions
    can_view = False
    if current_user.department == 'Procurement':
        # Procurement Department Manager can view all Procurement department requests regardless of status
        if current_user.role == 'Department Manager' and item_request.department == 'Procurement':
            can_view = True
        # Allow procurement users to view requests they created at any status
        elif item_request.user_id == current_user.user_id:
            can_view = True
        # All Procurement staff (Manager and Staff) can view all requests except "Pending Manager Approval" and "Rejected by Manager"
        elif item_request.status not in ['Pending Manager Approval', 'Rejected by Manager']:
            can_view = True
    elif current_user.role in ['GM', 'Operation Manager']:
        # General Manager and Operation Manager can view all requests (view-only)
        can_view = True
    elif current_user.department == 'IT':
        # IT department can view all item requests (view-only, consistent with item requests listing)
        can_view = True
    elif current_user.department == 'Auditing' and item_request.status == 'Completed':
        # Auditing department can view all completed item requests for auditing purposes
        can_view = True
    elif item_request.user_id == current_user.user_id:
        can_view = True
    else:
        approvers = get_authorized_manager_approvers_for_item_request(item_request)
        if current_user in approvers:
            can_view = True
    
    if not can_view:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    # Check what actions current user can perform
    can_approve_manager = False
    can_reject_manager = False
    can_approve_procurement_manager = False
    can_reject_procurement_manager = False
    can_complete = False
    
    # Manager approval: GM and Operation Manager can approve (in addition to assigned manager and temporary manager)
    # Also allow when status is 'On Hold' (if it was put on hold by manager)
    if item_request.status in ['Pending Manager Approval', 'On Hold']:
        approvers = get_authorized_manager_approvers_for_item_request(item_request)
        if current_user in approvers:
            # Check if it's on hold by manager (not procurement manager)
            if item_request.status == 'On Hold' and item_request.manager_on_hold_by_user_id:
                can_approve_manager = True
                can_reject_manager = True
            elif item_request.status == 'Pending Manager Approval':
                can_approve_manager = True
                can_reject_manager = True
    
    # Procurement Manager approval: Only Procurement Department Manager can approve
    # OR temporary managers with include_procurement_approvals=True
    # Also allow when status is 'On Hold' (if it was put on hold by procurement manager)
    if item_request.status in ['Pending Procurement Manager Approval', 'On Hold', 'Final Approval']:
        is_procurement_dept_manager = current_user.department == 'Procurement' and current_user.role == 'Department Manager'
        
        # Check if user is a temporary manager with include_procurement_approvals enabled
        is_temp_procurement_approver = False
        try:
            temp_procurement_approvers = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                DepartmentTemporaryManager.include_procurement_approvals == True,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            is_temp_procurement_approver = len(temp_procurement_approvers) > 0
        except Exception:
            pass
        
        if is_procurement_dept_manager or is_temp_procurement_approver:
            # Check if it's on hold by procurement manager (not manager)
            if item_request.status == 'On Hold' and item_request.procurement_manager_on_hold_by_user_id:
                can_approve_procurement_manager = True
                can_reject_procurement_manager = True
            elif item_request.status in ['Pending Procurement Manager Approval', 'Final Approval']:
                can_approve_procurement_manager = True
                can_reject_procurement_manager = True
    
    # Completion: Only the assigned procurement staff can complete when status is 'Assigned to Procurement' (GM and Operation Manager cannot complete)
    if current_user.role not in ['GM', 'Operation Manager']:
        if item_request.status == 'Assigned to Procurement' and current_user.department == 'Procurement':
            # Only allow completion if the current user is the assigned user
            if item_request.assigned_to_user_id and item_request.assigned_to_user_id == current_user.user_id:
                can_complete = True
    
    # Get user names safely (avoid lazy loading issues)
    assigned_to_name = None
    if item_request.assigned_to_user_id:
        assigned_user = User.query.get(item_request.assigned_to_user_id)
        assigned_to_name = assigned_user.name if assigned_user else None
    
    completed_by_name = None
    if item_request.completed_by_user_id:
        completed_user = User.query.get(item_request.completed_by_user_id)
        completed_by_name = completed_user.name if completed_user else None
    
    receipt_files = []
    if item_request.receipt_path:
        try:
            data = json.loads(item_request.receipt_path)
            if isinstance(data, list):
                receipt_files = data
            else:
                receipt_files = [item_request.receipt_path]
        except (json.JSONDecodeError, TypeError):
            receipt_files = [item_request.receipt_path]
    
    def _parse_invoice_files(raw_value):
        files = []
        if not raw_value:
            return files
        try:
            data = json.loads(raw_value)
        except (json.JSONDecodeError, TypeError):
            return [raw_value]

        if isinstance(data, list):
            for entry in data:
                if isinstance(entry, dict):
                    fname = entry.get('filename') or entry.get('file') or entry.get('name')
                    if fname:
                        files.append(fname)
                elif isinstance(entry, str):
                    files.append(entry)
        elif isinstance(data, dict):
            fname = data.get('filename') or data.get('file') or data.get('name')
            if fname:
                files.append(fname)
        else:
            files.append(raw_value)
        return files

    invoice_files = _parse_invoice_files(item_request.invoice_path)
    
    return jsonify({
        'success': True,
        'request': {
            'id': item_request.id,
            'requestor_name': item_request.requestor_name,
            'department': item_request.department,
            'category': item_request.category,
            'item_name': item_request.item_name,
            'quantity': item_request.quantity,
            'purpose': item_request.purpose,
            'branch_name': item_request.branch_name,
            'request_date': item_request.request_date.strftime('%Y-%m-%d') if item_request.request_date else None,
            'is_urgent': item_request.is_urgent,
            'notes': item_request.notes,
            'status': item_request.status,
            'created_at': item_request.created_at.strftime('%Y-%m-%d %H:%M:%S') if item_request.created_at else None,
            'manager_approver': item_request.manager_approver,
            'manager_approval_date': item_request.manager_approval_date.strftime('%Y-%m-%d') if item_request.manager_approval_date else None,
            'procurement_manager_approver': item_request.procurement_manager_approver,
            'assigned_to': assigned_to_name,
            'completed_by': completed_by_name,
            'completion_date': item_request.completion_date.strftime('%Y-%m-%d %H:%M:%S') if item_request.completion_date else None,
            'completion_notes': item_request.completion_notes,
            'receipt_files': receipt_files,
            'invoice_files': invoice_files
        },
        'permissions': {
            'can_approve_manager': can_approve_manager,
            'can_reject_manager': can_reject_manager,
            'can_approve_procurement_manager': can_approve_procurement_manager,
            'can_reject_procurement_manager': can_reject_procurement_manager,
            'can_complete': can_complete
        }
    })


@app.route('/procurement/item-request/<int:request_id>/view')
@login_required
def view_item_request_page(request_id):
    """View a specific item request in full page format"""
    # Safety migration: ensure new procurement_quantities column exists before querying
    try:
        import sqlite3
        db_path = app.config['SQLALCHEMY_DATABASE_URI'].replace('sqlite:///', '')
        if os.name == 'nt':  # Windows
            db_path = db_path.replace('/', '\\')

        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        cursor.execute("PRAGMA table_info(procurement_item_requests)")
        existing_columns = [row[1] for row in cursor.fetchall()]

        if 'procurement_quantities' not in existing_columns:
            cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_quantities TEXT")
            conn.commit()
            print("‚úì Added 'procurement_quantities' column to procurement_item_requests table (view_item_request_page)")

        conn.close()
    except Exception as e:
        print(f"Warning: Could not ensure procurement_quantities column exists: {e}")

    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Check access permissions
    can_view = False
    
    # Check if user is a temporary manager for item requests (this overrides regular permissions)
    is_temp_manager_for_item = False
    try:
        req_dept_normalized = (item_request.department or '').strip().lower() if item_request.department else ''
        if req_dept_normalized:
            temp_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            for ta in temp_assignments:
                ta_dept_normalized = (ta.department or '').strip().lower() if ta.department else ''
                if ta_dept_normalized == req_dept_normalized:
                    is_temp_manager_for_item = True
                    print(f"DEBUG: view_item_request_page - User {current_user.user_id} is temp manager for item requests from department '{item_request.department}'")
                    break
    except Exception as e:
        print(f"DEBUG: Error checking temp manager for item in view: {e}")
    
    # If user is a temporary manager, they can view ALL requests from their assigned department
    if is_temp_manager_for_item:
        can_view = True
    elif current_user.department == 'Procurement':
        # Procurement Department Manager can view all Procurement department requests regardless of status
        if current_user.role == 'Department Manager' and item_request.department == 'Procurement':
            can_view = True
        # Allow procurement users to view requests they created at any status
        elif item_request.user_id == current_user.user_id:
            can_view = True
        # All Procurement staff (Manager and Staff) can view all requests except "Pending Manager Approval" and "Rejected by Manager"
        elif item_request.status not in ['Pending Manager Approval', 'Rejected by Manager']:
            can_view = True
    elif current_user.role in ['GM', 'Operation Manager']:
        # General Manager and Operation Manager can view all requests (view-only)
        can_view = True
    elif current_user.department == 'IT':
        # IT department can view all item requests (view-only, consistent with item requests listing)
        can_view = True
    elif current_user.department == 'Auditing' and item_request.status == 'Completed':
        # Auditing department can view all completed item requests for auditing purposes
        can_view = True
    elif item_request.user_id == current_user.user_id:
        can_view = True
    else:
        approvers = get_authorized_manager_approvers_for_item_request(item_request)
        if current_user in approvers:
            can_view = True
    
    if not can_view:
        flash('You do not have permission to view this item request.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    # Get procurement members for assignment dropdown (only for Procurement Manager)
    procurement_members = []
    if current_user.department == 'Procurement' and current_user.role == 'Department Manager':
        procurement_members = User.query.filter_by(department='Procurement').all()
    
    # Get user names safely
    assigned_to_name = None
    if item_request.assigned_to_user_id:
        assigned_user = User.query.get(item_request.assigned_to_user_id)
        assigned_to_name = assigned_user.name if assigned_user else None
    
    assigned_by_name = None
    if item_request.assigned_by_user_id:
        assigned_by_user = User.query.get(item_request.assigned_by_user_id)
        assigned_by_name = assigned_by_user.name if assigned_by_user else None
    
    completed_by_name = None
    if item_request.completed_by_user_id:
        completed_user = User.query.get(item_request.completed_by_user_id)
        completed_by_name = completed_user.name if completed_user else None
    
    # Get manager approver name
    manager_approver_name = None
    if item_request.manager_approver_user_id:
        manager_user = User.query.get(item_request.manager_approver_user_id)
        manager_approver_name = manager_user.name if manager_user else item_request.manager_approver
    
    # Get manager rejector name
    manager_rejector_name = None
    if item_request.manager_rejector_user_id:
        rejector_user = User.query.get(item_request.manager_rejector_user_id)
        manager_rejector_name = rejector_user.name if rejector_user else item_request.manager_rejector
    elif item_request.manager_rejector:
        manager_rejector_name = item_request.manager_rejector
    
    # Get procurement manager approver name
    # IMPORTANT: Only modify the name for "Final Approval" status when showing "Pending by"
    # For "Pending Manager Approval" and "Pending Procurement Manager Approval" tabs,
    # always show the actual approver's name (even if they're unassigned) for historical accuracy
    procurement_manager_approver_name = None
    if item_request.procurement_manager_approver_user_id:
        pm_user = User.query.get(item_request.procurement_manager_approver_user_id)
        procurement_manager_approver_name = pm_user.name if pm_user else item_request.procurement_manager_approver
    
    # Special handling ONLY for "Final Approval" status "Pending by" display
    # If the approver was a temp manager who is now unassigned, show Procurement Department Manager instead
    if item_request.status == 'Final Approval' and item_request.procurement_manager_approver_user_id:
        # Check if the approver is still a temporary manager with include_procurement_approvals
        is_still_temp_manager = False
        try:
            temp_assign = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == item_request.procurement_manager_approver_user_id,
                DepartmentTemporaryManager.include_procurement_approvals == True,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).first()
            is_still_temp_manager = temp_assign is not None
        except Exception:
            pass
        
        if not is_still_temp_manager:
            # No longer a temp manager - show Procurement Department Manager instead for "Pending by"
            procurement_managers = User.query.filter_by(
                department='Procurement',
                role='Department Manager'
            ).all()
            if procurement_managers:
                procurement_manager_approver_name = procurement_managers[0].name
            else:
                procurement_manager_approver_name = 'Procurement Manager'
    
    # Determine the manager's name for display (same logic as payment requests)
    manager_name = None
    temporary_manager_name = None
    
    # Get the requestor user to check manager_id
    requestor_user = None
    if item_request.user_id:
        requestor_user = User.query.get(item_request.user_id)
    
    # CRITICAL: For ITEM REQUESTS, check department-level temporary manager based on request_type
    # This applies to ALL requests (old and new)
    # For item requests, only show temporary managers assigned for:
    #   - "Procurement Item Request" OR
    #   - "Both Payment and Item Request"
    # DO NOT show temporary managers assigned only for "Finance Payment Request"
    dt = None
    try:
        req_dept = (item_request.department or '').strip()
        print(f"=== ITEM REQUEST TEMP MANAGER LOOKUP ===")
        print(f"Item Request ID: {item_request.id}, Department: '{req_dept}' (length: {len(req_dept)})")
        
        if req_dept:
            # Step 1: Query ONLY temporary managers that are valid for item requests
            # This explicitly excludes "Finance Payment Request" only entries
            item_temp_managers = DepartmentTemporaryManager.query.filter(
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            
            print(f"Found {len(item_temp_managers)} temporary manager(s) for item requests")
            
            # Normalize request department for comparison
            req_dept_normalized = req_dept.lower().strip()
            
            # Step 2: Priority 1 - Look for exact "Procurement Item Request" match first
            for temp_dt in item_temp_managers:
                dt_dept = (temp_dt.department or '').strip()
                dt_dept_normalized = dt_dept.lower().strip()
                
                print(f"  Checking: dept='{dt_dept}' (normalized: '{dt_dept_normalized}'), request_type='{temp_dt.request_type}', manager_id={temp_dt.temporary_manager_id}")
                
                if dt_dept_normalized == req_dept_normalized and temp_dt.request_type == 'Procurement Item Request':
                    dt = temp_dt
                    print(f"  ‚úì MATCHED 'Procurement Item Request'! Selected: manager_id={dt.temporary_manager_id}")
                    break
            
            # Step 3: Priority 2 - If no exact match, look for "Both Payment and Item Request"
            if not dt:
                for temp_dt in item_temp_managers:
                    dt_dept = (temp_dt.department or '').strip()
                    dt_dept_normalized = dt_dept.lower().strip()
                    
                    if dt_dept_normalized == req_dept_normalized and temp_dt.request_type == 'Both Payment and Item Request':
                        dt = temp_dt
                        print(f"  ‚úì MATCHED 'Both Payment and Item Request'! Selected: manager_id={dt.temporary_manager_id}")
                        break
            
            if not dt:
                print(f"  ‚úó No matching item request temporary manager found for department '{req_dept}'")
    except Exception as e:
        print(f"ERROR: Exception finding item request temporary manager: {e}")
        import traceback
        traceback.print_exc()
        dt = None
    
    # Step 4: Get the user name for the selected temporary manager
    if dt:
        try:
            temp_user = User.query.get(dt.temporary_manager_id)
            if temp_user:
                temporary_manager_name = temp_user.name
                print(f"=== FINAL RESULT: temporary_manager_name = '{temp_user.name}' (ID: {dt.temporary_manager_id}, request_type: '{dt.request_type}') ===")
            else:
                print(f"WARNING: Temporary manager user not found for ID: {dt.temporary_manager_id}")
        except Exception as e:
            print(f"ERROR: Exception getting temporary manager user: {e}")
            pass
    else:
        print(f"=== FINAL RESULT: No temporary manager found, temporary_manager_name = None ===")
    
    # Determine manager name for all statuses (pending and completed)
    if requestor_user and requestor_user.manager_id:
        # Get the manager's name from the manager_id
        manager = User.query.get(requestor_user.manager_id)
        if manager:
            manager_name = manager.name
        else:
            # If manager_id exists but user not found, try to find Department Manager
            dept_manager = User.query.filter_by(role='Department Manager', department=item_request.department).first()
            if dept_manager:
                manager_name = dept_manager.name
    else:
        # Special display case: Branch Manager or Supervisor requests should show Branch Inventory Officer(s) as Assigned Manager
        try:
            if requestor_user and requestor_user.role in ['Branch Manager', 'Supervisor'] and (requestor_user.department or '').strip().lower() == 'branch':
                bios = User.query.filter_by(role='Branch Inventory Officer').all()
                if bios:
                    # Join multiple names if more than one Branch Inventory Officer exists
                    manager_name = ', '.join([b.name for b in bios])
                else:
                    # Fallback to Department Manager if no Branch Inventory Officer found
                    dept_manager = User.query.filter_by(role='Department Manager', department=item_request.department).first()
                    if dept_manager:
                        manager_name = dept_manager.name
                # Do not continue to other fallbacks for Branch Manager/Supervisor
        except Exception as e:
            app.logger.warning(f"Error resolving Branch Inventory Officer for display: {e}")
        # If no manager_id is set or Branch Inventory Officer not found, find the Department Manager for the requestor's department
        if not manager_name:
            dept_manager = User.query.filter_by(role='Department Manager', department=item_request.department).first()
            if dept_manager:
                manager_name = dept_manager.name
            elif item_request.department in ['Operation', 'Project']:
                # For Operation and Project, try Operation Manager as fallback
                operation_manager = User.query.filter_by(role='Operation Manager').first()
                if operation_manager:
                    manager_name = operation_manager.name
            elif item_request.department == 'Office':
                # For Office, fallback to the General Manager
                gm_user_fallback = User.query.filter_by(role='GM').first()
                if gm_user_fallback:
                    manager_name = gm_user_fallback.name
    
    # Also resolve GM and Operation Manager names (used for Department Manager submissions)
    gm_user = User.query.filter_by(role='GM').first()
    gm_name = gm_user.name if gm_user else 'General Manager'
    op_manager_user = User.query.filter_by(role='Operation Manager').first()
    op_manager_name = op_manager_user.name if op_manager_user else 'Operation Manager'
    
    # Check what actions current user can perform
    can_approve_manager = False
    can_reject_manager = False
    can_approve_procurement_manager = False
    can_reject_procurement_manager = False
    can_complete = False
    
    # Manager approval: GM and Operation Manager can approve (in addition to assigned manager and temporary manager)
    # Also allow when status is 'On Hold' (if it was put on hold by manager)
    if item_request.status in ['Pending Manager Approval', 'On Hold']:
        approvers = get_authorized_manager_approvers_for_item_request(item_request)
        if current_user in approvers:
            # Check if it's on hold by manager (not procurement manager)
            if item_request.status == 'On Hold' and item_request.manager_on_hold_by_user_id:
                can_approve_manager = True
                can_reject_manager = True
            elif item_request.status == 'Pending Manager Approval':
                can_approve_manager = True
                can_reject_manager = True
    
    # Procurement Manager approval: Only Procurement Department Manager can approve
    # OR temporary managers with include_procurement_approvals=True
    # Also allow when status is 'On Hold' (if it was put on hold by procurement manager)
    if item_request.status in ['Pending Procurement Manager Approval', 'On Hold', 'Final Approval']:
        is_procurement_dept_manager = current_user.department == 'Procurement' and current_user.role == 'Department Manager'
        
        # Check if user is a temporary manager with include_procurement_approvals enabled
        is_temp_procurement_approver = False
        try:
            temp_procurement_approvers = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                DepartmentTemporaryManager.include_procurement_approvals == True,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            is_temp_procurement_approver = len(temp_procurement_approvers) > 0
        except Exception:
            pass
        
        if is_procurement_dept_manager or is_temp_procurement_approver:
            # Check if it's on hold by procurement manager (not manager)
            if item_request.status == 'On Hold' and item_request.procurement_manager_on_hold_by_user_id:
                can_approve_procurement_manager = True
                can_reject_procurement_manager = True
            elif item_request.status in ['Pending Procurement Manager Approval', 'Final Approval']:
                can_approve_procurement_manager = True
                can_reject_procurement_manager = True
    
    # Completion: Only the assigned procurement staff can complete when status is 'Assigned to Procurement' (GM and Operation Manager cannot complete)
    if current_user.role not in ['GM', 'Operation Manager']:
        if item_request.status == 'Assigned to Procurement' and current_user.department == 'Procurement':
            # Only allow completion if the current user is the assigned user
            if item_request.assigned_to_user_id and item_request.assigned_to_user_id == current_user.user_id:
                can_complete = True
    
    # Authorization for scheduling payment date (similar to payment requests)
    can_schedule_payment_date = False
    payment_date_scheduled_by = None
    
    # Only allow scheduling when status is Pending Manager Approval or Pending Procurement Manager Approval
    if item_request.status in ['Pending Manager Approval', 'Pending Procurement Manager Approval']:
        try:
            # Get authorized approvers (same logic as manager approval)
            approvers = get_authorized_manager_approvers_for_item_request(item_request)
            # Also include Procurement Manager if status is Pending Procurement Manager Approval
            if item_request.status == 'Pending Procurement Manager Approval':
                if current_user.department == 'Procurement' and current_user.role == 'Department Manager':
                    can_schedule_payment_date = True
            # Check if current user is an authorized approver
            if current_user in approvers:
                can_schedule_payment_date = True
            
            # Resolve the name of the scheduler from audit logs (latest)
            if item_request.payment_date:
                from models import AuditLog
                keyword = f"item request #{request_id}"
                log = (
                    AuditLog.query
                    .filter(AuditLog.action.like('%scheduled for%'))
                    .filter(AuditLog.action.like(f"%{keyword}%"))
                    .order_by(AuditLog.timestamp.desc())
                    .first()
                )
                if log:
                    payment_date_scheduled_by = getattr(log.user, 'name', None) or log.username_snapshot or 'Unknown'
        except Exception as e:
            # Fail-safe: do not break view if any of the above fails
            print(f"DEBUG: Error computing can_schedule_payment_date or scheduled_by: {e}")
    
    # Prepare receipt files list
    receipt_files = []
    if item_request.receipt_path:
        try:
            data = json.loads(item_request.receipt_path)
            if isinstance(data, list):
                receipt_files = data
            else:
                receipt_files = [item_request.receipt_path]
        except (json.JSONDecodeError, TypeError):
            receipt_files = [item_request.receipt_path]
    
    # Prepare requestor-uploaded item files (stored in requestor_item_upload_path)
    requestor_item_uploads = []
    if getattr(item_request, 'requestor_item_upload_path', None):
        try:
            data = json.loads(item_request.requestor_item_upload_path)
            if isinstance(data, list):
                requestor_item_uploads = data
            else:
                requestor_item_uploads = [item_request.requestor_item_upload_path]
        except (json.JSONDecodeError, TypeError):
            requestor_item_uploads = [item_request.requestor_item_upload_path]
    # Prepare requestor-uploaded evidence files (stored in requestor_evidence_upload_path)
    requestor_evidence_uploads = []
    if getattr(item_request, 'requestor_evidence_upload_path', None):
        try:
            data = json.loads(item_request.requestor_evidence_upload_path)
            if isinstance(data, list):
                requestor_evidence_uploads = data
            else:
                requestor_evidence_uploads = [item_request.requestor_evidence_upload_path]
        except (json.JSONDecodeError, TypeError):
            requestor_evidence_uploads = [item_request.requestor_evidence_upload_path]

    # Prepare invoice files list (supports legacy string list and new metadata objects)
    def _parse_invoice_entries(raw_value):
        entries = []
        if not raw_value:
            return entries
        try:
            data = json.loads(raw_value)
        except (json.JSONDecodeError, TypeError):
            return [{'filename': raw_value, 'items': [], 'amount': None}]

        if isinstance(data, list):
            for entry in data:
                if isinstance(entry, dict):
                    fname = entry.get('filename') or entry.get('file') or entry.get('name')
                    items = entry.get('items') or entry.get('item_names') or []
                    amount_val = entry.get('amount')
                    if fname:
                        if not isinstance(items, list):
                            items = []
                        clean_items = [itm.strip() for itm in items if isinstance(itm, str) and itm.strip()]
                        entries.append({'filename': fname, 'items': clean_items, 'amount': amount_val})
                elif isinstance(entry, str):
                    entries.append({'filename': entry, 'items': [], 'amount': None})
        elif isinstance(data, dict):
            fname = data.get('filename') or data.get('file') or data.get('name')
            items = data.get('items') or []
            amount_val = data.get('amount')
            if fname:
                if not isinstance(items, list):
                    items = []
                clean_items = [itm.strip() for itm in items if isinstance(itm, str) and itm.strip()]
                entries.append({'filename': fname, 'items': clean_items, 'amount': amount_val})
        else:
            entries.append({'filename': raw_value, 'items': [], 'amount': None})

        return entries

    invoice_entries = _parse_invoice_entries(item_request.invoice_path)
    invoice_files = [entry.get('filename') for entry in invoice_entries if entry.get('filename')]

    # Items assigned to this request (used for invoice-to-item mapping)
    assigned_items = []
    if item_request.item_name:
        assigned_items = [itm.strip() for itm in item_request.item_name.split(',') if itm.strip()]

    # Current quantities aligned with assigned items (used to disable zero-qty items in invoice mapping)
    assigned_item_quantities = []
    try:
        # Prefer quantities saved by the assigned procurement staff. If not present,
        # fall back to procurement manager-approved quantities, then manager quantities,
        # and finally the original requested quantity.
        raw_quantity_source = item_request.assigned_procurement_quantities or item_request.procurement_manager_quantities or item_request.procurement_quantities or item_request.quantity
        quantity_list = (raw_quantity_source or '').split(';') if raw_quantity_source else []
        for idx, itm in enumerate(assigned_items):
            qty_raw = quantity_list[idx].strip() if idx < len(quantity_list) else ''
            if ':' in qty_raw:
                parts = qty_raw.split(':', 1)
                qty_raw = parts[1].strip() if len(parts) > 1 else qty_raw
            try:
                assigned_item_quantities.append(int(qty_raw))
            except Exception:
                assigned_item_quantities.append(0)
    except Exception:
        assigned_item_quantities = [0 for _ in assigned_items]

    # Check if quantities have been edited (for showing Edited chip)
    quantities_edited = False
    try:
        result = db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS item_request_quantity_edits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_request_id INTEGER NOT NULL,
                first_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(item_request_id)
            );
        '''))
        result.close()
        row = db.session.execute(db.text('SELECT 1 FROM item_request_quantity_edits WHERE item_request_id = :rid'), {'rid': request_id}).fetchone()
        quantities_edited = row is not None
    except Exception:
        quantities_edited = False

    return render_template('view_item_request.html',
                         item_request=item_request,
                         user=current_user,
                         procurement_members=procurement_members,
                         assigned_to_name=assigned_to_name,
                         assigned_by_name=assigned_by_name,
                         completed_by_name=completed_by_name,
                         receipt_files=receipt_files,
                         requestor_item_uploads=requestor_item_uploads,
                         requestor_evidence_uploads=requestor_evidence_uploads,
                         invoice_files=invoice_files,
                         invoice_entries=invoice_entries,
                         manager_approver_name=manager_approver_name,
                         manager_rejector_name=manager_rejector_name,
                         procurement_manager_approver_name=procurement_manager_approver_name,
                         manager_name=manager_name,
                         temporary_manager_name=temporary_manager_name,
                         gm_name=gm_name,
                         op_manager_name=op_manager_name,
                         requestor_user=requestor_user,
                         can_approve_manager=can_approve_manager,
                         can_reject_manager=can_reject_manager,
                         can_approve_procurement_manager=can_approve_procurement_manager,
                         can_reject_procurement_manager=can_reject_procurement_manager,
                         can_complete=can_complete,
                         can_schedule_payment_date=can_schedule_payment_date,
                         payment_date_scheduled_by=payment_date_scheduled_by,
                         quantities_edited=quantities_edited,
                         assigned_items=assigned_items,
                         assigned_item_quantities=assigned_item_quantities)


@app.route('/api/item-request/<int:request_id>/quantity-history', methods=['GET'])
@login_required
def get_item_request_quantity_history(request_id):
    """Return JSON history entries for quantity edits for this item request."""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Check access permissions (same as view_item_request_page)
    can_view = False
    
    # Check if user is a temporary manager for item requests (this overrides regular permissions)
    is_temp_manager_for_item = False
    try:
        req_dept_normalized = (item_request.department or '').strip().lower() if item_request.department else ''
        if req_dept_normalized:
            temp_assignments = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            for ta in temp_assignments:
                ta_dept_normalized = (ta.department or '').strip().lower() if ta.department else ''
                if ta_dept_normalized == req_dept_normalized:
                    is_temp_manager_for_item = True
                    break
    except Exception:
        pass
    
    # If user is a temporary manager, they can view ALL requests from their assigned department
    if is_temp_manager_for_item:
        can_view = True
    elif current_user.department == 'Procurement':
        if item_request.status not in ['Pending Manager Approval', 'Rejected by Manager']:
            can_view = True
    elif current_user.role in ['GM', 'Operation Manager']:
        can_view = True
    elif current_user.department == 'IT':
        can_view = True
    elif current_user.department == 'Auditing' and item_request.status == 'Completed':
        can_view = True
    elif item_request.user_id == current_user.user_id:
        can_view = True
    else:
        approvers = get_authorized_manager_approvers_for_item_request(item_request)
        if current_user in approvers:
            can_view = True
    
    if not can_view:
        return jsonify({'success': False, 'error': 'Not authorized'}), 403

    try:
        # Create table if it doesn't exist
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS item_request_quantity_edit_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_request_id INTEGER NOT NULL,
                old_value TEXT,
                new_value TEXT,
                edited_by_user_id INTEGER,
                edited_by_name TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        '''))
        
        rows = db.session.execute(
            db.text('''SELECT old_value, new_value, edited_by_name, created_at
                       FROM item_request_quantity_edit_logs
                       WHERE item_request_id = :rid
                       ORDER BY created_at DESC'''),
            {'rid': request_id}
        ).fetchall()
        
        history = []
        for r in rows:
            # Format quantities for display
            old_quantities = r[0] or ''
            new_quantities = r[1] or ''
            
            # If it's a multi-item request, format as list
            item_names = (item_request.item_name or '').split(',')
            
            # Parse quantities - could be JSON array or semicolon-separated
            old_list = []
            new_list = []
            
            if old_quantities:
                if old_quantities.strip().startswith('['):
                    # JSON format
                    try:
                        old_list = json.loads(old_quantities)
                    except:
                        old_list = old_quantities.split(';') if ';' in old_quantities else [old_quantities]
                else:
                    # Semicolon-separated format
                    old_list = old_quantities.split(';') if old_quantities else []
            
            if new_quantities:
                if new_quantities.strip().startswith('['):
                    # JSON format
                    try:
                        new_list = json.loads(new_quantities)
                    except:
                        new_list = new_quantities.split(';') if ';' in new_quantities else [new_quantities]
                else:
                    # Semicolon-separated format
                    new_list = new_quantities.split(';') if new_quantities else []
            
            # Build formatted display strings (one per line)
            # Helper function to extract just the quantity value (in case old_value already has item names)
            def extract_quantity(value_str):
                """Extract quantity from a string that might be 'item: qty' or just 'qty'"""
                if not value_str:
                    return ''
                value_str = value_str.strip()
                # If it contains ':', it might already have item name, extract just the quantity part
                if ':' in value_str:
                    # Split by ':' and take the last part (should be the quantity)
                    parts = value_str.rsplit(':', 1)  # Use rsplit to handle cases with multiple colons
                    if len(parts) == 2:
                        return parts[1].strip()
                return value_str
            
            old_display = []
            new_display = []
            for i, item_name in enumerate(item_names):
                item_name = item_name.strip()
                if item_name:
                    # Convert to string in case they're from JSON (could be int or str)
                    old_qty_raw = str(old_list[i]).strip() if i < len(old_list) else ''
                    new_qty_raw = str(new_list[i]).strip() if i < len(new_list) else ''
                    # Extract just the quantity part (in case it already has item name from previous formatting)
                    old_qty = extract_quantity(old_qty_raw)
                    new_qty = extract_quantity(new_qty_raw)
                    if old_qty or new_qty:
                        old_display.append(f"{item_name}: {old_qty if old_qty else 'Not specified'}")
                        new_display.append(f"{item_name}: {new_qty if new_qty else 'Not specified'}")
            
            # Join with newlines instead of semicolons
            old_formatted = '\n'.join(old_display) if old_display else (old_quantities if old_quantities else 'Not specified')
            new_formatted = '\n'.join(new_display) if new_display else (new_quantities if new_quantities else 'Not specified')
            
            # Convert timestamp from UTC to local time (UTC+4)
            edited_at_utc = r[3]
            edited_at_local = None
            if edited_at_utc:
                try:
                    # Parse the datetime string from SQLite
                    if isinstance(edited_at_utc, str):
                        # SQLite returns datetime as string, parse it
                        edited_at_utc = datetime.strptime(edited_at_utc, '%Y-%m-%d %H:%M:%S')
                    # Convert UTC to local time (UTC+4)
                    edited_at_local = (edited_at_utc + timedelta(hours=4)).strftime('%B %d, %Y at %I:%M %p')
                except Exception as e:
                    # If parsing fails, use the original value
                    edited_at_local = str(edited_at_utc) if edited_at_utc else ''
            
            history.append({
                'old_value': old_formatted,
                'new_value': new_formatted,
                'edited_by': r[2] or 'Unknown',
                'edited_at': edited_at_local or ''
            })
        
        return jsonify({'success': True, 'history': history})
    except Exception as e:
        app.logger.error(f"Error fetching item request quantity history: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/procurement/item-request/<int:request_id>/schedule_payment_date', methods=['POST'])
@login_required
def schedule_item_payment_date(request_id):
    """Allow authorized users to set a payment date for item requests (optional)."""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Only allowed when request is in these statuses
    if item_request.status not in ['Pending Manager Approval', 'Pending Procurement Manager Approval']:
        flash('Payment date can only be scheduled when status is Pending Manager Approval or Pending Procurement Manager Approval.', 'error')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Authorization logic - same as manager approval authorization
    authorized = False
    approvers = get_authorized_manager_approvers_for_item_request(item_request)
    
    # Check if current user is an authorized approver
    if current_user in approvers:
        authorized = True
    # Also allow Procurement Manager if status is Pending Procurement Manager Approval
    elif item_request.status == 'Pending Procurement Manager Approval':
        if current_user.department == 'Procurement' and current_user.role == 'Department Manager':
            authorized = True
    
    if not authorized:
        flash('You are not authorized to schedule a payment date for this request.', 'error')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    payment_date_str = request.form.get('payment_date', '').strip()
    if not payment_date_str:
        flash('Please select a payment date.', 'error')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    try:
        from datetime import datetime as _dt
        payment_date_val = _dt.strptime(payment_date_str, '%Y-%m-%d').date()
    except Exception:
        flash('Invalid payment date format.', 'error')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Persist payment date
    item_request.payment_date = payment_date_val
    item_request.updated_at = datetime.utcnow()
    db.session.commit()
    
    # Audit and log
    log_action(
        f"Item request #{request_id} from {item_request.requestor_name} in the {item_request.department} department has been scheduled for {payment_date_val} by {current_user.name}"
    )
    
    # Notify all authorized users
    try:
        title = "Item Request Payment Date Scheduled"
        msg = (
            f"Item request #{request_id} from {item_request.requestor_name} in the {item_request.department} department "
            f"has been scheduled for {payment_date_val.strftime('%B %d, %Y')} by {current_user.name}."
        )
        notified_user_ids = set()
        
        def add_user(u):
            if u and getattr(u, 'user_id', None):
                notified_user_ids.add(u.user_id)
        
        # Requestor
        if item_request.user_id:
            requestor_user = User.query.get(item_request.user_id)
            add_user(requestor_user)
        
        # Department Manager of the requestor's department
        try:
            dept_managers = User.query.filter_by(role='Department Manager', department=item_request.department).all()
        except Exception:
            dept_managers = []
        for u in dept_managers:
            add_user(u)
        
        # Authorized approvers
        for approver in approvers:
            add_user(approver)
        
        # Procurement Managers
        try:
            procurement_managers = User.query.filter_by(department='Procurement', role='Department Manager').all()
        except Exception:
            procurement_managers = []
        for u in procurement_managers:
            add_user(u)
        
        # General Managers
        try:
            gms = User.query.filter_by(role='GM').all()
        except Exception:
            gms = []
        for u in gms:
            add_user(u)
        
        # Operation Managers
        try:
            opms = User.query.filter_by(role='Operation Manager').all()
        except Exception:
            opms = []
        for u in opms:
            add_user(u)
        
        # Send notifications
        for user_id in notified_user_ids:
            create_notification(
                user_id=user_id,
                title=title,
                message=msg,
                notification_type="payment_scheduled",
                item_request_id=request_id
            )
    except Exception as e:
        print(f"Error sending notifications for scheduled payment date: {e}")
    
    flash(f'Payment date scheduled for {payment_date_val.strftime("%B %d, %Y")}.', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/manager-decision', methods=['POST'])
@login_required
def item_request_manager_decision(request_id):
    """Unified route for manager decisions (approve, reject, on_hold)"""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Check authorization
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    if current_user not in authorized_approvers:
        flash('You are not authorized to make decisions on this request.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    # Allow decisions when status is 'Pending Manager Approval' or 'On Hold'
    if item_request.status not in ['Pending Manager Approval', 'On Hold']:
        flash('This request is not pending manager approval or on hold.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    approval_status = request.form.get('approval_status')
    
    if approval_status == 'approve':
        return item_request_manager_approve_handler(request_id, item_request)
    elif approval_status == 'reject':
        return item_request_manager_reject_handler(request_id, item_request)
    elif approval_status == 'on_hold':
        return item_request_manager_on_hold_handler(request_id, item_request)
    else:
        flash('Invalid approval status.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))


def item_request_manager_approve_handler(request_id, item_request):
    """Handler for manager approval"""
    current_time = datetime.utcnow()
    
    # Update request
    item_request.status = 'Pending Procurement Manager Approval'
    item_request.manager_approval_date = current_time.date()
    item_request.manager_approver = current_user.name
    item_request.manager_approver_user_id = current_user.user_id
    item_request.manager_approval_end_time = current_time
    item_request.is_urgent = request.form.get('is_urgent') == 'on'
    item_request.manager_approval_reason = request.form.get('approval_reason', '').strip()
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Manager approved item request #{request_id}")
    
    # Notify requestor
    if item_request.user_id:
        formatted_items = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
        create_notification(
            user_id=item_request.user_id,
            title="Item Request Approved by Manager",
            message=f"Your item request #{request_id} for {formatted_items} has been approved by your manager and sent to Procurement Manager.",
            notification_type="request_approved",
            item_request_id=request_id
        )
    
    # Notify Procurement Managers and temporary managers with include_procurement_approvals
    procurement_managers = User.query.filter_by(
        department='Procurement',
        role='Department Manager'
    ).all()
    for pm in procurement_managers:
        create_notification(
            user_id=pm.user_id,
            title="New Item Request for Approval",
            message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) requires your approval.",
            notification_type="new_submission",
            item_request_id=request_id
        )
    
    # Notify temporary managers with include_procurement_approvals enabled
    try:
        temp_procurement_approvers = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.include_procurement_approvals == True,
            db.or_(
                DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).all()
        for temp_assign in temp_procurement_approvers:
            temp_manager = User.query.get(temp_assign.temporary_manager_id)
            if temp_manager:
                create_notification(
                    user_id=temp_manager.user_id,
                    title="New Item Request for Procurement Manager Approval",
                    message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) requires your procurement manager approval.",
                    notification_type="new_submission",
                    item_request_id=request_id
                )
    except Exception as e:
        print(f"DEBUG: Error notifying temp procurement approvers: {e}")
    
    # Notify other authorized managers (who could have approved but didn't) that the request was approved
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    for approver in authorized_approvers:
        if approver.user_id != current_user.user_id:  # Don't notify the approver themselves
            create_notification(
                user_id=approver.user_id,
                title="Item Request Approved by Assigned Manager",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) has been approved by {current_user.name} and sent to Procurement Manager.",
                notification_type="request_approved",
                item_request_id=request_id
            )
    
    flash('Item request approved successfully!', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


def item_request_manager_reject_handler(request_id, item_request):
    """Handler for manager rejection"""
    rejection_reason = request.form.get('rejection_reason', '').strip()
    if not rejection_reason:
        flash('Please provide a reason for rejection.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    current_time = datetime.utcnow()
    
    # Update request
    item_request.status = 'Rejected by Manager'
    item_request.manager_rejection_date = current_time.date()
    item_request.manager_rejector = current_user.name
    item_request.manager_rejector_user_id = current_user.user_id
    item_request.manager_rejection_reason = rejection_reason
    item_request.manager_approval_end_time = current_time
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Manager rejected item request #{request_id}")
    
    # Format item names with spaces
    formatted_items = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Notify requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request Rejected by Manager",
            message=f"Your item request #{request_id} for {formatted_items} has been rejected by your manager. Reason: {rejection_reason}",
            notification_type="request_rejected",
            item_request_id=request_id
        )
    
    # Procurement managers are intentionally not notified when a manager rejects a request.
    
    # Notify other authorized managers (who could have approved but didn't) that the request was rejected
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    for approver in authorized_approvers:
        if approver.user_id != current_user.user_id:  # Don't notify the rejector themselves
            create_notification(
                user_id=approver.user_id,
                title="Item Request Rejected by Another Manager",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_items} has been rejected by {current_user.name}. Reason: {rejection_reason}",
                notification_type="request_rejected",
                item_request_id=request_id
            )
    
    flash('Item request rejected.', 'info')
    return redirect(url_for('view_item_request_page', request_id=request_id))


def item_request_manager_on_hold_handler(request_id, item_request):
    """Handler for manager on hold"""
    on_hold_reason = request.form.get('on_hold_reason', '').strip()
    
    current_time = datetime.utcnow()
    
    # Update request - change status to 'On Hold'
    item_request.status = 'On Hold'
    item_request.manager_on_hold_date = current_time.date()
    item_request.manager_on_hold_by = current_user.name
    item_request.manager_on_hold_by_user_id = current_user.user_id
    item_request.manager_on_hold_reason = on_hold_reason
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Manager put item request #{request_id} on hold")
    
    # Format item names with spaces
    formatted_items = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Build message
    message_base = f"Item request #{request_id} for {formatted_items} has been put on hold by {current_user.name}."
    if on_hold_reason:
        message_base += f" Reason: {on_hold_reason}"
    
    # Notify requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request On Hold",
            message=f"Your {message_base.lower()}",
            notification_type="request_on_hold",
            item_request_id=request_id
        )
    
    # Notify all authorized managers (including temporary managers, Operation Manager, GM)
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    for approver in authorized_approvers:
        if approver.user_id != current_user.user_id:  # Don't notify the person who put it on hold
            create_notification(
                user_id=approver.user_id,
                title="Item Request On Hold",
                message=message_base,
                notification_type="request_on_hold",
                item_request_id=request_id
            )
    
    # Notify IT Department (all IT Staff and IT Department Manager)
    it_users = User.query.filter(
        User.department == 'IT'
    ).filter(
        User.role.in_(['IT Staff', 'Department Manager'])
    ).all()
    
    for it_user in it_users:
        create_notification(
            user_id=it_user.user_id,
            title="Item Request On Hold",
            message=message_base,
            notification_type="request_on_hold",
            item_request_id=request_id
        )
    
    flash('Item request has been put on hold.', 'warning')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/manager-reject', methods=['POST'])
@login_required
def item_request_manager_reject(request_id):
    """Manager rejects an item request"""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Check authorization
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    if current_user not in authorized_approvers:
        flash('You are not authorized to reject this request.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    if item_request.status != 'Pending Manager Approval':
        flash('This request is not pending manager approval.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    rejection_reason = request.form.get('rejection_reason', '').strip()
    if not rejection_reason:
        flash('Please provide a reason for rejection.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    current_time = datetime.utcnow()
    
    # Update request
    item_request.status = 'Rejected by Manager'
    item_request.manager_rejection_date = current_time.date()
    item_request.manager_rejector = current_user.name
    item_request.manager_rejector_user_id = current_user.user_id
    item_request.manager_rejection_reason = rejection_reason
    item_request.manager_approval_end_time = current_time
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Manager rejected item request #{request_id}")
    
    # Notify requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request Rejected by Manager",
            message=f"Your item request #{request_id} for {item_request.item_name} has been rejected by your manager. Reason: {rejection_reason}",
            notification_type="request_rejected",
            item_request_id=request_id
        )
    
    # Procurement managers are intentionally not notified when a manager rejects a request.
    
    # Notify other authorized managers (who could have approved but didn't) that the request was rejected
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    for approver in authorized_approvers:
        if approver.user_id != current_user.user_id:  # Don't notify the rejector themselves
            create_notification(
                user_id=approver.user_id,
                title="Item Request Rejected by Another Manager",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {item_request.item_name} has been rejected by {current_user.name}. Reason: {rejection_reason}",
                notification_type="request_rejected"
            )
    
    flash('Item request rejected.', 'info')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/procurement-manager-decision', methods=['POST'])
@login_required
def item_request_procurement_manager_decision(request_id):
    """Unified route for procurement manager decisions (approve, reject, on_hold)"""
    is_procurement_dept_manager = current_user.department == 'Procurement' and current_user.role == 'Department Manager'
    
    # Check if user is a temporary manager with include_procurement_approvals enabled
    is_temp_procurement_approver = False
    try:
        temp_procurement_approvers = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.temporary_manager_id == current_user.user_id,
            DepartmentTemporaryManager.include_procurement_approvals == True,
            db.or_(
                DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).all()
        is_temp_procurement_approver = len(temp_procurement_approvers) > 0
        print(f"DEBUG: procurement-manager-decision - User {current_user.user_id} is_temp_procurement_approver: {is_temp_procurement_approver}")
    except Exception as e:
        print(f"DEBUG: Error checking temp procurement approver: {e}")
    
    if not is_procurement_dept_manager and not is_temp_procurement_approver:
        flash('Access denied. Only Procurement Department Managers or temporary managers with procurement approval permissions can perform this action.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Allow decisions when status is 'Pending Procurement Manager Approval', 'Final Approval', or 'On Hold'
    if item_request.status not in ['Pending Procurement Manager Approval', 'Final Approval', 'On Hold']:
        flash('This request is not pending procurement manager approval, final approval, or on hold.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    approval_status = request.form.get('approval_status')
    
    if approval_status == 'approve':
        return item_request_procurement_manager_approve_handler(request_id, item_request)
    elif approval_status == 'reject':
        return item_request_procurement_manager_reject_handler(request_id, item_request)
    elif approval_status == 'on_hold':
        return item_request_procurement_manager_on_hold_handler(request_id, item_request)
    else:
        flash('Invalid approval status.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))


def item_request_procurement_manager_approve_handler(request_id, item_request):
    """Handler for procurement manager approval"""
    # Get and validate amount
    amount_str = request.form.get('amount', '').strip()
    
    # Amount is always optional for Procurement Manager approval
    amount = None
    if amount_str:
        try:
            amount = float(amount_str)
            if amount < 0:
                flash('Amount cannot be negative.', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))
        except ValueError:
            flash('Invalid amount format.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Only perform balance check if amount is provided
    if amount is not None:
        # Calculate available balance to check if amount exceeds it
        # Get completed payment requests (Bank money, Procurement department)
        bank_money_requests = PaymentRequest.query.filter(
            PaymentRequest.department == 'Procurement',
            PaymentRequest.request_type == 'Bank money',
            PaymentRequest.is_archived == False
        ).all()
        
        completed_requests_bm = [r for r in bank_money_requests if r.status == 'Completed']
        completed_amount_bm = sum(float(r.amount) for r in completed_requests_bm)
        
        # Get item requests with status "Assigned to Procurement" (excluding current request if it's already assigned)
        assigned_item_requests = ProcurementItemRequest.query.filter_by(status='Assigned to Procurement').all()
        # Exclude current request if it's already in the assigned list
        assigned_item_requests = [r for r in assigned_item_requests if r.id != request_id]
        item_requests_amount = sum(float(r.invoice_amount) for r in assigned_item_requests if r.invoice_amount is not None)
        
        # Get completed item requests
        completed_item_requests = ProcurementItemRequest.query.filter_by(status='Completed').all()
        completed_item_requests_amount = sum(float(r.invoice_amount) for r in completed_item_requests if r.invoice_amount is not None)
        
        # Calculate available balance
        # Available Balance = Completed payment requests - Completed item requests only
        # (Only completed item requests reduce available balance, not assigned/pending items)
        try:
            adjustments_sum = db.session.query(func.coalesce(func.sum(CurrentMoneyEntry.adjustment_amount), 0)).filter(
                CurrentMoneyEntry.department == 'Procurement',
                CurrentMoneyEntry.entry_kind == 'manual_adjustment',
                CurrentMoneyEntry.include_in_balance == True
            ).scalar() or 0
            adjustments_sum = float(adjustments_sum)
        except Exception:
            adjustments_sum = 0.0

        available_balance = completed_amount_bm - completed_item_requests_amount + adjustments_sum
        
        # Check and notify if balance is low
        check_and_notify_low_balance(available_balance)
        
        # Check if amount exceeds available balance
        if amount > available_balance:
            flash(f'Insufficient balance. Available balance is OMR {available_balance:.3f}, but the requested amount is OMR {amount:.3f}. Please put the request on hold.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    
    current_time = datetime.utcnow()
    
    # Update request based on current status
    if item_request.status == 'Final Approval':
        # If status is 'Final Approval', set it to 'Completed'
        item_request.status = 'Completed'
        item_request.completion_date = current_time
        item_request.completed_by = current_user.name
        item_request.completed_by_user_id = current_user.user_id
    else:
        # For 'Pending Procurement Manager Approval' or 'On Hold', set to 'Assigned to Procurement'
        item_request.status = 'Assigned to Procurement'
        item_request.assigned_by_user_id = current_user.user_id
        item_request.assignment_date = current_time
    
    item_request.procurement_manager_approval_date = current_time.date()
    item_request.procurement_manager_approver = current_user.name
    item_request.procurement_manager_approver_user_id = current_user.user_id
    item_request.procurement_manager_approval_reason = request.form.get('approval_reason', '').strip()
    # Only update amount if it was provided
    if amount is not None:
        item_request.amount = amount
    item_request.updated_at = current_time

    # If procurement manager did not edit quantities, persist the manager-approved quantities (or original) as the PM-approved baseline
    pm_quantities = (item_request.procurement_manager_quantities or '').strip()
    if not pm_quantities:
        item_request.procurement_manager_quantities = item_request.procurement_quantities or item_request.quantity or ''
        # Also carry over manager rejection reason so it remains visible in the PM approval tab
        if not item_request.procurement_manager_quantity_rejection_reason and item_request.manager_quantity_rejection_reason:
            item_request.procurement_manager_quantity_rejection_reason = item_request.manager_quantity_rejection_reason
    
    db.session.commit()
    
    # Format item names with comma and space separation
    formatted_item_names = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Check if this is a completion from Final Approval status
    is_completion_from_final_approval = (item_request.status == 'Completed')
    
    if is_completion_from_final_approval:
        # COMPLETION NOTIFICATIONS - sent only when transitioning from "Final Approval" to "Completed"
        log_action(f"Procurement Manager completed item request #{request_id}")
        
        # Notify original requestor about completion
        if item_request.user_id:
            create_notification(
                user_id=item_request.user_id,
                title="Item Request Completed",
                message=f"Your item request #{request_id} for {formatted_item_names} has been completed by the Procurement Manager.",
                notification_type="request_completed",
                item_request_id=request_id
            )
        
        # Notify the manager who originally approved
        if item_request.manager_approver_user_id:
            create_notification(
                user_id=item_request.manager_approver_user_id,
                title="Item Request Completed",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} that you approved has been completed by the Procurement Manager.",
                notification_type="request_completed",
                item_request_id=request_id
            )
        
        # Notify all authorized manager approvers
        authorized_managers = get_authorized_manager_approvers_for_item_request(item_request)
        for manager in authorized_managers:
            if manager.user_id != item_request.manager_approver_user_id:
                create_notification(
                    user_id=manager.user_id,
                    title="Item Request Completed",
                    message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} has been completed by the Procurement Manager.",
                    notification_type="request_completed",
                    item_request_id=request_id
                )
        
        # Notify all procurement staff members
        procurement_staff = User.query.filter_by(department='Procurement').all()
        for staff_member in procurement_staff:
            create_notification(
                user_id=staff_member.user_id,
                title="Item Request Completed",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} has been completed.",
                notification_type="request_completed",
                item_request_id=request_id
            )
        
        # Notify all auditing department users as well
        auditing_users = User.query.filter_by(department='Auditing').all()
        for audit_user in auditing_users:
            # Avoid duplicate notification if they are already covered above
            create_notification(
                user_id=audit_user.user_id,
                title="Item Request Completed",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} has been completed.",
                notification_type="request_completed",
                item_request_id=request_id
            )
        
        flash('Item request completed successfully!', 'success')
    else:
        # APPROVAL NOTIFICATIONS - sent when transitioning from "Pending Procurement Manager Approval" or "On Hold" to "Assigned to Procurement"
        log_action(f"Procurement Manager approved item request #{request_id} - available for all procurement staff")
        
        # Notify requestor
        if item_request.user_id:
            create_notification(
                user_id=item_request.user_id,
                title="Item Request Approved by Procurement Manager",
                message=f"Your item request #{request_id} has been approved and is now available for procurement staff to process.",
                notification_type="request_approved",
                item_request_id=request_id
            )
        
        # Notify all procurement staff members
        procurement_staff = User.query.filter_by(department='Procurement').all()
        for staff_member in procurement_staff:
            create_notification(
                user_id=staff_member.user_id,
                title="New Item Request Available",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) is now available for processing.",
                notification_type="item_request_assigned",
                item_request_id=request_id
            )
        
        # Notify the manager who originally approved (they should know it progressed)
        if item_request.manager_approver_user_id:
            create_notification(
                user_id=item_request.manager_approver_user_id,
                title="Item Request Approved by Procurement Manager",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) that you approved has been approved by Procurement Manager and assigned for processing.",
                notification_type="request_approved",
                item_request_id=request_id
            )
        
        flash('Item request approved and assigned successfully!', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


def item_request_procurement_manager_reject_handler(request_id, item_request):
    """Handler for procurement manager rejection"""
    rejection_reason = request.form.get('rejection_reason', '').strip()
    if not rejection_reason:
        flash('Please provide a reason for rejection.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    current_time = datetime.utcnow()
    
    # Update request
    item_request.status = 'Rejected by Procurement Manager'
    item_request.procurement_manager_rejection_date = current_time.date()
    item_request.procurement_manager_rejector = current_user.name
    item_request.procurement_manager_rejector_user_id = current_user.user_id
    item_request.procurement_manager_rejection_reason = rejection_reason
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Procurement Manager rejected item request #{request_id}")
    
    # Format item names with spaces
    formatted_items = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Notify requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request Rejected by Procurement Manager",
            message=f"Your item request #{request_id} for {formatted_items} has been rejected by Procurement Manager. Reason: {rejection_reason}",
            notification_type="request_rejected",
            item_request_id=request_id
        )
    
    # Notify the manager who originally approved (they should know it was rejected at procurement level)
    if item_request.manager_approver_user_id:
        create_notification(
            user_id=item_request.manager_approver_user_id,
            title="Item Request Rejected by Procurement Manager",
            message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_items} that you approved has been rejected by Procurement Manager. Reason: {rejection_reason}",
            notification_type="request_rejected",
            item_request_id=request_id
        )
    
    flash('Item request rejected.', 'info')
    return redirect(url_for('view_item_request_page', request_id=request_id))


def item_request_procurement_manager_on_hold_handler(request_id, item_request):
    """Handler for procurement manager on hold"""
    on_hold_reason = request.form.get('on_hold_reason', '').strip()
    
    current_time = datetime.utcnow()
    
    # Update request - change status to 'On Hold'
    item_request.status = 'On Hold'
    item_request.procurement_manager_on_hold_date = current_time.date()
    item_request.procurement_manager_on_hold_by = current_user.name
    item_request.procurement_manager_on_hold_by_user_id = current_user.user_id
    item_request.procurement_manager_on_hold_reason = on_hold_reason
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Procurement Manager put item request #{request_id} on hold")
    
    # Format item names with spaces
    formatted_items = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Build message
    message_base = f"Item request #{request_id} for {formatted_items} has been put on hold by Procurement Manager {current_user.name}."
    if on_hold_reason:
        message_base += f" Reason: {on_hold_reason}"
    
    # Notify requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request On Hold",
            message=f"Your {message_base.lower()}",
            notification_type="request_on_hold",
            item_request_id=request_id
        )
    
    # Notify all authorized managers (including temporary managers, Operation Manager, GM)
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    for approver in authorized_approvers:
        if approver.user_id != current_user.user_id:  # Don't notify the person who put it on hold
            create_notification(
                user_id=approver.user_id,
                title="Item Request On Hold",
                message=message_base,
                notification_type="request_on_hold",
                item_request_id=request_id
            )
    
    # Notify IT Department (all IT Staff and IT Department Manager)
    it_users = User.query.filter(
        User.department == 'IT'
    ).filter(
        User.role.in_(['IT Staff', 'Department Manager'])
    ).all()
    
    for it_user in it_users:
        create_notification(
            user_id=it_user.user_id,
            title="Item Request On Hold",
            message=message_base,
            notification_type="request_on_hold",
            item_request_id=request_id
        )
    
    flash('Item request has been put on hold.', 'warning')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/procurement-manager-reject', methods=['POST'])
@login_required
@role_required('Department Manager')
def item_request_procurement_manager_reject(request_id):
    """Procurement Manager rejects an item request"""
    if current_user.department != 'Procurement' or current_user.role != 'Department Manager':
        flash('Access denied. Only Procurement Department Managers can perform this action.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    if item_request.status != 'Pending Procurement Manager Approval':
        flash('This request is not pending procurement manager approval.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    rejection_reason = request.form.get('rejection_reason', '').strip()
    if not rejection_reason:
        flash('Please provide a reason for rejection.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    current_time = datetime.utcnow()
    
    # Update request
    item_request.status = 'Rejected by Procurement Manager'
    item_request.procurement_manager_rejection_date = current_time.date()
    item_request.procurement_manager_rejector = current_user.name
    item_request.procurement_manager_rejector_user_id = current_user.user_id
    item_request.procurement_manager_rejection_reason = rejection_reason
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Procurement Manager rejected item request #{request_id}")
    
    # Format item names with spaces
    formatted_items = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Notify requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request Rejected by Procurement Manager",
            message=f"Your item request #{request_id} for {formatted_items} has been rejected by Procurement Manager. Reason: {rejection_reason}",
            notification_type="request_rejected",
            item_request_id=request_id
        )
    
    # Notify the manager who originally approved (they should know it was rejected at procurement level)
    if item_request.manager_approver_user_id:
        create_notification(
            user_id=item_request.manager_approver_user_id,
            title="Item Request Rejected by Procurement Manager",
            message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_items} that you approved has been rejected by Procurement Manager. Reason: {rejection_reason}",
            notification_type="request_rejected",
            item_request_id=request_id
        )
    
    flash('Item request rejected.', 'info')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/save_uploads', methods=['POST'])
@login_required
def item_request_save_uploads(request_id):
    """Allow assigned procurement staff to save uploads incrementally before completion."""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'

    def error_response(message):
        if is_ajax:
            return jsonify({'success': False, 'message': message}), 400
        flash(message, 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Authorization mirrors completion rules
    if current_user.department != 'Procurement':
        return error_response('Only procurement staff can save uploads for this request.')

    if current_user.role in ['GM', 'Operation Manager']:
        return error_response('You do not have permission to save uploads for this request.')

    if item_request.status != 'Assigned to Procurement':
        return error_response('Uploads can only be saved while the request is assigned to procurement.')

    if not item_request.assigned_to_user_id or item_request.assigned_to_user_id != current_user.user_id:
        return error_response('Only the assigned procurement staff member can save uploads for this request.')

    # Optional fields (validate if provided)
    receipt_amount_value = None
    receipt_amount_str = request.form.get('receipt_amount', '').strip()
    if receipt_amount_str:
        try:
            receipt_amount_value = float(receipt_amount_str)
            if receipt_amount_value <= 0:
                raise ValueError()
        except Exception:
            return error_response('Please enter a valid positive receipt amount in OMR or leave it blank.')

    receipt_reference_number = request.form.get('receipt_reference_number', '').strip()
    if receipt_reference_number and not re.match(r'^[A-Za-z0-9]+$', receipt_reference_number):
        return error_response('Receipt reference number must contain only letters and numbers (no spaces or symbols).')

    completion_notes = request.form.get('completion_notes', '').strip()
    # Checkbox: item from store, no receipt/invoice expected
    from_store_flag = bool(request.form.get('from_store_no_receipt'))
    # Items assigned to this request (for invoice-to-item validation)
    assigned_items = []
    if item_request.item_name:
        assigned_items = [itm.strip() for itm in item_request.item_name.split(',') if itm.strip()]

    # Parse invoice-to-item selections (required when uploading invoice files)
    invoice_item_map_raw = request.form.get('invoice_item_map', '').strip()
    invoice_item_map = {}
    if invoice_item_map_raw:
        try:
            parsed_map = json.loads(invoice_item_map_raw) or {}
            if isinstance(parsed_map, dict):
                invoice_item_map = parsed_map
        except Exception:
            flash('Could not read the invoice-to-item selections. Please try again.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))

    # Items assigned to this request (for invoice-to-item validation)
    assigned_items = []
    if item_request.item_name:
        assigned_items = [itm.strip() for itm in item_request.item_name.split(',') if itm.strip()]

    # Parse invoice-to-item selections (required when uploading invoice files)
    invoice_item_map_raw = request.form.get('invoice_item_map', '').strip()
    invoice_item_map = {}
    if invoice_item_map_raw:
        try:
            parsed_map = json.loads(invoice_item_map_raw) or {}
            if isinstance(parsed_map, dict):
                invoice_item_map = parsed_map
        except Exception:
            flash('Could not read the invoice-to-item selections. Please try again.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))

    # Collect uploaded files
    receipt_files = request.files.getlist('receipt_files')
    invoice_files = request.files.getlist('invoice_files')

    has_new_receipts = receipt_files and any(f.filename for f in receipt_files)
    has_new_invoices = invoice_files and any(f.filename for f in invoice_files)

    # Check if there are any quantities or amounts from the right column
    quantities = request.form.getlist('quantities[]')
    amounts = request.form.getlist('amounts[]')
    has_quantities_or_amounts = any(q.strip() for q in quantities if q.strip() and q.strip() != '0') or any(a.strip() for a in amounts if a.strip() and a.strip() != '0')

    if not has_new_receipts and not has_new_invoices and not any([receipt_amount_str, receipt_reference_number, completion_notes]) and not has_quantities_or_amounts:
        return error_response('Please upload at least one file or enter some data to save.')

    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
    uploaded_receipt_filenames = []
    uploaded_invoice_entries = []

    # Helper to load existing files safely
    def _load_existing(json_field):
        if not json_field:
            return []
        try:
            data = json.loads(json_field)
            if isinstance(data, list):
                return data
            return [json_field]
        except Exception:
            return [json_field]

    def _parse_invoice_entries(raw_value):
        entries = []
        if not raw_value:
            return entries
        try:
            data = json.loads(raw_value)
        except Exception:
            return [{'filename': raw_value, 'items': []}]

        if isinstance(data, list):
            for entry in data:
                if isinstance(entry, dict):
                    fname = entry.get('filename') or entry.get('file') or entry.get('name')
                    items = entry.get('items') or []
                    amount_val = entry.get('amount')
                    if fname:
                        if not isinstance(items, list):
                            items = []
                        clean_items = [itm.strip() for itm in items if isinstance(itm, str) and itm.strip()]
                        entries.append({'filename': fname, 'items': clean_items, 'amount': amount_val})
                elif isinstance(entry, str):
                    entries.append({'filename': entry, 'items': [], 'amount': None})
        elif isinstance(data, dict):
            fname = data.get('filename') or data.get('file') or data.get('name')
            items = data.get('items') or []
            amount_val = data.get('amount')
            if fname:
                if not isinstance(items, list):
                    items = []
                clean_items = [itm.strip() for itm in items if isinstance(itm, str) and itm.strip()]
                entries.append({'filename': fname, 'items': clean_items, 'amount': amount_val})
        else:
            entries.append({'filename': raw_value, 'items': [], 'amount': None})

        return entries

    existing_receipts = _load_existing(item_request.receipt_path)
    existing_invoice_entries = _parse_invoice_entries(item_request.invoice_path)
    had_receipts_before = len(existing_receipts) > 0
    had_invoices_before = len(existing_invoice_entries) > 0
    has_saved_receipt_values = item_request.receipt_amount is not None and bool(item_request.receipt_reference_number)
    has_saved_invoice_amount = item_request.invoice_amount is not None or any(
        isinstance(entry, dict) and entry.get('amount') for entry in existing_invoice_entries
    )

    # Enforce required receipt fields on first receipt upload
    if has_new_receipts and not (had_receipts_before or has_saved_receipt_values):
        if receipt_amount_value is None:
            return error_response('Receipt amount is required when uploading the first receipt.')
        if not receipt_reference_number:
            return error_response('Receipt reference number is required when uploading the first receipt.')

    # Enforce required invoice amount on first invoice upload
    if has_new_invoices and not (had_invoices_before or has_saved_invoice_amount):
        # Require that mapping provides amounts for each invoice instead of a single invoice_amount field
        for inv_file in invoice_files or []:
            if inv_file and inv_file.filename:
                selected_entry = invoice_item_map.get(inv_file.filename) or {}
                amount_raw = selected_entry.get('amount') if isinstance(selected_entry, dict) else None
                try:
                    amount_val = float(amount_raw) if amount_raw not in [None, ''] else None
                except Exception:
                    amount_val = None
                if amount_val is None or amount_val <= 0:
                    return error_response('Invoice amount is required and must be greater than 0 for each uploaded invoice.')

    # Require item selections for any new invoice uploads
    if has_new_invoices and not invoice_item_map:
        return error_response('Please choose which item(s) apply to each invoice file you are uploading.')

    # Process receipt files
    if has_new_receipts:
        for receipt_file in receipt_files:
            if receipt_file and receipt_file.filename:
                file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                if file_extension not in allowed_extensions:
                    flash(f'Invalid file type for receipt "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                    return redirect(url_for('view_item_request_page', request_id=request_id))

                file_size = len(receipt_file.read())
                if file_size > max_file_size:
                    flash(f'Receipt file "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                    return redirect(url_for('view_item_request_page', request_id=request_id))

                receipt_file.seek(0)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
                filename = secure_filename(receipt_file.filename)
                filename = f"item_receipt_{request_id}_{timestamp}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                receipt_file.save(filepath)
                uploaded_receipt_filenames.append(filename)

    # Process invoice files
    if has_new_invoices:
        for invoice_file in invoice_files:
            if invoice_file and invoice_file.filename:
                original_name = invoice_file.filename
                file_extension = original_name.rsplit('.', 1)[1].lower() if '.' in original_name else ''
                if file_extension not in allowed_extensions:
                    flash(f'Invalid file type for invoice "{original_name}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                    return redirect(url_for('view_item_request_page', request_id=request_id))

                file_size = len(invoice_file.read())
                if file_size > max_file_size:
                    flash(f'Invoice file "{original_name}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                    return redirect(url_for('view_item_request_page', request_id=request_id))

                invoice_file.seek(0)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
                filename = secure_filename(original_name)
                filename = f"item_invoice_{request_id}_{timestamp}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                invoice_file.save(filepath)

                selected_entry = invoice_item_map.get(original_name) or invoice_item_map.get(filename) or {}
                selected_items = []
                amount_val = None
                if isinstance(selected_entry, dict):
                    selected_items = selected_entry.get('items') or []
                    try:
                        amount_val_raw = selected_entry.get('amount')
                        if amount_val_raw is not None and amount_val_raw != '':
                            amount_val = float(amount_val_raw)
                    except Exception:
                        pass
                elif isinstance(selected_entry, list):
                    selected_items = selected_entry

                if not isinstance(selected_items, list):
                    selected_items = []
                clean_items = [itm.strip() for itm in selected_items if isinstance(itm, str) and itm.strip()]
                if not clean_items:
                    return error_response(f'Please choose which item(s) apply to invoice "{original_name}".')
                invalid_items = [itm for itm in clean_items if itm not in assigned_items]
                if invalid_items:
                    return error_response(f'Invoice "{original_name}" includes item selections not assigned to this request.')

                if amount_val is None or amount_val <= 0:
                    return error_response(f'Please enter a valid amount greater than 0 for invoice "{original_name}".')

                uploaded_invoice_entries.append({'filename': filename, 'items': clean_items, 'amount': amount_val})

    # Merge new and existing files
    all_receipts = existing_receipts + uploaded_receipt_filenames
    all_invoices = existing_invoice_entries + uploaded_invoice_entries

    # Persist combined invoice total (for legacy views/exports) using per-file amounts when present
    def _invoice_total(entries):
        total = 0.0
        for entry in entries:
            if isinstance(entry, dict):
                try:
                    amt = float(entry.get('amount') or 0)
                    total += amt
                except Exception:
                    continue
        return total if total > 0 else None

    invoice_total = _invoice_total(all_invoices)

    item_request.receipt_path = json.dumps(all_receipts) if all_receipts else None
    item_request.invoice_path = json.dumps(all_invoices) if all_invoices else None

    if receipt_amount_value is not None:
        item_request.receipt_amount = receipt_amount_value
    if invoice_total is not None:
        item_request.invoice_amount = invoice_total
    if receipt_reference_number:
        item_request.receipt_reference_number = receipt_reference_number
    if completion_notes:
        item_request.completion_notes = completion_notes
    # Persist from-store flag
    item_request.from_store_no_receipt = from_store_flag

    # Save quantities and amounts from the right column if provided
    quantities_list = request.form.getlist('quantities[]')
    amounts_list = request.form.getlist('amounts[]')
    
    if quantities_list:
        cleaned_quantities = [q.strip() for q in quantities_list if q.strip()]
        item_request.assigned_procurement_quantities = ';'.join(cleaned_quantities) if cleaned_quantities else None
    
    if amounts_list:
        cleaned_amounts = [a.strip() for a in amounts_list if a.strip()]
        item_request.procurement_amounts = ';'.join(cleaned_amounts) if cleaned_amounts else None
    
    # Save rejection reason if provided
    rejection_reason = request.form.get('quantity_rejection_reason', '').strip()
    if rejection_reason:
        item_request.procurement_quantity_rejection_reason = rejection_reason

    item_request.updated_at = datetime.utcnow()
    db.session.commit()

    # Notify authorized users about saved uploads
    try:
        recipient_ids = set()
        if item_request.user_id:
            recipient_ids.add(item_request.user_id)
        # Authorized approvers (GM, operation manager, manager chain, etc.)
        for user in get_authorized_manager_approvers_for_item_request(item_request):
            recipient_ids.add(user.user_id)
        # Procurement Department Manager(s)
        procurement_mgrs = User.query.filter_by(department='Procurement', role='Department Manager').all()
        for pm in procurement_mgrs:
            recipient_ids.add(pm.user_id)
        # All procurement staff
        procurement_staff = User.query.filter_by(department='Procurement').all()
        for staff in procurement_staff:
            recipient_ids.add(staff.user_id)

        title = f"Changes saved for Item Request #{request_id}"
        who = current_user.name or 'assigned procurement staff'
        message = f"{who} saved changes for Item Request #{request_id}."
        for uid in recipient_ids:
            create_notification(uid, title, message, 'item_request_updated', item_request_id=request_id)
    except Exception as e:
        app.logger.warning(f"Failed to send upload notifications for item request #{request_id}: {e}")

    log_action(f"Procurement member saved uploads for item request #{request_id}")

    # Return JSON for AJAX saves, otherwise redirect with flash
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return jsonify({
            'success': True,
            'message': 'Changes saved successfully.',
            'receipt_files': all_receipts,
            'invoice_files': [
                entry.get('filename') if isinstance(entry, dict) else entry
                for entry in all_invoices
                if (isinstance(entry, dict) and entry.get('filename')) or isinstance(entry, str)
            ]
        })

    flash('Changes saved successfully. You can make more changes before marking this request as completed.', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/complete', methods=['POST'])
@login_required
def item_request_complete(request_id):
    """Procurement member completes an item request"""
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Check if current user is from Procurement department
    if current_user.department != 'Procurement':
        flash('Only procurement staff can complete this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # GM and Operation Manager cannot complete
    if current_user.role in ['GM', 'Operation Manager']:
        flash('You do not have permission to complete this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    if item_request.status != 'Assigned to Procurement':
        flash('This request is not assigned to procurement.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Check if the current user is the assigned user
    if not item_request.assigned_to_user_id or item_request.assigned_to_user_id != current_user.user_id:
        flash('Only the assigned procurement staff member can complete this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    completion_notes = request.form.get('completion_notes', '').strip()
    # Checkbox: item from store, no receipt/invoice expected
    from_store_flag = bool(request.form.get('from_store_no_receipt'))
    # Items assigned to this request (for invoice-to-item validation)
    assigned_items = []
    if item_request.item_name:
        assigned_items = [itm.strip() for itm in item_request.item_name.split(',') if itm.strip()]

    # Parse invoice-to-item selections (required when uploading invoice files)
    invoice_item_map_raw = request.form.get('invoice_item_map', '').strip()
    invoice_item_map = {}
    if invoice_item_map_raw:
        try:
            parsed_map = json.loads(invoice_item_map_raw) or {}
            if isinstance(parsed_map, dict):
                invoice_item_map = parsed_map
        except Exception:
            flash('Could not read the invoice-to-item selections. Please try again.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Receipt Amount and reference (required unless item is from store)
    receipt_amount_str = request.form.get('receipt_amount', '').strip()
    receipt_reference_number = request.form.get('receipt_reference_number', '').strip()
    if not from_store_flag:
        if not receipt_amount_str:
            flash('Receipt amount is required.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
        try:
            receipt_amount_value = float(receipt_amount_str)
            if receipt_amount_value <= 0:
                raise ValueError()
        except Exception:
            flash('Please enter a valid positive receipt amount in OMR.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
        if not receipt_reference_number:
            flash('Receipt reference number is required.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
        if not re.match(r'^[A-Za-z0-9]+$', receipt_reference_number):
            flash('Receipt reference number must contain only letters and numbers (no spaces or symbols).', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Handle receipt file upload (allow reuse of existing saved receipts)
    existing_receipt_files = []
    try:
        if item_request.receipt_path:
            existing_receipt_files = json.loads(item_request.receipt_path) or []
    except Exception:
        existing_receipt_files = []

    receipt_files = request.files.getlist('receipt_files')
    has_new_receipts = receipt_files and any(f.filename for f in receipt_files)
    if not from_store_flag:
        if not has_new_receipts and not existing_receipt_files:
            flash('Upload Receipt file is required.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # Handle invoice file upload (allow reuse of existing saved invoices)
    def _parse_invoice_entries(raw_value):
        entries = []
        if not raw_value:
            return entries
        try:
            data = json.loads(raw_value)
        except Exception:
            return [{'filename': raw_value, 'items': [], 'amount': None}]

        if isinstance(data, list):
            for entry in data:
                if isinstance(entry, dict):
                    fname = entry.get('filename') or entry.get('file') or entry.get('name')
                    items = entry.get('items') or []
                    amount_val = entry.get('amount')
                    if fname:
                        if not isinstance(items, list):
                            items = []
                        clean_items = [itm.strip() for itm in items if isinstance(itm, str) and itm.strip()]
                        entries.append({'filename': fname, 'items': clean_items, 'amount': amount_val})
                elif isinstance(entry, str):
                    entries.append({'filename': entry, 'items': [], 'amount': None})
        elif isinstance(data, dict):
            fname = data.get('filename') or data.get('file') or data.get('name')
            items = data.get('items') or []
            amount_val = data.get('amount')
            if fname:
                if not isinstance(items, list):
                    items = []
                clean_items = [itm.strip() for itm in items if isinstance(itm, str) and itm.strip()]
                entries.append({'filename': fname, 'items': clean_items, 'amount': amount_val})
        else:
            entries.append({'filename': raw_value, 'items': [], 'amount': None})

        return entries

    existing_invoice_entries = _parse_invoice_entries(item_request.invoice_path)

    invoice_files = request.files.getlist('invoice_files')
    has_new_invoices = invoice_files and any(f.filename for f in invoice_files)
    if not from_store_flag:
        if not has_new_invoices and not existing_invoice_entries:
            flash('Upload Invoice file is required.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
        if has_new_invoices and not invoice_item_map:
            flash('Please choose which item(s) apply to each invoice file you are uploading.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    if not from_store_flag:
        if not has_new_invoices and not existing_invoice_entries:
            flash('Upload Invoice file is required.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
        if has_new_invoices and not invoice_item_map:
            flash('Please choose which item(s) apply to each invoice file you are uploading.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id))
    
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
    uploaded_receipt_filenames = []
    uploaded_invoice_entries = []
    
    # Process receipt files
    for receipt_file in receipt_files or []:
        if receipt_file and receipt_file.filename:
            file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
            if file_extension not in allowed_extensions:
                flash(f'Invalid file type for receipt "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))
            
            file_size = len(receipt_file.read())
            if file_size > max_file_size:
                flash(f'Receipt file "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))
            
            receipt_file.seek(0)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = secure_filename(receipt_file.filename)
            filename = f"item_receipt_{request_id}_{timestamp}_{filename}"
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            receipt_file.save(filepath)
            uploaded_receipt_filenames.append(filename)
    
    # Process invoice files
    for invoice_file in invoice_files or []:
        if invoice_file and invoice_file.filename:
            original_name = invoice_file.filename
            file_extension = original_name.rsplit('.', 1)[1].lower() if '.' in original_name else ''
            if file_extension not in allowed_extensions:
                flash(f'Invalid file type for invoice "{original_name}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))
            
            file_size = len(invoice_file.read())
            if file_size > max_file_size:
                flash(f'Invoice file "{original_name}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))
            
            invoice_file.seek(0)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = secure_filename(original_name)
            filename = f"item_invoice_{request_id}_{timestamp}_{filename}"
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            invoice_file.save(filepath)

            selected_entry = invoice_item_map.get(original_name) or invoice_item_map.get(filename) or {}
            selected_items = []
            amount_val = None
            if isinstance(selected_entry, dict):
                selected_items = selected_entry.get('items') or []
                try:
                    amount_raw = selected_entry.get('amount')
                    if amount_raw is not None and amount_raw != '':
                        amount_val = float(amount_raw)
                except Exception:
                    pass
            elif isinstance(selected_entry, list):
                selected_items = selected_entry

            if not isinstance(selected_items, list):
                selected_items = []
            clean_items = [itm.strip() for itm in selected_items if isinstance(itm, str) and itm.strip()]
            if not clean_items:
                flash(f'Please choose which item(s) apply to invoice "{original_name}".', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))
            invalid_items = [itm for itm in clean_items if itm not in assigned_items]
            if invalid_items:
                flash(f'Invoice "{original_name}" includes item selections not assigned to this request.', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))

            if amount_val is None or amount_val <= 0:
                flash(f'Please enter a valid amount greater than 0 for invoice "{original_name}".', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))

            uploaded_invoice_entries.append({'filename': filename, 'items': clean_items, 'amount': amount_val})
    
    current_time = datetime.utcnow()
    
    # Update request (reuse existing files if none uploaded)
    final_receipts = uploaded_receipt_filenames if uploaded_receipt_filenames else existing_receipt_files
    final_invoices = uploaded_invoice_entries if uploaded_invoice_entries else existing_invoice_entries

    # Ensure all invoice entries carry a valid amount
    for entry in final_invoices:
        if isinstance(entry, dict):
            try:
                amt = float(entry.get('amount') or 0)
            except Exception:
                amt = 0
            if amt <= 0:
                flash('Please ensure every invoice has a positive amount.', 'danger')
                return redirect(url_for('view_item_request_page', request_id=request_id))

    # Sum invoice amounts from entries for storage/exports
    def _invoice_total(entries):
        total = 0.0
        for entry in entries:
            if isinstance(entry, dict):
                try:
                    total += float(entry.get('amount') or 0)
                except Exception:
                    continue
        return total if total > 0 else None

    invoice_total = _invoice_total(final_invoices)

    item_request.status = 'Final Approval'
    # Only set receipt amount/reference when not marked as from-store (no receipt expected)
    if not from_store_flag:
        item_request.receipt_amount = receipt_amount_value
        item_request.receipt_reference_number = receipt_reference_number
    else:
        # Clear receipt fields when item is from store
        item_request.receipt_amount = None
        item_request.receipt_reference_number = None
    if invoice_total is not None:
        item_request.invoice_amount = invoice_total
    item_request.receipt_path = json.dumps(final_receipts)
    item_request.invoice_path = json.dumps(final_invoices)
    item_request.updated_at = current_time
    
    db.session.commit()
    
    log_action(f"Procurement member submitted item request #{request_id} for final approval")
    
    # Format item names with comma and space separation
    formatted_item_names = ', '.join([item.strip() for item in item_request.item_name.split(',') if item.strip()]) if item_request.item_name else 'Item'
    
    # Notify original requestor
    if item_request.user_id:
        create_notification(
            user_id=item_request.user_id,
            title="Item Request Submitted for Final Approval",
            message=f"Your item request #{request_id} for {formatted_item_names} has been submitted for final approval by the procurement team.",
            notification_type="request_pending_approval",
            item_request_id=request_id
        )
    
    # Notify the manager who originally approved the request
    if item_request.manager_approver_user_id:
        create_notification(
            user_id=item_request.manager_approver_user_id,
            title="Item Request Awaiting Final Approval",
            message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} that you approved has been submitted for final approval.",
            notification_type="request_pending_approval",
            item_request_id=request_id
        )
    
    # Notify Procurement Manager for final approval
    if item_request.procurement_manager_approver_user_id:
        create_notification(
            user_id=item_request.procurement_manager_approver_user_id,
            title="Item Request Awaiting Final Approval",
            message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} is ready for your final approval.",
            notification_type="request_pending_approval",
            item_request_id=request_id
        )
    
    # Notify all authorized manager approvers for this request
    authorized_managers = get_authorized_manager_approvers_for_item_request(item_request)
    for manager in authorized_managers:
        # Avoid duplicate notifications to already notified users
        if manager.user_id != item_request.manager_approver_user_id:
            create_notification(
                user_id=manager.user_id,
                title="Item Request Awaiting Final Approval",
                message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {formatted_item_names} is awaiting final approval.",
                notification_type="request_pending_approval",
                item_request_id=request_id
            )
    
    flash('Item request submitted for final approval!', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/update_quantities_procurement_manager', methods=['POST'])
@login_required
def update_item_request_quantities_procurement_manager(request_id):
    """Allow Procurement Department Manager to adjust per-item quantities during Procurement Manager Approval.

    This uses the same procurement_quantities field so that Procurement staff
    see the procurement manager-approved quantities, while the original requested quantity
    remains unchanged in the quantity column.
    """
    item_request = ProcurementItemRequest.query.get_or_404(request_id)

    # Only allow updates while request is awaiting (or on) Procurement Manager Approval
    if item_request.status not in ['Pending Procurement Manager Approval', 'On Hold']:
        flash('Quantities can only be updated while the request is pending procurement manager approval or on hold by procurement manager.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Authorization: Only Procurement Department Manager
    if current_user.department != 'Procurement' or current_user.role != 'Department Manager':
        flash('You do not have permission to update quantities for this request at the procurement manager stage.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Check if it's on hold by procurement manager (not manager)
    if item_request.status == 'On Hold' and not item_request.procurement_manager_on_hold_by_user_id:
        flash('Quantities can only be updated while the request is pending procurement manager approval or on hold by procurement manager.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Parse the posted quantities list
    raw_quantities = request.form.getlist('quantities[]')
    cleaned_quantities = [q.strip() for q in raw_quantities]

    # Ensure alignment with existing item list
    item_names = [name.strip() for name in (item_request.item_name or '').split(',') if name.strip()]
    if not item_names:
        flash('No item names found for this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Normalise quantity list length to match items
    if len(cleaned_quantities) < len(item_names):
        cleaned_quantities += [''] * (len(item_names) - len(cleaned_quantities))
    elif len(cleaned_quantities) > len(item_names):
        cleaned_quantities = cleaned_quantities[:len(item_names)]

    # Get old quantities for edit history tracking (use procurement_manager_quantities if exists, otherwise procurement_quantities)
    old_quantities = item_request.procurement_manager_quantities or item_request.procurement_quantities or item_request.quantity or ''
    old_quantities_str = old_quantities if old_quantities else ''
    new_quantities_str = ';'.join(cleaned_quantities)

    # Helper to parse quantity string to int
    def _qty_to_int(val: str) -> int:
        try:
            # support "Item: 0" style values
            parts = (val or '').split(':', 1)
            num_str = parts[1].strip() if len(parts) > 1 else (parts[0].strip() if parts else '0')
            return int(num_str or 0)
        except Exception:
            return 0

    # Manager-approved quantities (baseline)
    mgr_quantities_str = item_request.procurement_quantities or item_request.quantity or ''
    mgr_list = mgr_quantities_str.split(';') if mgr_quantities_str else []
    new_list = new_quantities_str.split(';') if new_quantities_str else []

    # Indices with quantity 0 before (manager) and after (procurement manager)
    zeros_old = {i for i, q in enumerate(mgr_list) if _qty_to_int(q) == 0}
    zeros_new = {i for i, q in enumerate(new_list) if _qty_to_int(q) == 0}

    # Decide rejection reason
    quantity_rejection_reason = request.form.get('quantity_rejection_reason', '').strip()
    new_zero_not_prev = zeros_new - zeros_old

    if zeros_new:
        # If procurement manager zeroed a NEW item, reason is required
        if new_zero_not_prev and not quantity_rejection_reason:
            flash('Please provide a reason for items you set to quantity 0.', 'danger')
            return redirect(url_for('view_item_request_page', request_id=request_id, tab='procurement'))
        # If only previously-zero items remain zero and no new reason given, inherit manager reason
        if not new_zero_not_prev and not quantity_rejection_reason:
            quantity_rejection_reason = item_request.manager_quantity_rejection_reason or ''

    # Store procurement manager-approved quantities in separate field (does not affect manager-approved quantities)
    item_request.procurement_manager_quantities = new_quantities_str
    item_request.procurement_manager_quantity_rejection_reason = quantity_rejection_reason if quantity_rejection_reason else None
    item_request.updated_at = datetime.utcnow()

    # Track quantity edits in edit history table (similar to payment requests)
    try:
        # Create table if it doesn't exist
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS item_request_quantity_edit_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_request_id INTEGER NOT NULL,
                old_value TEXT,
                new_value TEXT,
                edited_by_user_id INTEGER,
                edited_by_name TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        '''))
        
        # Create table to track which item requests have edited quantities
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS item_request_quantity_edits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_request_id INTEGER NOT NULL,
                first_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(item_request_id)
            );
        '''))
        
        # Only log if quantities actually changed
        if old_quantities_str != new_quantities_str:
            # Insert edit log entry
            db.session.execute(db.text('''
                INSERT INTO item_request_quantity_edit_logs (item_request_id, old_value, new_value, edited_by_user_id, edited_by_name)
                VALUES (:rid, :oldv, :newv, :uid, :uname)
            '''), {
                'rid': request_id,
                'oldv': old_quantities_str,
                'newv': new_quantities_str,
                'uid': current_user.user_id,
                'uname': current_user.name
            })
            
            # Mark that this item request has edited quantities
            db.session.execute(db.text('''
                INSERT INTO item_request_quantity_edits (item_request_id) VALUES (:rid)
                ON CONFLICT(item_request_id) DO UPDATE SET last_edited_at = CURRENT_TIMESTAMP
            '''), {'rid': request_id})
            
            # Notify requestor and other authorized managers that quantities have been edited (outside try block to ensure it always runs)
            if old_quantities_str != new_quantities_str:
                # Parse quantities to show what changed
                item_names_list = [name.strip() for name in (item_request.item_name or '').split(',') if name.strip()]
                
                # Parse quantities - could be JSON array or semicolon-separated
                old_list = []
                new_list = []
                
                if old_quantities_str:
                    if old_quantities_str.strip().startswith('['):
                        try:
                            old_list = json.loads(old_quantities_str)
                        except:
                            old_list = old_quantities_str.split(';') if ';' in old_quantities_str else [old_quantities_str]
                    else:
                        old_list = old_quantities_str.split(';') if old_quantities_str else []
                
                if new_quantities_str:
                    if new_quantities_str.strip().startswith('['):
                        try:
                            new_list = json.loads(new_quantities_str)
                        except:
                            new_list = new_quantities_str.split(';') if ';' in new_quantities_str else [new_quantities_str]
                    else:
                        new_list = new_quantities_str.split(';') if new_quantities_str else []
                
                # Build recipient list for notifications
                recipient_ids = set()
                
                # Original requestor
                if item_request.user_id:
                    recipient_ids.add(item_request.user_id)
                
                # Authorized approvers
                authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
                for approver in authorized_approvers:
                    if approver.user_id != current_user.user_id:
                        recipient_ids.add(approver.user_id)
                
                # Requestor's direct manager
                requestor = User.query.get(item_request.user_id) if item_request.user_id else None
                if requestor and requestor.manager_id:
                    recipient_ids.add(requestor.manager_id)
                
                # Department Manager of requestor's department
                if requestor and requestor.department:
                    dept_managers = User.query.filter_by(role='Department Manager', department=requestor.department).all()
                    for dept_manager in dept_managers:
                        if dept_manager.user_id != current_user.user_id:
                            recipient_ids.add(dept_manager.user_id)
                
                # Operation Manager if Operation or Project department
                if requestor and (requestor.department == 'Operation' or requestor.department == 'Project'):
                    op_managers = User.query.filter_by(role='Operation Manager').all()
                    for op_manager in op_managers:
                        if op_manager.user_id != current_user.user_id:
                            recipient_ids.add(op_manager.user_id)
                
                # General Managers
                gm_users = User.query.filter_by(role='GM').all()
                for gm_user in gm_users:
                    if gm_user.user_id != current_user.user_id:
                        recipient_ids.add(gm_user.user_id)
                
                # IT Department
                it_users = User.query.filter(
                    User.department == 'IT'
                ).filter(
                    User.role.in_(['IT Staff', 'Department Manager'])
                ).all()
                for it_user in it_users:
                    if it_user.user_id != current_user.user_id:
                        recipient_ids.add(it_user.user_id)
                
                # Send notifications to all recipients
                title = f"Changes saved for Item Request #{request_id}"
                message = f"Item request #{request_id} quantities have been updated by {current_user.name}."
                for uid in recipient_ids:
                    create_notification(uid, title, message, 'item_request_updated', item_request_id=request_id)
    except Exception as e:
        app.logger.warning(f"Failed to persist quantity edit history: {e}")

    db.session.commit()
    
    flash('Quantities updated successfully!', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/update_quantities', methods=['POST'])
@login_required
def update_item_request_quantities(request_id):
    """Update per-item quantities for multi-item requests (assigned procurement staff only).

    NOTE: This should NOT modify the original quantity entered by the requestor.
    Values are stored in ProcurementItemRequest.procurement_quantities instead.
    """
    item_request = ProcurementItemRequest.query.get_or_404(request_id)

    # Only allow updates while request is assigned to procurement
    if item_request.status != 'Assigned to Procurement':
        flash('Quantities can only be updated when the request is assigned to procurement.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Must be Procurement department and not GM / Operation Manager
    if current_user.department != 'Procurement' or current_user.role in ['GM', 'Operation Manager']:
        flash('You do not have permission to update quantities for this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Only the assigned procurement staff member can edit
    if not item_request.assigned_to_user_id or item_request.assigned_to_user_id != current_user.user_id:
        flash('Only the assigned procurement staff member can update quantities for this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Parse the posted quantities list
    raw_quantities = request.form.getlist('quantities[]')
    cleaned_quantities = [q.strip() for q in raw_quantities]

    # Ensure alignment with existing item list
    item_names = [name.strip() for name in (item_request.item_name or '').split(',') if name.strip()]
    if not item_names:
        flash('No item names found for this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Normalise quantity list length to match items
    if len(cleaned_quantities) < len(item_names):
        cleaned_quantities += [''] * (len(item_names) - len(cleaned_quantities))
    elif len(cleaned_quantities) > len(item_names):
        cleaned_quantities = cleaned_quantities[:len(item_names)]

    # Parse and align per-item amounts (new field)
    raw_amounts = request.form.getlist('amounts[]')
    cleaned_amounts = []
    for a in raw_amounts:
        try:
            amt = round(float(a.strip()), 3) if a.strip() else 0.0
        except Exception:
            amt = 0.0
        cleaned_amounts.append(f"{amt:.3f}")

    if len(cleaned_amounts) < len(item_names):
        cleaned_amounts += ['0.000'] * (len(item_names) - len(cleaned_amounts))
    elif len(cleaned_amounts) > len(item_names):
        cleaned_amounts = cleaned_amounts[:len(item_names)]

    # Determine if any quantity is set to 0 (for rejection reason requirement)
    def _parse_qty_to_int(val: str) -> int:
        try:
            return int(val)
        except Exception:
            return 0

    has_zero_quantity = False
    for q in cleaned_quantities:
        parts = (q or '').split(':', 1)
        numeric_part = parts[1].strip() if len(parts) > 1 else (parts[0].strip() if parts else '0')
        if _parse_qty_to_int(numeric_part or '0') == 0:
            has_zero_quantity = True
            break
    quantity_rejection_reason = request.form.get('quantity_rejection_reason', '').strip()
    if has_zero_quantity and not quantity_rejection_reason:
        flash('Please provide a reason for items set to quantity 0.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Join using ";" separator (same convention used when displaying multiple quantities)
    # Store in dedicated field so manager quantities (procurement_quantities) and procurement manager quantities (procurement_manager_quantities) remain unchanged
    item_request.assigned_procurement_quantities = ';'.join(cleaned_quantities)
    item_request.procurement_amounts = ';'.join(cleaned_amounts)
    item_request.procurement_quantity_rejection_reason = quantity_rejection_reason if quantity_rejection_reason else None
    item_request.updated_at = datetime.utcnow()

    db.session.commit()

    # Notify requestor and authorized managers about changes
    try:
        recipient_ids = set()
        # Original requestor
        if item_request.user_id:
            recipient_ids.add(item_request.user_id)
        # Authorized approvers
        for user in get_authorized_manager_approvers_for_item_request(item_request):
            recipient_ids.add(user.user_id)
        
        title = f"Changes saved for Item Request #{request_id}"
        who = current_user.name or 'assigned procurement staff'
        message = f"{who} saved changes for Item Request #{request_id}."
        for uid in recipient_ids:
            create_notification(uid, title, message, 'item_request_updated', item_request_id=request_id)
    except Exception as e:
        app.logger.warning(f"Failed to send notifications for item request #{request_id}: {e}")

    log_action(f"Updated item quantities for procurement item request #{request_id}")
    flash('Item quantities updated successfully.', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id))


@app.route('/procurement/item-request/<int:request_id>/update_quantities_manager', methods=['POST'])
@login_required
def update_item_request_quantities_manager(request_id):
    """Allow authorized managers to adjust per-item quantities during Manager Approval.

    This uses the same procurement_quantities field so that Procurement staff
    see the manager-approved quantities, while the original requested quantity
    remains unchanged in the quantity column.
    """
    item_request = ProcurementItemRequest.query.get_or_404(request_id)

    # Only allow updates while request is awaiting (or on) Manager Approval
    if item_request.status not in ['Pending Manager Approval', 'On Hold']:
        flash('Quantities can only be updated while the request is pending manager approval or on hold by manager.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Authorization: same approvers as Manager Approval
    approvers = get_authorized_manager_approvers_for_item_request(item_request)
    if current_user not in approvers:
        flash('You do not have permission to update quantities for this request at the manager stage.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Parse the posted quantities list
    raw_quantities = request.form.getlist('quantities[]')
    cleaned_quantities = [q.strip() for q in raw_quantities]

    # Ensure alignment with existing item list
    item_names = [name.strip() for name in (item_request.item_name or '').split(',') if name.strip()]
    if not item_names:
        flash('No item names found for this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))

    # Normalise quantity list length to match items
    if len(cleaned_quantities) < len(item_names):
        cleaned_quantities += [''] * (len(item_names) - len(cleaned_quantities))
    elif len(cleaned_quantities) > len(item_names):
        cleaned_quantities = cleaned_quantities[:len(item_names)]

    # Get old quantities for edit history tracking
    old_quantities = item_request.procurement_quantities or item_request.quantity or ''
    old_quantities_str = old_quantities if old_quantities else ''
    new_quantities_str = ';'.join(cleaned_quantities)

    # Store manager-approved quantities in the same field used by Procurement
    item_request.procurement_quantities = new_quantities_str
    # Store rejection reason if provided
    quantity_rejection_reason = request.form.get('quantity_rejection_reason', '').strip()
    item_request.manager_quantity_rejection_reason = quantity_rejection_reason if quantity_rejection_reason else None
    item_request.updated_at = datetime.utcnow()

    # Track quantity edits in edit history table (similar to payment requests)
    try:
        # Create table if it doesn't exist
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS item_request_quantity_edit_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_request_id INTEGER NOT NULL,
                old_value TEXT,
                new_value TEXT,
                edited_by_user_id INTEGER,
                edited_by_name TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        '''))
        
        # Create table to track which item requests have edited quantities
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS item_request_quantity_edits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                item_request_id INTEGER NOT NULL,
                first_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(item_request_id)
            );
        '''))
        
        # Only log if quantities actually changed
        if old_quantities_str != new_quantities_str:
            # Insert edit log entry
            db.session.execute(db.text('''
                INSERT INTO item_request_quantity_edit_logs (item_request_id, old_value, new_value, edited_by_user_id, edited_by_name)
                VALUES (:rid, :oldv, :newv, :uid, :uname)
            '''), {
                'rid': request_id,
                'oldv': old_quantities_str,
                'newv': new_quantities_str,
                'uid': current_user.user_id,
                'uname': current_user.name
            })
            
            # Mark that this item request has edited quantities
            db.session.execute(db.text('''
                INSERT INTO item_request_quantity_edits (item_request_id) VALUES (:rid)
                ON CONFLICT(item_request_id) DO UPDATE SET last_edited_at = CURRENT_TIMESTAMP
            '''), {'rid': request_id})
    except Exception as e:
        app.logger.warning(f"Failed to persist quantity edit history: {e}")

    db.session.commit()

    # Notify requestor and other authorized managers that quantities have been edited (outside try block to ensure it always runs)
    if old_quantities_str != new_quantities_str:
        try:
            # Build a message showing what changed
            item_names_list = [name.strip() for name in (item_request.item_name or '').split(',') if name.strip()]
            
            # Parse quantities - could be JSON array or semicolon-separated
            old_list = []
            new_list = []
            
            if old_quantities_str:
                if old_quantities_str.strip().startswith('['):
                    try:
                        old_list = json.loads(old_quantities_str)
                    except:
                        old_list = old_quantities_str.split(';') if ';' in old_quantities_str else [old_quantities_str]
                else:
                    old_list = old_quantities_str.split(';') if old_quantities_str else []
            
            if new_quantities_str:
                if new_quantities_str.strip().startswith('['):
                    try:
                        new_list = json.loads(new_quantities_str)
                    except:
                        new_list = new_quantities_str.split(';') if ';' in new_quantities_str else [new_quantities_str]
                else:
                    new_list = new_quantities_str.split(';') if new_quantities_str else []
            
            # Find which items changed
            changed_items = []
            for i, item_name in enumerate(item_names_list):
                # Convert to string in case they're from JSON (could be int or str)
                old_qty = str(old_list[i]).strip() if i < len(old_list) else ''
                new_qty = str(new_list[i]).strip() if i < len(new_list) else ''
                if old_qty != new_qty:
                    old_display = old_qty if old_qty else 'Not specified'
                    new_display = new_qty if new_qty else 'Not specified'
                    changed_items.append(f"{item_name}: {old_display} ‚Üí {new_display}")
            
            # Build recipient list for notifications
            recipient_ids = set()
            
            # Original requestor
            if item_request.user_id:
                recipient_ids.add(item_request.user_id)
            
            # Authorized approvers
            authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)

            # Ensure department-level temporary manager (if any) is included even if department casing differs
            try:
                req_dept = (item_request.department or '').strip()
                if req_dept:
                    dept_temp = None
                    for dt in DepartmentTemporaryManager.query.filter(
                        db.or_(
                            DepartmentTemporaryManager.request_type == 'Procurement Item Request',
                            DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                        )
                    ).all():
                        if (dt.department or '').strip().lower() == req_dept.lower():
                            dept_temp = dt
                            break
                    if dept_temp:
                        temp_user = User.query.get(dept_temp.temporary_manager_id)
                        if temp_user and temp_user not in authorized_approvers:
                            authorized_approvers.append(temp_user)
                            print(f"DEBUG: Added department-level temporary manager for item_request dept '{req_dept}' to authorized_approvers: {temp_user.name} (ID: {temp_user.user_id})")
            except Exception:
                pass
            for approver in authorized_approvers:
                if approver.user_id != current_user.user_id:
                    recipient_ids.add(approver.user_id)
            
            # Requestor's direct manager
            requestor = User.query.get(item_request.user_id) if item_request.user_id else None
            if requestor and requestor.manager_id:
                recipient_ids.add(requestor.manager_id)
            
            # Department Manager of requestor's department
            if requestor and requestor.department:
                dept_managers = User.query.filter_by(role='Department Manager', department=requestor.department).all()
                for dept_manager in dept_managers:
                    if dept_manager.user_id != current_user.user_id:
                        recipient_ids.add(dept_manager.user_id)
            
            # Operation Manager if Operation or Project department
            if requestor and (requestor.department == 'Operation' or requestor.department == 'Project'):
                op_managers = User.query.filter_by(role='Operation Manager').all()
                for op_manager in op_managers:
                    if op_manager.user_id != current_user.user_id:
                        recipient_ids.add(op_manager.user_id)
            
            # General Managers
            gm_users = User.query.filter_by(role='GM').all()
            for gm_user in gm_users:
                if gm_user.user_id != current_user.user_id:
                    recipient_ids.add(gm_user.user_id)
            
            # IT Department
            it_users = User.query.filter(
                User.department == 'IT'
            ).filter(
                User.role.in_(['IT Staff', 'Department Manager'])
            ).all()
            for it_user in it_users:
                if it_user.user_id != current_user.user_id:
                    recipient_ids.add(it_user.user_id)
            
            # Send notifications to all recipients
            title = f"Changes saved for Item Request #{request_id}"
            message = f"Item request #{request_id} quantities have been updated by {current_user.name}."
            for uid in recipient_ids:
                create_notification(uid, title, message, 'item_request_updated', item_request_id=request_id)
        except Exception as e:
            app.logger.error(f"Failed to create notification for item request quantity update: {e}")

    log_action(f"Manager-stage quantities updated for item request #{request_id}")
    flash('Item quantities updated successfully for manager approval.', 'success')
    return redirect(url_for('view_item_request_page', request_id=request_id, tab='manager'))


@app.route('/procurement/item-requests/bulk-assign', methods=['POST'])
@login_required
def bulk_assign_item_requests():
    """Bulk assign item requests to the current user"""
    if current_user.department != 'Procurement':
        flash('Only procurement staff can perform this action.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    request_ids = request.form.getlist('request_ids')
    if not request_ids:
        flash('Please select at least one request.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    try:
        request_ids = [int(rid) for rid in request_ids]
    except ValueError:
        flash('Invalid request IDs.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    current_time = datetime.utcnow()
    assigned_count = 0
    skipped_count = 0
    
    for request_id in request_ids:
        item_request = ProcurementItemRequest.query.get(request_id)
        if not item_request:
            skipped_count += 1
            continue
        
        # Only assign if status is "Assigned to Procurement" and not already assigned to someone else
        if item_request.status == 'Assigned to Procurement' and not item_request.assigned_to_user_id:
            item_request.assigned_to_user_id = current_user.user_id
            item_request.assigned_by_user_id = current_user.user_id
            item_request.assignment_date = current_time
            item_request.updated_at = current_time
            
            assigned_count += 1
            
            # Get authorized persons for notifications - use a set to avoid duplicates
            authorized_user_ids = set()
            
            # Add requestor
            if item_request.user_id:
                authorized_user_ids.add(item_request.user_id)
            
            # Add manager approver
            if item_request.manager_approver_user_id:
                authorized_user_ids.add(item_request.manager_approver_user_id)
            
            # Add procurement manager approver
            if item_request.procurement_manager_approver_user_id:
                authorized_user_ids.add(item_request.procurement_manager_approver_user_id)
            
            # Add all procurement staff (they should know about assignments)
            procurement_staff = User.query.filter_by(department='Procurement').all()
            for staff in procurement_staff:
                authorized_user_ids.add(staff.user_id)
            
            # Get all authorized approvers for this item request (includes GM, Operation Manager, etc.)
            authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
            for approver in authorized_approvers:
                authorized_user_ids.add(approver.user_id)
            
            # ALWAYS add General Manager (GM) - regardless of requestor
            gm_users = User.query.filter_by(role='GM').all()
            for gm_user in gm_users:
                authorized_user_ids.add(gm_user.user_id)
            
            # ALWAYS add Operation Manager - regardless of requestor
            op_manager_users = User.query.filter_by(role='Operation Manager').all()
            for op_manager in op_manager_users:
                authorized_user_ids.add(op_manager.user_id)
            
            # Send notifications to all authorized users with the same notification
            notification_message = f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {item_request.item_name} has been assigned to {current_user.name} by {current_user.name}."
            for user_id in authorized_user_ids:
                create_notification(
                    user_id=user_id,
                    title="Item Request Assigned",
                    message=notification_message,
                    notification_type="item_request_assigned",
                    item_request_id=request_id
                )
            
            # Explicitly notify the manager who originally approved (they should know it was assigned)
            if item_request.manager_approver_user_id:
                create_notification(
                    user_id=item_request.manager_approver_user_id,
                    title="Item Request Assigned",
                    message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) that you approved has been assigned to {current_user.name} for processing.",
                    notification_type="item_request_assigned",
                    item_request_id=request_id
                )
            
            log_action(f"Bulk assigned item request #{request_id} to {current_user.name}")
        else:
            skipped_count += 1
    
    db.session.commit()
    
    if assigned_count > 0:
        flash(f'Successfully assigned {assigned_count} request(s) to {current_user.name}.', 'success')
    if skipped_count > 0:
        flash(f'Skipped {skipped_count} request(s) that are not in "Assigned to Procurement" status or are already assigned to someone else.', 'info')
    
    return redirect(url_for('procurement_item_requests'))


@app.route('/procurement/item-request/<int:request_id>/assign-to-self', methods=['POST'])
@login_required
def assign_item_request_to_self(request_id):
    """Assign a single item request to the current user"""
    if current_user.department != 'Procurement':
        flash('Only procurement staff can perform this action.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    # GM and Operation Manager cannot assign
    if current_user.role in ['GM', 'Operation Manager']:
        flash('You do not have permission to assign this request.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    item_request = ProcurementItemRequest.query.get_or_404(request_id)
    
    # Only assign if status is "Assigned to Procurement" and not already assigned to someone else
    if item_request.status != 'Assigned to Procurement':
        flash('This request is not in "Assigned to Procurement" status.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    if item_request.assigned_to_user_id:
        flash('This request is already assigned to someone else.', 'danger')
        return redirect(url_for('view_item_request_page', request_id=request_id))
    
    current_time = datetime.utcnow()
    
    item_request.assigned_to_user_id = current_user.user_id
    item_request.assigned_by_user_id = current_user.user_id
    item_request.assignment_date = current_time
    item_request.updated_at = current_time
    
    # Get authorized persons for notifications - use a set to avoid duplicates
    authorized_user_ids = set()
    
    # Add requestor
    if item_request.user_id:
        authorized_user_ids.add(item_request.user_id)
    
    # Add manager approver
    if item_request.manager_approver_user_id:
        authorized_user_ids.add(item_request.manager_approver_user_id)
    
    # Add procurement manager approver
    if item_request.procurement_manager_approver_user_id:
        authorized_user_ids.add(item_request.procurement_manager_approver_user_id)
    
    # Add all procurement staff (they should know about assignments)
    procurement_staff = User.query.filter_by(department='Procurement').all()
    for staff in procurement_staff:
        authorized_user_ids.add(staff.user_id)
    
    # Get all authorized approvers for this item request (includes GM, Operation Manager, etc.)
    authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
    for approver in authorized_approvers:
        authorized_user_ids.add(approver.user_id)
    
    # ALWAYS add General Manager (GM) - regardless of requestor
    gm_users = User.query.filter_by(role='GM').all()
    for gm_user in gm_users:
        authorized_user_ids.add(gm_user.user_id)
    
    # ALWAYS add Operation Manager - regardless of requestor
    op_manager_users = User.query.filter_by(role='Operation Manager').all()
    for op_manager in op_manager_users:
        authorized_user_ids.add(op_manager.user_id)
    
    # Send notifications to all authorized users
    notification_message = f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {item_request.item_name} has been assigned to {current_user.name} by {current_user.name}."
    for user_id in authorized_user_ids:
        create_notification(
            user_id=user_id,
            title="Item Request Assigned",
            message=notification_message,
            notification_type="item_request_assigned",
            item_request_id=request_id
        )
    
    # Explicitly notify the manager who originally approved (they should know it was assigned)
    if item_request.manager_approver_user_id:
        create_notification(
            user_id=item_request.manager_approver_user_id,
            title="Item Request Assigned",
            message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) that you approved has been assigned to {current_user.name} for processing.",
            notification_type="item_request_assigned",
            item_request_id=request_id
        )
    
    db.session.commit()
    
    log_action(f"Assigned item request #{request_id} to {current_user.name}")
    flash(f'Successfully assigned request #{request_id} to yourself.', 'success')
    
    return redirect(url_for('view_item_request_page', request_id=request_id) + '?tab=assigned')


@app.route('/procurement/item-requests/bulk-upload', methods=['POST'])
@login_required
def bulk_upload_item_files():
    """Bulk upload invoice/receipt files to multiple item requests"""
    if current_user.department != 'Procurement':
        flash('Only procurement staff can perform this action.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    request_ids_str = request.form.get('request_ids', '').strip()
    if not request_ids_str:
        flash('No requests selected.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    # Receipt Amount (required, applied to all selected requests)
    receipt_amount_str = request.form.get('receipt_amount', '').strip()
    if not receipt_amount_str:
        flash('Receipt amount is required.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    try:
        receipt_amount_value = float(receipt_amount_str)
        if receipt_amount_value <= 0:
            raise ValueError()
    except Exception:
        flash('Please enter a valid positive receipt amount in OMR.', 'danger')
        return redirect(url_for('procurement_item_requests'))

    # Invoice Amount (required, applied to all selected requests)
    invoice_amount_str = request.form.get('invoice_amount', '').strip()
    if not invoice_amount_str:
        flash('Invoice amount is required.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    try:
        invoice_amount_value = float(invoice_amount_str)
        if invoice_amount_value <= 0:
            raise ValueError()
    except Exception:
        flash('Please enter a valid positive invoice amount in OMR.', 'danger')
        return redirect(url_for('procurement_item_requests'))

    # Receipt reference number (required, alphanumeric only)
    receipt_reference_number = request.form.get('receipt_reference_number', '').strip()
    if not receipt_reference_number:
        flash('Receipt reference number is required.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    if not re.match(r'^[A-Za-z0-9]+$', receipt_reference_number):
        flash('Receipt reference number must contain only letters and numbers (no spaces or symbols).', 'danger')
        return redirect(url_for('procurement_item_requests'))

    try:
        request_ids = [int(rid.strip()) for rid in request_ids_str.split(',')]
    except ValueError:
        flash('Invalid request IDs.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    # Handle receipt files (optional)
    receipt_files = request.files.getlist('receipt_files')
    uploaded_receipt_filenames = []
    
    # Handle invoice files (optional)
    invoice_files = request.files.getlist('invoice_files')
    uploaded_invoice_filenames = []
    
    # Check if both file types are provided (both are required)
    if not receipt_files or not any(f.filename for f in receipt_files):
        flash('Upload Receipt file is required.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    if not invoice_files or not any(f.filename for f in invoice_files):
        flash('Upload Invoice file is required.', 'danger')
        return redirect(url_for('procurement_item_requests'))
    
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
    
    # Process receipt files
    if receipt_files and any(f.filename for f in receipt_files):
        for receipt_file in receipt_files:
            if receipt_file and receipt_file.filename:
                file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                if file_extension not in allowed_extensions:
                    flash(f'Invalid file type for receipt "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                    return redirect(url_for('procurement_item_requests'))
                
                file_size = len(receipt_file.read())
                if file_size > max_file_size:
                    flash(f'Receipt file "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                    return redirect(url_for('procurement_item_requests'))
                
                receipt_file.seek(0)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = secure_filename(receipt_file.filename)
                filename = f"bulk_receipt_{timestamp}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                receipt_file.save(filepath)
                uploaded_receipt_filenames.append(filename)
    
    # Process invoice files
    if invoice_files and any(f.filename for f in invoice_files):
        for invoice_file in invoice_files:
            if invoice_file and invoice_file.filename:
                file_extension = invoice_file.filename.rsplit('.', 1)[1].lower() if '.' in invoice_file.filename else ''
                if file_extension not in allowed_extensions:
                    flash(f'Invalid file type for invoice "{invoice_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                    return redirect(url_for('procurement_item_requests'))
                
                file_size = len(invoice_file.read())
                if file_size > max_file_size:
                    flash(f'Invoice file "{invoice_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                    return redirect(url_for('procurement_item_requests'))
                
                invoice_file.seek(0)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = secure_filename(invoice_file.filename)
                filename = f"bulk_invoice_{timestamp}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                invoice_file.save(filepath)
                uploaded_invoice_filenames.append(filename)
    
    # Update all selected requests
    updated_count = 0
    skipped_count = 0
    not_assigned_count = 0
    
    for request_id in request_ids:
        item_request = ProcurementItemRequest.query.get(request_id)
        if not item_request:
            skipped_count += 1
            continue
        
        # Only update if status is "Assigned to Procurement"
        if item_request.status == 'Assigned to Procurement':
            # Check if current user is assigned to this request
            if item_request.assigned_to_user_id != current_user.user_id:
                not_assigned_count += 1
                skipped_count += 1
                continue
            
            # Merge with existing files if any
            existing_receipts = []
            existing_invoices = []
            
            if item_request.receipt_path:
                try:
                    existing_receipts = json.loads(item_request.receipt_path)
                    if not isinstance(existing_receipts, list):
                        existing_receipts = [item_request.receipt_path]
                except:
                    existing_receipts = [item_request.receipt_path] if item_request.receipt_path else []
            
            if item_request.invoice_path:
                try:
                    existing_invoices = json.loads(item_request.invoice_path)
                    if not isinstance(existing_invoices, list):
                        existing_invoices = [item_request.invoice_path]
                except:
                    existing_invoices = [item_request.invoice_path] if item_request.invoice_path else []
            
            # Add new files to existing ones
            all_receipts = existing_receipts + uploaded_receipt_filenames
            all_invoices = existing_invoices + uploaded_invoice_filenames
            
            item_request.receipt_path = json.dumps(all_receipts) if all_receipts else None
            item_request.invoice_path = json.dumps(all_invoices) if all_invoices else None
            item_request.receipt_amount = receipt_amount_value
            item_request.invoice_amount = invoice_amount_value
            item_request.receipt_reference_number = receipt_reference_number
            
            # Mark request as completed
            current_time = datetime.utcnow()
            item_request.status = 'Completed'
            item_request.completed_by_user_id = current_user.user_id
            item_request.completion_date = current_time
            item_request.updated_at = current_time
            
            updated_count += 1
            
            # Get authorized persons for notifications
            authorized_users = []
            
            # Add requestor
            if item_request.user_id:
                authorized_users.append(item_request.user_id)
            
            # Add manager approver
            if item_request.manager_approver_user_id:
                authorized_users.append(item_request.manager_approver_user_id)
            
            # Add procurement manager approver
            if item_request.procurement_manager_approver_user_id:
                authorized_users.append(item_request.procurement_manager_approver_user_id)
            
            # Add all procurement staff
            procurement_staff = User.query.filter_by(department='Procurement').all()
            for staff in procurement_staff:
                if staff.user_id not in authorized_users:
                    authorized_users.append(staff.user_id)
            
            # Add all auditing department users
            auditing_staff = User.query.filter_by(department='Auditing').all()
            for audit_user in auditing_staff:
                if audit_user.user_id not in authorized_users:
                    authorized_users.append(audit_user.user_id)
            
            # Send notifications for completion
            for user_id in authorized_users:
                create_notification(
                    user_id=user_id,
                    title="Item Request Completed",
                    message=f"Item request #{request_id} from {item_request.requestor_name} ({item_request.department}) for {item_request.item_name} has been completed by {current_user.name}.",
                    notification_type="request_completed",
                    item_request_id=request_id
                )
            
            log_action(f"Bulk uploaded files and marked item request #{request_id} as completed by {current_user.name}")
        else:
            skipped_count += 1
    
    db.session.commit()
    
    if updated_count > 0:
        flash(f'Successfully uploaded files and marked {updated_count} request(s) as completed.', 'success')
    if not_assigned_count > 0:
        flash(f'Skipped {not_assigned_count} request(s) that are not assigned to you. You can only bulk upload requests assigned to you.', 'warning')
    if skipped_count > not_assigned_count:
        flash(f'Skipped {skipped_count - not_assigned_count} request(s) that are not in "Assigned to Procurement" status.', 'info')
    
    return redirect(url_for('procurement_item_requests'))


@app.route('/procurement/request-item', methods=['GET', 'POST'])
@login_required
def procurement_request_item():
    """Form for requesting items from Procurement department"""
    
    if request.method == 'POST':
        # Handle form submission
        requestor_name = request.form.get('requestor_name', '').strip()
        category = request.form.get('category', '').strip()
        # Check for multiple item names first (new format), then fall back to item_name_value or item_name (backward compatibility)
        item_names = request.form.get('item_names', '').strip()
        item_name_value = request.form.get('item_name_value', '').strip()
        item_name = request.form.get('item_name', '').strip()
        item_quantities_json = request.form.get('item_quantities', '').strip()
        # Use item_names if available, otherwise use item_name_value or item_name
        if item_names:
            item_name = item_names
        elif item_name_value:
            item_name = item_name_value
        # Handle quantities - always use item_quantities from per-item QTY fields
        quantity = None
        if item_quantities_json:
            try:
                import json
                quantities = json.loads(item_quantities_json)
                # Combine quantities into a formatted string if multiple items
                if item_names and len(quantities) > 1:
                    # Store only the numeric quantities in order, separated by semicolons
                    quantity_parts = []
                    for qty in quantities:
                        if qty and qty.strip():
                            quantity_parts.append(qty.strip())
                    if quantity_parts:
                        quantity = '; '.join(quantity_parts)
                    elif len(quantities) == 1 and quantities[0]:
                        quantity = quantities[0]
                elif len(quantities) == 1 and quantities[0]:
                    quantity = quantities[0]
            except (json.JSONDecodeError, ValueError):
                pass
        purpose = request.form.get('purpose', '').strip()
        # Check for multiple branch names first (new format), then fall back to single branch_name (backward compatibility)
        branch_names = request.form.get('branch_names', '').strip()
        branch_name = request.form.get('branch_name', '').strip()
        # Use branch_names if available, otherwise use branch_name
        if branch_names:
            branch_name = branch_names
        # Date is automatically set to today's date (no longer required from form)
        request_date = datetime.utcnow().date()
        notes = request.form.get('notes', '').strip()
        
        # Check if this is a save as draft request
        is_save_draft = request.form.get('action') == 'save_draft'
        
        # Validation for submit (more strict) vs draft (more lenient)
        if not is_save_draft:
            # Build missing fields list similar to client-side
            missing_fields = []
            if not requestor_name:
                missing_fields.append('requestor_name')
            if not category:
                missing_fields.append('category')
            # item_name may contain multiple items joined by commas - check presence
            if not item_name:
                missing_fields.append('item_name')
            if not purpose:
                missing_fields.append('purpose')
            if not branch_name:
                missing_fields.append('branch_name')
            # Check uploaded files presence (server-side fallback)
            uploaded_files = request.files.getlist('upload_files') if 'upload_files' in request.files else []
            has_file = any(f and getattr(f, 'filename', '') for f in uploaded_files)
            if not has_file:
                missing_fields.append('upload_files')
            # evidence_files is optional; do not require it server-side

            # Check quantities: parse item_quantities JSON (if provided) and ensure at least one positive numeric value
            qty_problem = False
            if item_quantities_json:
                try:
                    import json as _json
                    parsed_quantities = _json.loads(item_quantities_json)
                    # parsed_quantities should be a list of values corresponding to selected items
                    if not parsed_quantities or (isinstance(parsed_quantities, list) and all((not q or str(q).strip() == '') for q in parsed_quantities)):
                        qty_problem = True
                    else:
                        for q in parsed_quantities:
                            try:
                                if float(str(q).strip()) <= 0:
                                    qty_problem = True
                                    break
                            except Exception:
                                qty_problem = True
                                break
                except Exception:
                    # If parsing fails, mark as problem so client will be required to supply quantities
                    qty_problem = True
            else:
                # No quantities provided at all
                qty_problem = True

            if qty_problem:
                missing_fields.append('item_quantity')

            if missing_fields:
                # If request came via AJAX/fetch, return JSON with missing fields so frontend can show the same modal
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 'application/json' in (request.headers.get('Accept') or ''):
                    return jsonify({'missing_fields': missing_fields}), 400
                # Fallback behavior for non-AJAX: flash and redirect
                flash('Please fill in all required fields.', 'danger')
                return redirect(url_for('procurement_request_item'))

            # Require quantities for submission and ensure they are positive
            valid_quantity = False
            if quantity:
                # quantity may be semicolon-separated for multiple items
                qty_parts = [q.strip() for q in (quantity.split(';') if ';' in quantity else [quantity.strip()])]
                for part in qty_parts:
                    try:
                        if float(part) > 0:
                            valid_quantity = True
                            break
                    except Exception:
                        # non-numeric part - skip
                        continue
            if not valid_quantity:
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 'application/json' in (request.headers.get('Accept') or ''):
                    return jsonify({'errors': ['Please provide a positive quantity for the requested item(s).']}), 400
                flash('Please provide a positive quantity for the requested item(s).', 'danger')
                return redirect(url_for('procurement_request_item'))
        
        # Handle requestor file uploads (both draft and submit)
        upload_paths = None
        uploaded_filenames = []
        if 'upload_files' in request.files:
            upload_files = request.files.getlist('upload_files')
            if upload_files and any(f.filename for f in upload_files):
                import uuid, json, os
                # Save uploads into the configured receipts upload folder so they are served by uploaded_file()
                upload_folder = app.config.get('UPLOAD_FOLDER') or os.path.join(app.root_path, 'uploads', 'receipts')
                os.makedirs(upload_folder, exist_ok=True)
                allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
                max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                for upfile in upload_files:
                    if upfile and upfile.filename:
                        # Validate size
                        file_size = len(upfile.read())
                        if file_size > max_file_size:
                            flash(f'File "{upfile.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                            return redirect(url_for('procurement_request_item'))
                        upfile.seek(0)
                        # Validate extension
                        file_extension = upfile.filename.rsplit('.', 1)[1].lower() if '.' in upfile.filename else ''
                        if file_extension not in allowed_extensions:
                            flash(f'Invalid file type for "{upfile.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                            return redirect(url_for('procurement_request_item'))
                        filename = f"{uuid.uuid4()}_{secure_filename(upfile.filename)}"
                        full_path = os.path.join(upload_folder, filename)
                        upfile.save(full_path)
                        uploaded_filenames.append(filename)
                upload_paths = json.dumps(uploaded_filenames) if uploaded_filenames else None
        # Handle additional evidence file uploads (e.g., photos of damage / reason)
        evidence_paths = None
        evidence_filenames = []
        if 'evidence_files' in request.files:
            evidence_files = request.files.getlist('evidence_files')
            if evidence_files and any(f.filename for f in evidence_files):
                import uuid as _uuid, json as _json, os as _os
                evidence_upload_folder = app.config.get('UPLOAD_FOLDER') or os.path.join(app.root_path, 'uploads', 'receipts')
                _os.makedirs(evidence_upload_folder, exist_ok=True)
                allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
                max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                for upfile in evidence_files:
                    if upfile and upfile.filename:
                        file_size = len(upfile.read())
                        if file_size > max_file_size:
                            flash(f'File "{upfile.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'danger')
                            return redirect(url_for('procurement_request_item'))
                        upfile.seek(0)
                        file_extension = upfile.filename.rsplit('.', 1)[1].lower() if '.' in upfile.filename else ''
                        if file_extension not in allowed_extensions:
                            flash(f'Invalid file type for "{upfile.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'danger')
                            return redirect(url_for('procurement_request_item'))
                        filename = f"{_uuid.uuid4()}_{secure_filename(upfile.filename)}"
                        full_path = _os.path.join(evidence_upload_folder, filename)
                        upfile.save(full_path)
                        evidence_filenames.append(filename)
                evidence_paths = _json.dumps(evidence_filenames) if evidence_filenames else None
        # Create procurement item request record
        current_time = datetime.utcnow()
        item_request = ProcurementItemRequest(
            requestor_name=requestor_name,
            department=current_user.department if current_user else '',
            category=category if category else None,
            item_name=item_name,
            procurement_quantities=quantity if quantity else None,  # Store requested quantities as formatted string (not raw JSON)
            purpose=purpose,
            branch_name=branch_name,
            request_date=request_date,
            is_urgent=False,  # Will be set by manager during approval
            notes=notes if notes else None,
            is_draft=is_save_draft,  # Mark as draft if saving as draft
            status='Pending Manager Approval' if not is_save_draft else 'Draft',
            user_id=current_user.user_id if current_user else None,
            requestor_item_upload_path=upload_paths,
            requestor_evidence_upload_path=evidence_paths,
            manager_approval_start_time=current_time if not is_save_draft else None
        )
        
        db.session.add(item_request)
        db.session.commit()
        
        if is_save_draft:
            flash('Item request draft saved successfully!', 'success')
            log_action(f'Saved procurement item request as draft: {item_name}')
            return redirect(url_for('drafts') + '#item-requests')
        
        # Refresh the item_request to ensure relationships are loaded
        db.session.refresh(item_request)
        
        # Notify the requestor
        if current_user:
            create_notification(
                user_id=current_user.user_id,
                title="Item Request Submitted",
                message=f"Your item request for {item_name} has been submitted successfully and is awaiting manager approval.",
                notification_type="new_submission",
                item_request_id=item_request.id
            )
        
        # Notify manager(s) - similar to payment requests
        if current_user:
            # Get manager approvers - ensure we reload the item_request with user relationship
            item_request = ProcurementItemRequest.query.get(item_request.id)
            
            authorized_approvers = get_authorized_manager_approvers_for_item_request(item_request)
            
            if not authorized_approvers:
                # Log warning if no approvers found with more details
                log_action(f"WARNING: No authorized approvers found for item request #{item_request.id} from {requestor_name} ({item_request.department}), user_id: {item_request.user_id}, role: {current_user.role if current_user else 'Unknown'}")
            
            for approver in authorized_approvers:
                try:
                    create_notification(
                        user_id=approver.user_id,
                        title="New Item Request for Approval",
                        message=f"New item request submitted by {requestor_name} from {item_request.department} department for {item_name} - requires your approval",
                        notification_type="item_request_submission",
                        item_request_id=item_request.id
                    )
                except Exception as e:
                    # Silently handle notification errors - don't log to audit
                    pass
        
        # Notify IT department users about new item request (all IT Staff and IT Department Manager)
        it_users = User.query.filter(
            User.department == 'IT'
        ).filter(
            User.role.in_(['IT Staff', 'Department Manager'])
        ).all()
        
        for it_user in it_users:
            try:
                create_notification(
                    user_id=it_user.user_id,
                    title="New Item Request Created",
                    message=f"New item request #{item_request.id} submitted by {requestor_name} from {item_request.department} department for {item_name}",
                    notification_type="item_request_submission",
                    item_request_id=item_request.id
                )
                pass
            except Exception as e:
                # Silently handle notification errors - don't log to audit
                pass
        
        # Build a readable quantity string for display
        quantity_display = quantity or "N/A"
        flash(f'Item request submitted successfully! Item: {item_name}, Quantity: {quantity_display}', 'success')
        
        # Log the action
        log_action(f'Submitted procurement item request: {item_name} (Quantity: {quantity_display})')
        
        return redirect(url_for('procurement_item_requests'))
    
    # GET request - show the form
    # Get available branches ordered by location priority from database
    available_branches = get_branches_ordered_by_location()
    
    # Get categories and items from database based on user's department
    user_department = current_user.department if current_user else None
    procurement_categories = []
    procurement_items = []
    
    if user_department:
        # Get active categories for the user's department
        procurement_categories = ProcurementCategory.query.filter_by(
            department=user_department,
            is_active=True
        ).order_by(ProcurementCategory.name).all()
        
        # Get active items for the user's department
        procurement_items = ProcurementItem.query.filter_by(
            department=user_department,
            is_active=True
        ).order_by(ProcurementItem.name).all()
    
    # Legacy hard-coded items for backward compatibility (will be removed after migration)
    kitchen_tool_items = [
        "JUICE BLENDER (500ML)",
        "PLASTIC JAG COVER (2L)",
        "JUICE BLENDER JUG 5000ML",
        "BER SPOON",
        "JUICE CUP HOLDER",
        "MEASUREMENT CUP (SET)",
        "MEASUREMENT MUG",
        "MEASUREMENT SPOON (1/4) SET",
        "TONG",
        "FORTE SLOTTED SPATULA STAINLESS STEEL",
        "STAINLESS STEEL SERVING SPOON BIG",
        "SOUP LADLE 3 OZ SIZE",
        "STAINLESS STEEL BURGER SMASHER CIRCULAR",
        "STAINLESS STEEL FRENCH FRY SCOOP",
        "SHARPING STONE",
        "SPATULA WOODEN",
        "PLASTIC SPATULA (40CM)",
        "STAINLESS STEEL SALT SHAKER TOP FULLY HOLE",
        "TIMER",
        "GAS LIGHTER",
        "BRUSH FOR BREAD POLISH",
        "GRILL CLEANING BRUSH TRIANGLE",
        "FRYER CLEANING BRUSH",
        "STAINLESS STEEL ALLOY SCOOP MEDUIM SIZE",
        "STAINLESS STEEL SPOON WITH HOLES (3OZ)",
        "FRYING PAN FOR PASTA (20CM)",
        "FRYING PAN FOR PASTA (30CM)",
        "STAINLESS STEEL COOKING POT (30CM)",
        "STAINLESS STEEL TREY 40*30",
        "STAINLESS STEEL CONTAINERS WITH COVER (1 /1 15 CM)",
        "STAINLESS STEEL CONTAINERS WITH HOLES WITH COVER (1/1 15CM)",
        "STAINLES STEEL CONTAINERS WITH COVER (1/2 15CM)",
        "STAINLESS STEEL CONTAINER WITH HOLES WITH COVER (1/2 15CM)",
        "STAINLES STEEL CONTAINERS WITH COVER (1/3 15CM)",
        "STAINLESS STEEL CONTAINERS WITH HOLES WITH COVER (1/3 15 CM)",
        "STAINLESS STEEL CONTAINERS WITH COVER (1/6 15CM)",
        "STAINLESS STEEL FOOD KIPPER (3KG)",
        "SPICE BOX 4IN1",
        "STAINLESS STEEL BOWL (10L)",
        "STAINLESS STEEL COLANDER STRAINER 30CM",
        "STAINLESS STEEL STRAINER 11 INCHES WITH HANDLE",
        "STAINLESS STEEL STRAINER 7 INCHES WITH HANDLE",
        "STAINLESS STEEL STRAINER SMALL 7 INCHES WITH LONG HANDLE",
        "STAINLESS STEEL STRAINER SQUARE SHAPE 40*25CM",
        "STAINLESS STEEL STRAINER FOR CRISPY (27*37)CM",
        "STAINLESS STEEL STRAINER FOR DRAINAGE (10X10) INCHES",
        "POLYCARBONATED GN CONTAINER WITH COVER 1/2 (15CM)",
        "YELLOW CHOPPING BOARD BIG (60/40)",
        "YELLOOW CHOPPING BOARD SMALL (40/30)",
        "GREEN CHOPPING BOARD BIG (60/40)",
        "GREEN CHOPPING BOARD SMALL (40/30)",
        "RED CHOPPING BOARD BIG (60/40)",
        "RED CHOPPING BOARD SMALL (40/30)",
        "CHOPPING BOARD STAND",
        "GREEN KNIFE BIG (12INCH)",
        "YELLOW KNIFE BIG (12INCH)",
        "RED KNIFE BIG (12INCH)",
        "BREAD KNIFE BIG (12 INCH)",
        "BREAD KNIFE SMALL",
        "SQUEEZER BOTTLE YELLOW BIG 1000ML",
        "SQUEEZAR BOTTLE RED BIG 1000ML",
        "SQUEEZAR BOTTLE WHITE BIG 1000ML",
        "WHISK",
        "BIG WHITE SCALE (30/40KG)",
    ]
    
    # Dining items for Operation department
    dining_items = [
        "DINING TREY BIG",
        "DINING TREY MEDUIM",
        "DINING TREY SMALL",
        "DINING PLATE FOR FRIES",
        "DINING PLATE FOR BURGER",
        "DINING CUP FOR EXTRA SAUCE (2OZ)",
    ]
    
    # Stationary items for Operation department
    stationary_items = [
        "DUSTBIN BIG OPEN WITH LEG 120L",
        "DUSTBIN MEDUIM OPEN WITH LEG 60L",
        "DUSTBIN SMALL OPEN WITH LEG 40L",
        "DUSTBIN SMALL WITH LEG 40L FOR DINING AREA TOILET",
        "DUSTPAN WITH STICK BRUSH",
        "GRABBER TOOL",
    ]
    
    # Electrical items for Operation department
    electrical_items = [
        "Washing Machine",
        "Freezer",
        "Cashier Machine",
        "Phone",
        "Ipad",
        "Adapter",
        "Wire",
        "Fridge",
        "Cooker",
    ]
    
    # Furniture items for Operation department
    furniture_items = [
        "Curtains",
        "Door Mat",
    ]
    
    # HR Stationary items
    hr_stationary_items = [
        "Pens",
        "Note",
        "Files",
    ]
    
    # All items for Operation department (for backward compatibility)
    operation_items = kitchen_tool_items + dining_items + stationary_items + electrical_items + furniture_items + [
        "SMALL WEIGHT SCALE (IN TOP GLASS)",
        "BAIN MARIE (56*35)",
        "FRIES WARMER",
        "CABBAGE CUTER MACHINE",
        "GARLIC PEELER MACHINE",
        "ONION/MUSHROOM CUTTER",
        "PATTY PRESSER MACHINE BIG",
        "CAN OPENER",
        "TROLLY HEAVY BIG SIZE",
        "LADDER",
        "EXTENSION BOARD HEAVY DUTY",
        "PALETTE",
        "DRAINAGE CLEANING ACID",
        "SAFETY GLOVES",
        "TISSUE DISPENSER",
        "BROOM HOLDER"
    ]
    
    return render_template('procurement_request_item.html',
                         user=current_user,
                         available_branches=available_branches,
                         operation_items=operation_items,
                         kitchen_tool_items=kitchen_tool_items,
                         dining_items=dining_items,
                         stationary_items=stationary_items,
                         electrical_items=electrical_items,
                         furniture_items=furniture_items,
                         hr_stationary_items=hr_stationary_items,
                         procurement_categories=procurement_categories,
                         procurement_items=procurement_items,
                         today=datetime.utcnow().date().strftime('%Y-%m-%d'))


@app.route('/admin/dashboard')
@login_required
@role_required('Finance Admin')
def admin_dashboard():
    """Dashboard for admin - shows all requests with optional status filtering"""
    # Check for recurring payments due today
    check_recurring_payments_due()
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    status_filter = request.args.get('status', None)
    department_filter = request.args.get('department', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    tab = request.args.get('tab', 'all')  # 'all' tab shows all requests
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query with optional status, department, and search filters
    # Apply finance status filtering for all tabs (including "All Requests" tab)
    # Finance Admin can see finance-related statuses + Pending Manager Approval from Finance department only (or their own requests)
    finance_statuses = ['Pending Finance Approval', 'Returned to Manager', 'Proof Pending', 'Proof Sent', 'Proof Rejected', 'Recurring', 'Completed', 'Rejected by Finance']

    # For Abdalaziz, also include Pending Manager Approval and Rejected by Manager
    # for Finance department, his own requests, temporary manager assignments,
    # and requests submitted by Finance Staff, GM, Operation Manager, and CEO
    if current_user.name == 'Abdalaziz Al-Brashdi':
        special_submitter_roles = ['Finance Staff', 'GM', 'Operation Manager', 'CEO']
        query = PaymentRequest.query.filter(
            db.or_(
                PaymentRequest.status.in_(finance_statuses),
                # Pending Manager Approval from Finance department
                db.and_(
                    PaymentRequest.status == 'Pending Manager Approval',
                    PaymentRequest.department == 'Finance'
                ),
                # Rejected by Manager from Finance department
                db.and_(
                    PaymentRequest.status == 'Rejected by Manager',
                    PaymentRequest.department == 'Finance'
                ),
                # Always include current user's own requests regardless of status
                PaymentRequest.user_id == current_user.user_id,
                # Include requests where the current user is temporarily assigned as manager
                db.and_(
                    PaymentRequest.status == 'Pending Manager Approval',
                    PaymentRequest.temporary_manager_id == current_user.user_id
                ),
                # Include PMA/Rejected-by-Manager for specific submitter roles (GM/CEO/etc.)
                db.and_(
                    PaymentRequest.status.in_(['Pending Manager Approval', 'Rejected by Manager']),
                    PaymentRequest.user.has(User.role.in_(special_submitter_roles))
                )
            ),
            PaymentRequest.is_archived == False,
            PaymentRequest.is_draft == False
        )
    else:
        # Other Finance Admins only see finance-related statuses plus temporary assignments awaiting manager approval
        query = PaymentRequest.query.filter(
            db.or_(
                PaymentRequest.status.in_(finance_statuses),
                # Always include current user's own requests regardless of status
                PaymentRequest.user_id == current_user.user_id,
                db.and_(
                    PaymentRequest.status == 'Pending Manager Approval',
                    PaymentRequest.temporary_manager_id == current_user.user_id
                )
            ),
            PaymentRequest.is_archived == False,
            PaymentRequest.is_draft == False
        )
    
    # Apply department filter (before tab filtering)
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    
    # Apply search filter (before tab filtering)
    if search_query:
        # Search by request ID or requestor name
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            query = query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    
    # Apply urgent filter (before tab filtering)
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = query.filter(PaymentRequest.status == 'Completed')
    elif tab == 'rejected':
        query = query.filter(db.or_(
            PaymentRequest.status == 'Rejected by Manager',
            PaymentRequest.status == 'Rejected by Finance'
        ))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        # For 'my_requests' tab, show only the current user's requests
        query = query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        # 'all' tab - apply status filter if provided (only on all tab)
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    
    # Get paginated requests
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get overdue requests count
    overdue_count = get_overdue_requests_count()
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin_dashboard.html', 
                         requests=requests_pagination.items, 
                         my_requests=my_requests_pagination.items,
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         user=current_user, 
                         notifications=notifications, 
                         unread_count=unread_count,
                         overdue_count=overdue_count,
                         status_filter=status_filter,
                         department_filter=department_filter,
                         search_query=search_query,
                         urgent_filter=urgent_filter,
                         active_tab=tab)


@app.route('/finance/dashboard')
@login_required
@role_required('Finance Staff')
def finance_dashboard():
    """Dashboard for finance - can view all reports and submit requests"""
    # Check for recurring payments due today
    check_recurring_payments_due()
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.get('department', None)
    status_filter = request.args.get('status', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    tab = request.args.get('tab', 'all')  # 'all' tab shows all requests
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query with optional department and search filters
    # Apply finance status filtering for all tabs (including "All Requests" tab)
    # Finance Staff can see finance-related statuses + their own requests with Pending Manager Approval + their own requests with Rejected by Manager
    # Abdalaziz can see finance-related statuses + Pending Manager Approval + Rejected by Manager for Finance department only (or his own requests)
    finance_statuses = ['Pending Finance Approval', 'Returned to Manager', 'Proof Pending', 'Proof Sent', 'Proof Rejected', 'Recurring', 'Completed', 'Rejected by Finance']
    
    # Base query for finance-related statuses (exclude archived and drafts)
    query = PaymentRequest.query.filter(
        PaymentRequest.status.in_(finance_statuses),
        PaymentRequest.is_archived == False,
        PaymentRequest.is_draft == False
    )
    # Visibility hardening: Finance Staff must not see CEO-submitted requests
    if current_user.role == 'Finance Staff':
        query = query.filter(~PaymentRequest.user.has(User.role == 'CEO'))
    
    # Add Finance Staff's own requests with Pending Manager Approval and Rejected by Manager (exclude archived and drafts)
    if current_user.role == 'Finance Staff':
        own_pending_requests = PaymentRequest.query.filter(
            db.and_(
                PaymentRequest.user_id == current_user.user_id,
                PaymentRequest.status.in_(['Pending Manager Approval', 'Rejected by Manager']),
                PaymentRequest.is_archived == False,
                PaymentRequest.is_draft == False
            )
        )
        query = query.union(own_pending_requests)
    
    # Add Abdalaziz's special permissions: Finance department requests OR his own requests (exclude archived and drafts)
    elif current_user.name == 'Abdalaziz Al-Brashdi':
        abdalaziz_special_requests = PaymentRequest.query.filter(
            db.and_(
                PaymentRequest.status.in_(['Pending Manager Approval', 'Rejected by Manager']),
                db.or_(
                    PaymentRequest.department == 'Finance',
                    PaymentRequest.user_id == current_user.user_id
                ),
                PaymentRequest.is_archived == False,
                PaymentRequest.is_draft == False
            )
        )
        query = query.union(abdalaziz_special_requests)
    
    # Apply department filter (before tab filtering)
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    
    # Apply search filter (before tab filtering)
    if search_query:
        # Search by request ID or requestor name
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            query = query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    
    # Apply urgent filter (before tab filtering)
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = query.filter(PaymentRequest.status == 'Completed')
    elif tab == 'rejected':
        query = query.filter(db.or_(
            PaymentRequest.status == 'Rejected by Manager',
            PaymentRequest.status == 'Rejected by Finance'
        ))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        # For 'my_requests' tab, show only the current user's requests
        query = query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        # 'all' tab - apply status filter if provided (only on all tab)
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
        # Otherwise show all requests that the user can see
    
    # Get paginated requests
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get overdue requests count
    overdue_count = get_overdue_requests_count()
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('finance_dashboard.html', 
                         requests=requests_pagination.items, 
                         my_requests=my_requests_pagination.items,
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         user=current_user, 
                         notifications=notifications, 
                         unread_count=unread_count,
                         overdue_count=overdue_count,
                         department_filter=department_filter,
                         search_query=search_query,
                         urgent_filter=urgent_filter,
                         active_tab=tab)


@app.route('/gm/dashboard')
@login_required
@role_required('GM')
def gm_dashboard():
    """Dashboard for General Manager - view all reports (Approved/Pending only)"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.get('department', None)
    status_filter = request.args.get('status', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    tab = request.args.get('tab', 'all')  # 'all' tab shows all requests
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query with optional department and search filters
    # GM can see ALL requests from ALL departments including rejected by manager
    # Exclude archived requests and drafts
    query = PaymentRequest.query.filter(
        PaymentRequest.is_archived == False,
        PaymentRequest.is_draft == False
    )
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    if search_query:
        # Search by request ID or requestor name
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            query = query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = query.filter(PaymentRequest.status.in_(['Completed', 'Paid', 'Approved']))
    elif tab == 'rejected':
        query = query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        # For 'my_requests' tab, show only the current user's requests
        query = query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        # 'all' tab (All Requests) shows all requests
        # Apply status filter if provided (excludes Completed, Rejected, Recurring from dropdown)
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    # Default case also shows all requests
    
    # Get paginated requests
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    # Calculate statistics (all requests from all departments - exclude archived and drafts)
    all_requests = PaymentRequest.query.filter(
        PaymentRequest.is_archived == False,
        PaymentRequest.is_draft == False
    ).all()
    total_requests = len(all_requests)
    approved = len([r for r in all_requests if r.status == 'Approved'])
    pending = len([r for r in all_requests if r.status == 'Pending'])
    total_amount = sum([float(r.amount) for r in all_requests if r.status == 'Approved'])
    
    stats = {
        'total_requests': total_requests,
        'approved': approved,
        'pending': pending,
        'total_amount': total_amount
    }
    
    # Get notifications for GM (all notifications)
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get separate queries for completed, rejected, and recurring requests for tab content (exclude archived)
    completed_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    rejected_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    recurring_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    
    if department_filter:
        completed_query = completed_query.filter(PaymentRequest.department == department_filter)
        rejected_query = rejected_query.filter(PaymentRequest.department == department_filter)
        recurring_query = recurring_query.filter(PaymentRequest.department == department_filter)
    
    completed_query = completed_query.filter(PaymentRequest.status == 'Completed')
    rejected_query = rejected_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    recurring_query = recurring_query.filter(PaymentRequest.recurring == 'Recurring')
    
    completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    rejected_requests = rejected_query.order_by(get_rejected_datetime_order()).all()
    recurring_requests = recurring_query.order_by(PaymentRequest.created_at.desc()).all()
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('gm_dashboard.html', 
                         requests=requests_pagination.items, 
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         stats=stats, 
                         user=current_user,
                         notifications=notifications,
                         unread_count=unread_count,
                         department_filter=department_filter,
                         status_filter=status_filter,
                         search_query=search_query,
                         urgent_filter=urgent_filter,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         recurring_requests=recurring_requests,
                         my_requests=my_requests_pagination.items,
                         active_tab=tab)


@app.route('/ceo/dashboard')
@login_required
@role_required('CEO')
def ceo_dashboard():
    """Dashboard for CEO - identical to GM but view-only (no approval actions)"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.get('department', None)
    status_filter = request.args.get('status', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    tab = request.args.get('tab', 'all')

    if per_page not in [10, 20, 50, 100]:
        per_page = 10

    # Exclude archived requests and drafts
    query = PaymentRequest.query.filter(
        PaymentRequest.is_archived == False,
        PaymentRequest.is_draft == False
    )
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    if search_query:
        # Search by request ID or requestor name
        try:
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            query = query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)

    if tab == 'completed':
        query = query.filter(PaymentRequest.status.in_(['Completed', 'Paid', 'Approved']))
    elif tab == 'rejected':
        query = query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        query = query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)

    # Get paginated requests
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )

    # Exclude archived requests and drafts from stats
    all_requests = PaymentRequest.query.filter(
        PaymentRequest.is_archived == False,
        PaymentRequest.is_draft == False
    ).all()
    stats = {
        'total_requests': len(all_requests),
        'approved': len([r for r in all_requests if r.status == 'Approved']),
        'pending': len([r for r in all_requests if r.status == 'Pending']),
        'total_amount': sum([float(r.amount) for r in all_requests if r.status == 'Approved'])
    }

    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)

    # Exclude archived requests from tab queries
    completed_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    rejected_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    recurring_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    if department_filter:
        completed_query = completed_query.filter(PaymentRequest.department == department_filter)
        rejected_query = rejected_query.filter(PaymentRequest.department == department_filter)
        recurring_query = recurring_query.filter(PaymentRequest.department == department_filter)

    completed_query = completed_query.filter(PaymentRequest.status == 'Completed')
    rejected_query = rejected_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    recurring_query = recurring_query.filter(PaymentRequest.recurring == 'Recurring')

    completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    rejected_requests = rejected_query.order_by(PaymentRequest.created_at.desc()).all()
    recurring_requests = recurring_query.order_by(PaymentRequest.created_at.desc()).all()

    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )

    return render_template('ceo_dashboard.html',
                          requests=requests_pagination.items,
                          pagination=requests_pagination,
                          my_pagination=my_requests_pagination,
                          stats=stats,
                          user=current_user,
                          notifications=notifications,
                          unread_count=unread_count,
                          department_filter=department_filter,
                          status_filter=status_filter,
                          search_query=search_query,
                          urgent_filter=urgent_filter,
                          completed_requests=completed_requests,
                          rejected_requests=rejected_requests,
                          recurring_requests=recurring_requests,
                          my_requests=my_requests_pagination.items,
                          active_tab=tab)

@app.route('/it/dashboard')
@login_required
@role_required('IT Staff', 'Department Manager')
def it_dashboard():
    """Dashboard for IT - full CRUD access"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.get('department', None)
    status_filter = request.args.get('status', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    location_filter = request.args.get('location', None)
    tab = request.args.get('tab', 'all')  # 'all' tab shows all requests
    
    # If department filter is provided, default to request-types tab
    if department_filter and not request.args.get('tab'):
        tab = 'request-types'
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        session['permission_denied'] = 'You do not have permission to access this page.'
        return redirect(url_for('dashboard'))
    
    # Build query with optional department and search filters
    if current_user.role == 'IT Staff' or (current_user.role == 'Department Manager' and current_user.department == 'IT'):
        # IT users and IT Department Managers see all requests (sensitive fields masked in UI)
        # Exclude archived requests
        query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    else:
        # Other users should not see requests that are still pending manager approval
        # Exclude archived requests
        query = PaymentRequest.query.filter(
            PaymentRequest.status != 'Pending Manager Approval',
            PaymentRequest.is_archived == False
        )
    
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    if search_query:
        # Search by request ID or requestor name
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search ONLY by requestor name
            search_term = f'%{search_query}%'
            query = query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = query.filter(PaymentRequest.status.in_(['Completed', 'Paid', 'Approved']))
    elif tab == 'rejected':
        query = query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'all':
        # 'all' tab (All Requests) shows all requests
        # Apply status filter if provided (excludes Completed, Rejected, Recurring from dropdown)
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    # Default case also shows all requests
    
    # Get paginated requests
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    # Get notifications for IT users and IT Department Managers
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get separate queries for completed, rejected, and recurring requests for tab content
    # Exclude archived requests from all queries
    completed_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    rejected_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    recurring_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    
    if current_user.role == 'IT Staff' or (current_user.role == 'Department Manager' and current_user.department == 'IT'):
        # IT users and IT Department Managers see all requests
        pass
    else:
        # Other users should not see requests that are still pending manager approval
        completed_query = completed_query.filter(PaymentRequest.status != 'Pending Manager Approval')
        rejected_query = rejected_query.filter(PaymentRequest.status != 'Pending Manager Approval')
        recurring_query = recurring_query.filter(PaymentRequest.status != 'Pending Manager Approval')
    
    if department_filter:
        completed_query = completed_query.filter(PaymentRequest.department == department_filter)
        rejected_query = rejected_query.filter(PaymentRequest.department == department_filter)
        recurring_query = recurring_query.filter(PaymentRequest.department == department_filter)
    
    completed_query = completed_query.filter(PaymentRequest.status == 'Completed')
    rejected_query = rejected_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    recurring_query = recurring_query.filter(PaymentRequest.recurring == 'Recurring')
    
    completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    rejected_requests = rejected_query.order_by(PaymentRequest.created_at.desc()).all()
    recurring_requests = recurring_query.order_by(PaymentRequest.created_at.desc()).all()
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    users = User.query.all()
    logs = AuditLog.query.order_by(AuditLog.timestamp.desc()).limit(50).all()
    
    # Get search queries for request types and person/company options
    request_types_search = request.args.get('request_types_search', '')
    person_company_search = request.args.get('person_company_search', '')
    
    # Get request types for the Request Types Management section with department filter
    request_types_query = RequestType.query
    
    # Apply department filter if specified
    if department_filter and department_filter != 'all':
        if department_filter == 'Management':
            request_types_query = request_types_query.filter(RequestType.department.in_(['Management', 'General Manager']))
        else:
            request_types_query = request_types_query.filter(RequestType.department == department_filter)
    
    # Apply search filter for request types
    if request_types_search:
        request_types_query = request_types_query.filter(RequestType.name.contains(request_types_search))
    
    request_types = request_types_query.order_by(RequestType.id).all()
    
    # Get person/company options for the Person/Company Names Management section with department filter
    person_company_options_query = PersonCompanyOption.query
    
    # Apply department filter if specified
    if department_filter and department_filter != 'all':
        if department_filter == 'Management':
            person_company_options_query = person_company_options_query.filter(PersonCompanyOption.department.in_(['Management', 'General Manager']))
        else:
            person_company_options_query = person_company_options_query.filter(PersonCompanyOption.department == department_filter)
    
    # Apply search filter for person/company options
    if person_company_search:
        person_company_options_query = person_company_options_query.filter(PersonCompanyOption.name.contains(person_company_search))
    
    person_company_options = person_company_options_query.order_by(PersonCompanyOption.id).all()
    
    # Get procurement categories and items for the Procurement Categories/Items Management section
    procurement_categories_query = ProcurementCategory.query
    procurement_items_query = ProcurementItem.query
    
    # Apply department filter if specified
    procurement_department_filter = request.args.get('procurement_department_filter', '')
    if procurement_department_filter and procurement_department_filter != 'all':
        procurement_categories_query = procurement_categories_query.filter(ProcurementCategory.department == procurement_department_filter)
        procurement_items_query = procurement_items_query.filter(ProcurementItem.department == procurement_department_filter)
    
    # Apply search filter for procurement items
    procurement_search = request.args.get('procurement_search', '')
    if procurement_search:
        procurement_categories_query = procurement_categories_query.filter(ProcurementCategory.name.contains(procurement_search))
        procurement_items_query = procurement_items_query.filter(ProcurementItem.name.contains(procurement_search))
    
    procurement_categories = procurement_categories_query.order_by(ProcurementCategory.id).all()
    procurement_items = procurement_items_query.order_by(ProcurementItem.id).all()
    
    # Get branches for the Branches Management section
    branches_query = Branch.query.filter_by(is_active=True)
    
    # Apply location filter if specified
    if location_filter:
        branches_query = branches_query.filter(Branch.restaurant == location_filter)
    
    branches = branches_query.order_by(Branch.id).all()
    
    # Get all departments for the filter dropdown and normalize legacy label
    all_departments = db.session.query(RequestType.department).distinct().order_by(RequestType.department).all()
    departments = []
    for dept in all_departments:
        d = dept[0]
        departments.append('Management' if d == 'General Manager' else d)
    
    # Get available locations for the filter dropdown
    available_locations = get_location_priorities()
    
    # Get all location priorities for the branches tab
    location_priorities = LocationPriority.query.order_by(LocationPriority.priority, LocationPriority.location_name).all()
    
    return render_template('it_dashboard.html', 
                         requests=requests_pagination.items, 
                         my_requests=my_requests_pagination.items,
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         users=users, 
                         logs=logs, 
                         request_types=request_types,
                         person_company_options=person_company_options,
                         procurement_categories=procurement_categories,
                         procurement_items=procurement_items,
                         procurement_department_filter=procurement_department_filter,
                         procurement_search=procurement_search,
                         branches=branches,
                         departments=departments,
                         user=current_user,
                         notifications=notifications,
                         unread_count=unread_count,
                         department_filter=department_filter,
                         status_filter=status_filter,
                         search_query=search_query,
                         request_types_search=request_types_search,
                         person_company_search=person_company_search,
                         location_filter=location_filter,
                         available_locations=available_locations,
                         location_priorities=location_priorities,
                         urgent_filter=urgent_filter,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         recurring_requests=recurring_requests,
                         active_tab=tab)


@app.route('/it/archives')
@login_required
@role_required('IT Staff', 'Department Manager')
def archives():
    """Archives page for IT department - shows archived requests"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        session['permission_denied'] = 'You do not have permission to access this page.'
        return redirect(url_for('dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.get('department', None)
    status_filter = request.args.get('status', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query for archived requests only
    query = PaymentRequest.query.filter(PaymentRequest.is_archived == True)
    
    # Apply filters
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    
    if search_query:
        # Search by request ID or requestor name
        try:
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            search_term = f'%{search_query}%'
            query = query.filter(
                PaymentRequest.requestor_name.ilike(search_term)
            )
    
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    if status_filter:
        query = query.filter(PaymentRequest.status == status_filter)
    
    # Get paginated archived requests
    requests_pagination = query.order_by(PaymentRequest.archived_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    # Get all departments for the filter dropdown
    all_departments = db.session.query(RequestType.department).distinct().order_by(RequestType.department).all()
    departments = []
    for dept in all_departments:
        d = dept[0]
        departments.append('Management' if d == 'General Manager' else d)
    
    return render_template('archives.html',
                         requests=requests_pagination.items,
                         pagination=requests_pagination,
                         departments=departments,
                         user=current_user,
                         department_filter=department_filter,
                         status_filter=status_filter,
                         search_query=search_query,
                         urgent_filter=urgent_filter)


@app.route('/request/<int:request_id>/restore', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def restore_request(request_id):
    """Restore an archived payment request (IT only)"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        session['permission_denied'] = 'You do not have permission to access this page.'
        return redirect(url_for('dashboard'))
    
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is archived
    if not req.is_archived:
        flash(f'Payment request #{request_id} is not archived.', 'warning')
        return redirect(url_for('archives'))
    
    # Resume any paused approval timing when restoring
    # If timing was paused (end_time was set during archiving), resume it from where it left off
    # We adjust the start_time to account for the pause duration, so elapsed time continues correctly
    
    # Store archived_at before clearing it (needed for timing check)
    archived_at_time = req.archived_at
    restore_time = datetime.utcnow()
    
    # Resume manager approval timing if it was paused
    if req.manager_approval_start_time and req.manager_approval_end_time:
        # Check if end_time was set during archiving (close to archived_at time)
        if archived_at_time and abs((req.manager_approval_end_time - archived_at_time).total_seconds()) < 60:
            # Timing was paused during archiving - calculate elapsed time and adjust start_time
            # Elapsed time = time from start to when it was paused
            elapsed_time = req.manager_approval_end_time - req.manager_approval_start_time
            # Adjust start_time so elapsed time calculation continues from where it left off
            # New start_time = now - elapsed_time (so elapsed = now - new_start = elapsed_time + time_since_restore)
            req.manager_approval_start_time = restore_time - elapsed_time
            req.manager_approval_end_time = None  # Clear end_time to resume timing
            print(f"DEBUG: Resumed manager approval timing for request #{request_id} (elapsed: {elapsed_time.total_seconds()}s)")
    
    # Resume finance approval timing if it was paused
    if req.finance_approval_start_time and req.finance_approval_end_time:
        # Check if end_time was set during archiving (close to archived_at time)
        if archived_at_time and abs((req.finance_approval_end_time - archived_at_time).total_seconds()) < 60:
            # Timing was paused during archiving - calculate elapsed time and adjust start_time
            # Elapsed time = time from start to when it was paused
            elapsed_time = req.finance_approval_end_time - req.finance_approval_start_time
            # Adjust start_time so elapsed time calculation continues from where it left off
            # New start_time = now - elapsed_time (so elapsed = now - new_start = elapsed_time + time_since_restore)
            req.finance_approval_start_time = restore_time - elapsed_time
            req.finance_approval_end_time = None  # Clear end_time to resume timing
            print(f"DEBUG: Resumed finance approval timing for request #{request_id} (elapsed: {elapsed_time.total_seconds()}s)")
    
    # Restore the request
    req.is_archived = False
    req.archived_at = None
    req.archived_by = None
    req.archived_by_user_id = None
    
    db.session.commit()
    
    log_action(f"Restored payment request #{request_id}")
    
    # Notify all IT department users about the restore
    it_users = User.query.filter(
        db.or_(
            User.role == 'IT Staff',
            db.and_(User.role == 'Department Manager', User.department == 'IT')
        )
    ).all()
    
    print(f"DEBUG: Found {len(it_users)} IT department users for restore notification")
    for u in it_users:
        print(f"DEBUG: IT user: {u.username} (ID: {u.user_id}, Role: {u.role}, Dept: {u.department})")
    
    # Exclude the user who restored (they already know)
    it_users_to_notify = [user for user in it_users if user.user_id != current_user.user_id]
    
    print(f"DEBUG: Will notify {len(it_users_to_notify)} IT users about restore (excluding restorer: {current_user.username})")
    
    notification_title = "Payment Request Restored"
    notification_message = f"Payment request #{request_id} submitted by {req.requestor_name} has been restored by {current_user.name}."
    
    for it_user in it_users_to_notify:
        print(f"DEBUG: Creating restore notification for IT user: {it_user.username} (ID: {it_user.user_id})")
        create_notification(
            user_id=it_user.user_id,
            title=notification_title,
            message=notification_message,
            notification_type="request_restored",
            request_id=request_id
        )
    
    # Emit real-time notification to all users after creating database notifications
    if it_users_to_notify:
        try:
            socketio.emit('new_notification', {
                'title': notification_title,
                'message': notification_message,
                'type': 'request_restored',
                'request_id': request_id
            }, room='all_users')
            
            # Also emit a general update event to trigger notification count updates
            socketio.emit('notification_update', {
                'action': 'new_notification',
                'type': 'request_restored'
            }, room='all_users')
            
            print(f"DEBUG: WebSocket events emitted for request_restored")
        except Exception as e:
            print(f"Error emitting WebSocket notification: {e}")
    
    flash(f'Payment request #{request_id} has been restored.', 'success')
    return redirect(url_for('archives'))


@app.route('/request/<int:request_id>/delete_permanently', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_request_permanently(request_id):
    """Permanently delete a payment request from the database (IT only)"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to perform this action.', 'danger')
        return redirect(url_for('dashboard'))
    
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is archived
    if not req.is_archived:
        flash(f'Payment request #{request_id} must be archived before it can be permanently deleted.', 'warning')
        return redirect(url_for('archives'))
    
    try:
        # Store request info for notifications before deletion
        requestor_name = req.requestor_name
        request_id_val = request_id
        
        # Notify all IT department users about the permanent deletion (same as archive notifications)
        it_users = User.query.filter(
            db.or_(
                User.role == 'IT Staff',
                db.and_(User.role == 'Department Manager', User.department == 'IT')
            )
        ).all()
        
        # Exclude the user who deleted (they already know)
        it_users_to_notify = [user for user in it_users if user.user_id != current_user.user_id]
        
        notification_title = "Payment Request Permanently Deleted"
        notification_message = f"Payment request #{request_id_val} submitted by {requestor_name} has been permanently deleted from the database by {current_user.name}. This action cannot be undone."
        
        # Delete old notifications for this request first (before creating new ones)
        Notification.query.filter_by(request_id=request_id).delete()
        
        # Create new "permanently deleted" notifications BEFORE deleting the request (so request_id is still valid)
        for it_user in it_users_to_notify:
            create_notification(
                user_id=it_user.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="request_permanently_deleted",
                request_id=request_id_val
            )
        
        # Commit notifications before deleting the request
        db.session.commit()
        
        # Delete all related records (cascade deletes)
        
        # 1. Get schedule IDs before deleting schedules (for edit history cleanup)
        schedule_ids = db.session.query(RecurringPaymentSchedule.schedule_id).filter_by(request_id=request_id).all()
        schedule_ids_list = [sid[0] for sid in schedule_ids] if schedule_ids else []
        
        # 2. Delete InstallmentEditHistory entries (via schedule relationship)
        if schedule_ids_list:
            InstallmentEditHistory.query.filter(InstallmentEditHistory.schedule_id.in_(schedule_ids_list)).delete()
        
        # 3. Delete RecurringPaymentSchedule entries
        RecurringPaymentSchedule.query.filter_by(request_id=request_id).delete()
        
        # 4. Delete PaidNotification entries
        PaidNotification.query.filter_by(request_id=request_id).delete()
        
        # 5. Delete LateInstallment entries
        LateInstallment.query.filter_by(request_id=request_id).delete()
        
        # 6. Delete FinanceAdminNote entries
        FinanceAdminNote.query.filter_by(request_id=request_id).delete()
        
        # 7. Delete the PaymentRequest itself (notifications were already handled above)
        db.session.delete(req)
        
        # Commit all deletions
        db.session.commit()
        
        log_action(f"Permanently deleted payment request #{request_id_val} from database")
        
        # Emit real-time notification to IT users after creating database notifications
        if it_users_to_notify:
            try:
                socketio.emit('new_notification', {
                    'title': notification_title,
                    'message': notification_message,
                    'type': 'request_permanently_deleted',
                    'request_id': request_id_val
                }, room='all_users')
                
                socketio.emit('notification_update', {
                    'action': 'new_notification',
                    'type': 'request_permanently_deleted'
                }, room='all_users')
            except Exception as e:
                print(f"DEBUG: Error emitting WebSocket notification: {e}")
        
        # Emit real-time update to remove from all dashboards
        try:
            socketio.emit('request_deleted', {
                'request_id': request_id_val
            }, room='all_users')
        except Exception as e:
            print(f"DEBUG: Error emitting request_deleted event: {e}")
        
        flash(f'Payment request #{request_id_val} has been permanently deleted from the database.', 'success')
        return redirect(url_for('archives'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting request: {str(e)}', 'error')
        app.logger.error(f"Error permanently deleting request #{request_id}: {str(e)}")
        return redirect(url_for('archives'))


# ==================== REQUEST TYPES MANAGEMENT ROUTES ====================

@app.route('/it/request-types')
@login_required
@role_required('IT Staff', 'Department Manager')
def manage_request_types():
    """Manage request types for all departments - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    department_filter = request.args.get('department', '')
    search_query = request.args.get('search', '')
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 20
    
    # Build query
    query = RequestType.query
    
    if department_filter:
        if department_filter == 'Management':
            query = query.filter(RequestType.department.in_(['Management', 'General Manager']))
        else:
            query = query.filter(RequestType.department == department_filter)
    
    if search_query:
        query = query.filter(RequestType.name.contains(search_query))
    
    # Get paginated results
    request_types_pagination = query.order_by(RequestType.id).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    # Get all departments for filter dropdown (normalize legacy values)
    departments = db.session.query(RequestType.department).distinct().all()
    departments = [('Management' if dept[0] == 'General Manager' else dept[0]) for dept in departments]
    
    return render_template('manage_request_types.html',
                         request_types=request_types_pagination.items,
                         pagination=request_types_pagination,
                         departments=departments,
                         department_filter=department_filter,
                         search_query=search_query,
                         user=current_user)


@app.route('/it/request-types/add', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_request_type():
    """Add new request type - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        department = request.form.get('department', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not name or not department:
            flash('Name and department are required.', 'danger')
            return redirect(url_for('add_request_type'))
        
        # Check if request type already exists for this department
        existing = RequestType.query.filter_by(name=name, department=department).first()
        if existing:
            flash(f'Request type "{name}" already exists for {department} department.', 'danger')
            return redirect(url_for('add_request_type'))
        
        try:
            request_type = RequestType(
                name=name,
                department=department,
                is_active=is_active,
                created_by_user_id=current_user.user_id
            )
            
            db.session.add(request_type)
            db.session.commit()
            
            # Log the action
            log_action(f'Added request type: {name} for {department} department')
            
            flash(f'Request type "{name}" added successfully for {department} department.', 'success')
            return redirect(url_for('manage_request_types'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding request type: {str(e)}', 'danger')
            return redirect(url_for('add_request_type'))
    
    # Get all departments for dropdown
    departments = ['Management', 'Finance', 'Operation', 'PR', 'Maintenance', 'Marketing', 
                   'Logistic', 'HR', 'Quality Control', 'Procurement', 'IT', 'Customer Service', 
                   'Project', 'Sales']
    
    return render_template('add_request_type.html', departments=departments, user=current_user)


@app.route('/it/request-types/edit/<int:request_type_id>', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_request_type(request_type_id):
    """Edit request type - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    request_type = RequestType.query.get_or_404(request_type_id)
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        department = request.form.get('department', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not name or not department:
            flash('Name and department are required.', 'danger')
            return redirect(url_for('edit_request_type', request_type_id=request_type_id))
        
        # Check if request type already exists for this department (excluding current one)
        existing = RequestType.query.filter(
            RequestType.name == name,
            RequestType.department == department,
            RequestType.id != request_type_id
        ).first()
        
        if existing:
            flash(f'Request type "{name}" already exists for {department} department.', 'danger')
            return redirect(url_for('edit_request_type', request_type_id=request_type_id))
        
        try:
            old_name = request_type.name
            old_department = request_type.department
            
            request_type.name = name
            request_type.department = department
            request_type.is_active = is_active
            request_type.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Log the action
            log_action(f'Updated request type: {old_name} ({old_department}) to {name} ({department})')
            
            flash(f'Request type updated successfully.', 'success')
            return redirect(url_for('manage_request_types'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating request type: {str(e)}', 'danger')
            return redirect(url_for('edit_request_type', request_type_id=request_type_id))
    
    # Get all departments for dropdown
    departments = ['Management', 'Finance', 'Operation', 'PR', 'Maintenance', 'Marketing', 
                   'Logistic', 'HR', 'Quality Control', 'Procurement', 'IT', 'Customer Service', 
                   'Project', 'Sales']
    
    return render_template('edit_request_type.html', 
                         request_type=request_type, 
                         departments=departments, 
                         user=current_user)


@app.route('/it/request-types/delete/<int:request_type_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_request_type(request_type_id):
    """Delete request type - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    request_type = RequestType.query.get_or_404(request_type_id)
    
    try:
        # Check if any payment requests are using this request type
        existing_requests = PaymentRequest.query.filter_by(request_type=request_type.name).first()
        if existing_requests:
            flash(f'Cannot delete request type "{request_type.name}" because it is being used by existing payment requests.', 'danger')
            return redirect(url_for('it_dashboard', tab='request-types'))
        
        # Log the action before deletion
        log_action(f'Deleted request type: {request_type.name} ({request_type.department})')
        
        db.session.delete(request_type)
        db.session.commit()
        
        flash(f'Request type "{request_type.name}" deleted successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting request type: {str(e)}', 'danger')
    
    # Redirect back to IT dashboard with request-types tab active
    return redirect(url_for('it_dashboard', tab='request-types'))


@app.route('/it/request-types/bulk-delete', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def bulk_delete_request_types():
    """Bulk delete request types - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    request_type_ids = request.form.getlist('request_type_ids')
    
    if not request_type_ids:
        flash('No request types selected for deletion.', 'warning')
        return redirect(url_for('it_dashboard', tab='request-types'))
    
    deleted_count = 0
    failed_deletions = []
    
    try:
        for request_type_id in request_type_ids:
            request_type = RequestType.query.get(request_type_id)
            if not request_type:
                failed_deletions.append(f"Request type with ID {request_type_id} not found")
                continue
            
            # Check if any payment requests are using this request type
            existing_requests = PaymentRequest.query.filter_by(request_type=request_type.name).first()
            if existing_requests:
                failed_deletions.append(f'"{request_type.name}" (used by existing payment requests)')
                continue
            
            # Log the action before deletion
            log_action(f'Bulk deleted request type: {request_type.name} ({request_type.department})')
            
            db.session.delete(request_type)
            deleted_count += 1
        
        if deleted_count > 0:
            db.session.commit()
            flash(f'Successfully deleted {deleted_count} request type(s).', 'success')
        
        if failed_deletions:
            flash(f'Could not delete: {", ".join(failed_deletions)}', 'warning')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error during bulk deletion: {str(e)}', 'danger')
    
    return redirect(url_for('it_dashboard', tab='request-types'))


@app.route('/it/request-types/toggle/<int:request_type_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def toggle_request_type(request_type_id):
    """Toggle request type active status - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    request_type = RequestType.query.get_or_404(request_type_id)
    
    try:
        request_type.is_active = not request_type.is_active
        request_type.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        status = 'activated' if request_type.is_active else 'deactivated'
        log_action(f'{status.title()} request type: {request_type.name} ({request_type.department})')
        
        flash(f'Request type "{request_type.name}" {status} successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating request type: {str(e)}', 'danger')
    
    return redirect(url_for('manage_request_types'))


# ==================== PERSON/COMPANY OPTIONS MANAGEMENT ROUTES ====================

@app.route('/it/person-company-options')
@login_required
@role_required('IT Staff', 'Department Manager')
def manage_person_company_options():
    """Manage person/company name options for all departments - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    department_filter = request.args.get('department', '')
    search_query = request.args.get('search', '')
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 20
    
    # Build query
    query = PersonCompanyOption.query
    
    if department_filter:
        if department_filter == 'Management':
            query = query.filter(PersonCompanyOption.department.in_(['Management', 'General Manager']))
        else:
            query = query.filter(PersonCompanyOption.department == department_filter)
    
    if search_query:
        query = query.filter(PersonCompanyOption.name.contains(search_query))
    
    # Get paginated results
    options_pagination = query.order_by(PersonCompanyOption.id).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    # Get all departments for filter dropdown (normalize legacy values)
    departments = db.session.query(RequestType.department).distinct().all()
    departments = [('Management' if dept[0] == 'General Manager' else dept[0]) for dept in departments]
    
    return render_template('manage_person_company_options.html',
                         options=options_pagination.items,
                         pagination=options_pagination,
                         departments=departments,
                         department_filter=department_filter,
                         search_query=search_query,
                         user=current_user)


@app.route('/it/person-company-options/add', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_person_company_option():
    """Add new person/company name option - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        department = request.form.get('department', '').strip()
        request_type = request.form.get('request_type', '').strip()
        is_active = request.form.get('is_active') == 'on'
        account_name = request.form.get('account_name', '').strip() or None
        account_number = request.form.get('account_number', '').strip() or None
        bank_name = request.form.get('bank_name', '').strip() or None
        description = request.form.get('description', '').strip() or None
        
        if not name or not department or not request_type:
            flash('Name, department, and request type are required.', 'danger')
            return redirect(url_for('add_person_company_option'))
        
        # Check if option already exists for this department and request type combination
        existing = PersonCompanyOption.query.filter_by(
            name=name, 
            department=department, 
            request_type=request_type
        ).first()
        
        if existing:
            flash(f'Person/Company name "{name}" already exists for {department} department and {request_type} request type.', 'danger')
            return redirect(url_for('add_person_company_option'))
        
        try:
            option = PersonCompanyOption(
                name=name,
                department=department,
                request_type=request_type,
                is_active=is_active,
                account_name=account_name,
                account_number=account_number,
                bank_name=bank_name,
                description=description,
                created_by_user_id=current_user.user_id
            )
            
            db.session.add(option)
            db.session.commit()
            
            # Log the action
            log_action(f'Added person/company name option: {name} for {department}/{request_type}')
            
            flash(f'Person/Company name option "{name}" added successfully.', 'success')
            return redirect(url_for('manage_person_company_options'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding person/company name option: {str(e)}', 'danger')
            return redirect(url_for('add_person_company_option'))
    
    # Get all departments and request types for dropdowns
    departments = ['Management', 'Finance', 'Operation', 'PR', 'Maintenance', 'Marketing', 
                   'Logistic', 'HR', 'Quality Control', 'Procurement', 'IT', 'Customer Service', 
                   'Project', 'Sales']
    
    # Get all active request types grouped by department
    request_types_by_dept = {}
    for dept in departments:
        dept_name = 'Management' if dept == 'Management' else dept
        if dept == 'Management':
            types = RequestType.query.filter(
                RequestType.department.in_(['Management', 'General Manager']),
                RequestType.is_active == True
            ).order_by(RequestType.name).all()
        else:
            types = RequestType.query.filter_by(
                department=dept,
                is_active=True
            ).order_by(RequestType.name).all()
        request_types_by_dept[dept] = [rt.name for rt in types]
    
    return render_template('add_person_company_option.html', 
                         departments=departments,
                         request_types_by_dept=request_types_by_dept,
                         user=current_user)


@app.route('/it/person-company-options/edit/<int:option_id>', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_person_company_option(option_id):
    """Edit person/company name option - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    option = PersonCompanyOption.query.get_or_404(option_id)
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        department = request.form.get('department', '').strip()
        request_type = request.form.get('request_type', '').strip()
        is_active = request.form.get('is_active') == 'on'
        account_name = request.form.get('account_name', '').strip() or None
        account_number = request.form.get('account_number', '').strip() or None
        bank_name = request.form.get('bank_name', '').strip() or None
        description = request.form.get('description', '').strip() or None
        
        if not name or not department or not request_type:
            flash('Name, department, and request type are required.', 'danger')
            return redirect(url_for('edit_person_company_option', option_id=option_id))
        
        # Check if option already exists for this department and request type combination (excluding current one)
        existing = PersonCompanyOption.query.filter(
            PersonCompanyOption.name == name,
            PersonCompanyOption.department == department,
            PersonCompanyOption.request_type == request_type,
            PersonCompanyOption.id != option_id
        ).first()
        
        if existing:
            flash(f'Person/Company name "{name}" already exists for {department} department and {request_type} request type.', 'danger')
            return redirect(url_for('edit_person_company_option', option_id=option_id))
        
        try:
            old_name = option.name
            old_department = option.department
            old_request_type = option.request_type
            
            option.name = name
            option.department = department
            option.request_type = request_type
            option.is_active = is_active
            option.account_name = account_name
            option.account_number = account_number
            option.bank_name = bank_name
            option.description = description
            option.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Log the action
            log_action(f'Updated person/company name option: {old_name} ({old_department}/{old_request_type}) to {name} ({department}/{request_type})')
            
            flash(f'Person/Company name option updated successfully.', 'success')
            return redirect(url_for('manage_person_company_options'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating person/company name option: {str(e)}', 'danger')
            return redirect(url_for('edit_person_company_option', option_id=option_id))
    
    # Get all departments and request types for dropdowns
    departments = ['Management', 'Finance', 'Operation', 'PR', 'Maintenance', 'Marketing', 
                   'Logistic', 'HR', 'Quality Control', 'Procurement', 'IT', 'Customer Service', 
                   'Project', 'Sales']
    
    # Get all active request types grouped by department
    request_types_by_dept = {}
    for dept in departments:
        dept_name = 'Management' if dept == 'Management' else dept
        if dept == 'Management':
            types = RequestType.query.filter(
                RequestType.department.in_(['Management', 'General Manager']),
                RequestType.is_active == True
            ).order_by(RequestType.name).all()
        else:
            types = RequestType.query.filter_by(
                department=dept,
                is_active=True
            ).order_by(RequestType.name).all()
        request_types_by_dept[dept] = [rt.name for rt in types]
    
    return render_template('edit_person_company_option.html', 
                         option=option,
                         departments=departments,
                         request_types_by_dept=request_types_by_dept,
                         user=current_user)


@app.route('/it/person-company-options/toggle/<int:option_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def toggle_person_company_option(option_id):
    """Toggle person/company name option active status - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    option = PersonCompanyOption.query.get_or_404(option_id)
    
    try:
        option.is_active = not option.is_active
        option.updated_at = datetime.utcnow()
        db.session.commit()
        
        # Log the action
        status = 'activated' if option.is_active else 'deactivated'
        log_action(f'{status.capitalize()} person/company name option: {option.name} ({option.department}/{option.request_type})')
        
        flash(f'Person/Company name option {status} successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error toggling person/company name option: {str(e)}', 'danger')
    
    return redirect(url_for('manage_person_company_options'))


# Procurement Category and Item Management Routes
@app.route('/it/procurement-categories-items')
@login_required
@role_required('IT Staff', 'Department Manager')
def manage_procurement_categories_items():
    """Manage procurement categories and items for all departments - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    department_filter = request.args.get('department', '')
    search_query = request.args.get('search', '')
    filter_type = request.args.get('filter_type', 'items')  # 'categories' or 'items'
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 20
    
    # Get all departments for filter dropdown
    departments = ['Operation', 'HR', 'IT', 'Finance', 'Maintenance', 'Marketing', 
                   'Logistic', 'Quality Control', 'Procurement', 'Customer Service', 
                   'Project', 'PR', 'Sales']
    
    if filter_type == 'categories':
        # Build query for categories
        query = ProcurementCategory.query
        
        if department_filter:
            query = query.filter(ProcurementCategory.department == department_filter)
        
        if search_query:
            query = query.filter(ProcurementCategory.name.contains(search_query))
        
        # Get paginated results
        items_pagination = query.order_by(ProcurementCategory.id).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        return render_template('manage_procurement_categories_items.html',
                             items=items_pagination.items,
                             pagination=items_pagination,
                             departments=departments,
                             department_filter=department_filter,
                             search_query=search_query,
                             filter_type='categories',
                             user=current_user)
    else:
        # Build query for items
        query = ProcurementItem.query
        
        if department_filter:
            query = query.filter(ProcurementItem.department == department_filter)
        
        if search_query:
            query = query.filter(ProcurementItem.name.contains(search_query))
        
        # Get paginated results
        items_pagination = query.order_by(ProcurementItem.id).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        return render_template('manage_procurement_categories_items.html',
                             items=items_pagination.items,
                             pagination=items_pagination,
                             departments=departments,
                             department_filter=department_filter,
                             search_query=search_query,
                             filter_type='items',
                             user=current_user)


@app.route('/it/procurement-categories/add', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_procurement_category():
    """Add new procurement category - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        department = request.form.get('department', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not name or not department:
            flash('Name and department are required.', 'danger')
            return redirect(url_for('add_procurement_category'))
        
        # Check if category already exists for this department
        existing = ProcurementCategory.query.filter_by(
            name=name, 
            department=department
        ).first()
        
        if existing:
            flash(f'Category "{name}" already exists for {department} department.', 'danger')
            return redirect(url_for('add_procurement_category'))
        
        try:
            category = ProcurementCategory(
                name=name,
                department=department,
                is_active=is_active,
                created_by_user_id=current_user.user_id
            )
            
            db.session.add(category)
            db.session.commit()
            
            # Log the action
            log_action(f'Added procurement category: {name} for {department}')
            
            flash(f'Procurement category "{name}" added successfully.', 'success')
            return redirect(url_for('manage_procurement_categories_items', filter_type='categories'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding procurement category: {str(e)}', 'danger')
            return redirect(url_for('add_procurement_category'))
    
    # Get all departments for dropdown
    departments = ['Operation', 'HR', 'IT', 'Finance', 'Maintenance', 'Marketing', 
                   'Logistic', 'Quality Control', 'Procurement', 'Customer Service', 
                   'Project', 'PR']
    
    return render_template('add_procurement_category.html', 
                         departments=departments,
                         user=current_user)


@app.route('/it/procurement-categories/edit/<int:category_id>', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_procurement_category(category_id):
    """Edit procurement category - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    category = ProcurementCategory.query.get_or_404(category_id)
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        department = request.form.get('department', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not name or not department:
            flash('Name and department are required.', 'danger')
            return redirect(url_for('edit_procurement_category', category_id=category_id))
        
        # Check if category already exists for this department (excluding current one)
        existing = ProcurementCategory.query.filter(
            ProcurementCategory.name == name,
            ProcurementCategory.department == department,
            ProcurementCategory.id != category_id
        ).first()
        
        if existing:
            flash(f'Category "{name}" already exists for {department} department.', 'danger')
            return redirect(url_for('edit_procurement_category', category_id=category_id))
        
        try:
            old_name = category.name
            old_department = category.department
            
            category.name = name
            category.department = department
            category.is_active = is_active
            category.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Log the action
            log_action(f'Updated procurement category: {old_name} ({old_department}) to {name} ({department})')
            
            flash(f'Procurement category updated successfully.', 'success')
            return redirect(url_for('manage_procurement_categories_items', filter_type='categories'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating procurement category: {str(e)}', 'danger')
            return redirect(url_for('edit_procurement_category', category_id=category_id))
    
    # Get all departments for dropdown
    departments = ['Operation', 'HR', 'IT', 'Finance', 'Maintenance', 'Marketing', 
                   'Logistic', 'Quality Control', 'Procurement', 'Customer Service', 
                   'Project', 'PR']
    
    return render_template('edit_procurement_category.html', 
                         category=category,
                         departments=departments,
                         user=current_user)


@app.route('/it/procurement-categories/toggle/<int:category_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def toggle_procurement_category(category_id):
    """Toggle procurement category active status - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    category = ProcurementCategory.query.get_or_404(category_id)
    
    try:
        category.is_active = not category.is_active
        category.updated_at = datetime.utcnow()
        db.session.commit()
        
        # Log the action
        status = 'activated' if category.is_active else 'deactivated'
        log_action(f'{status.capitalize()} procurement category: {category.name} ({category.department})')
        
        flash(f'Procurement category {status} successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error toggling procurement category: {str(e)}', 'danger')
    
    return redirect(url_for('manage_procurement_categories_items', filter_type='categories'))


@app.route('/it/procurement-items/add', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_procurement_item():
    """Add new procurement item - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        category_id = request.form.get('category_id', '').strip()
        department = request.form.get('department', '').strip()
        description = request.form.get('description', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not name or not department or not category_id:
            flash('Name, department, and category are required.', 'danger')
            return redirect(url_for('add_procurement_item'))
        
        # Check if item already exists for this department and category
        existing = ProcurementItem.query.filter_by(
            name=name, 
            department=department,
            category_id=int(category_id)
        ).first()
        
        if existing:
            flash(f'Item "{name}" already exists for {department} department in this category.', 'danger')
            return redirect(url_for('add_procurement_item'))
        
        try:
            item = ProcurementItem(
                name=name,
                category_id=int(category_id),
                department=department,
                description=description if description else None,
                is_active=is_active,
                created_by_user_id=current_user.user_id
            )
            
            db.session.add(item)
            db.session.commit()
            
            # Log the action
            log_action(f'Added procurement item: {name} for {department}')
            
            flash(f'Procurement item "{name}" added successfully.', 'success')
            return redirect(url_for('manage_procurement_categories_items', filter_type='items'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding procurement item: {str(e)}', 'danger')
            return redirect(url_for('add_procurement_item'))
    
    # Get all departments for dropdown
    departments = ['Operation', 'HR', 'IT', 'Finance', 'Maintenance', 'Marketing', 
                   'Logistic', 'Quality Control', 'Procurement', 'Customer Service', 
                   'Project', 'PR']
    
    # Get all active categories for dropdown
    categories = ProcurementCategory.query.filter_by(is_active=True).order_by(ProcurementCategory.department, ProcurementCategory.name).all()
    
    return render_template('add_procurement_item.html', 
                         departments=departments,
                         categories=categories,
                         user=current_user)


@app.route('/it/procurement-items/edit/<int:item_id>', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_procurement_item(item_id):
    """Edit procurement item - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    item = ProcurementItem.query.get_or_404(item_id)
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        category_id = request.form.get('category_id', '').strip()
        department = request.form.get('department', '').strip()
        description = request.form.get('description', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not name or not department or not category_id:
            flash('Name, department, and category are required.', 'danger')
            return redirect(url_for('edit_procurement_item', item_id=item_id))
        
        # Check if item already exists for this department and category (excluding current one)
        existing = ProcurementItem.query.filter(
            ProcurementItem.name == name,
            ProcurementItem.department == department,
            ProcurementItem.category_id == int(category_id),
            ProcurementItem.id != item_id
        ).first()
        
        if existing:
            flash(f'Item "{name}" already exists for {department} department in this category.', 'danger')
            return redirect(url_for('edit_procurement_item', item_id=item_id))
        
        try:
            old_name = item.name
            old_department = item.department
            
            item.name = name
            item.category_id = int(category_id)
            item.department = department
            item.description = description if description else None
            item.is_active = is_active
            item.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Log the action
            log_action(f'Updated procurement item: {old_name} ({old_department}) to {name} ({department})')
            
            flash(f'Procurement item updated successfully.', 'success')
            return redirect(url_for('manage_procurement_categories_items', filter_type='items'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating procurement item: {str(e)}', 'danger')
            return redirect(url_for('edit_procurement_item', item_id=item_id))
    
    # Get all departments for dropdown
    departments = ['Operation', 'HR', 'IT', 'Finance', 'Maintenance', 'Marketing', 
                   'Logistic', 'Quality Control', 'Procurement', 'Customer Service', 
                   'Project', 'PR']
    
    # Get all active categories for dropdown
    categories = ProcurementCategory.query.filter_by(is_active=True).order_by(ProcurementCategory.department, ProcurementCategory.name).all()
    
    return render_template('edit_procurement_item.html', 
                         item=item,
                         departments=departments,
                         categories=categories,
                         user=current_user)


@app.route('/it/procurement-items/toggle/<int:item_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def toggle_procurement_item(item_id):
    """Toggle procurement item active status - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    item = ProcurementItem.query.get_or_404(item_id)
    
    try:
        item.is_active = not item.is_active
        item.updated_at = datetime.utcnow()
        db.session.commit()
        
        # Log the action
        status = 'activated' if item.is_active else 'deactivated'
        log_action(f'{status.capitalize()} procurement item: {item.name} ({item.department})')
        
        flash(f'Procurement item {status} successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error toggling procurement item: {str(e)}', 'danger')
    
    return redirect(url_for('manage_procurement_categories_items', filter_type='items'))


# Branch Management Routes
@app.route('/it/branches')
@login_required
@role_required('IT Staff', 'Department Manager')
def manage_branches():
    """Manage branches - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    search_query = request.args.get('search', '')
    restaurant_filter = request.args.get('restaurant', '')
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 20
    
    # Build query
    query = Branch.query
    
    if search_query:
        query = query.filter(Branch.name.contains(search_query))
    
    if restaurant_filter:
        query = query.filter(Branch.restaurant == restaurant_filter)
    
    # Get paginated results
    branches_pagination = query.order_by(Branch.id).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('manage_branches.html',
                         branches=branches_pagination.items,
                         pagination=branches_pagination,
                         search_query=search_query,
                         restaurant_filter=restaurant_filter,
                         user=current_user)


@app.route('/it/branches/add', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_branch():
    """Add new branch - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        restaurant = request.form.get('restaurant', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not restaurant:
            flash('Location is required.', 'danger')
            return redirect(url_for('add_branch'))
        
        if not name:
            flash('Name is required.', 'danger')
            return redirect(url_for('add_branch'))
        
        # Check if branch already exists
        existing = Branch.query.filter_by(name=name).first()
        if existing:
            flash(f'Branch "{name}" already exists.', 'danger')
            return redirect(url_for('add_branch'))
        
        try:
            branch = Branch(
                name=name,
                restaurant=restaurant,
                is_active=is_active,
                created_by_user_id=current_user.user_id
            )
            
            db.session.add(branch)
            db.session.commit()
            
            # Log the action
            log_action(f'Added branch: {name}')
            
            flash(f'Branch "{name}" added successfully.', 'success')
            return redirect(url_for('manage_branches'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding branch: {str(e)}', 'danger')
            return redirect(url_for('add_branch'))
    
    # Get all available locations from LocationPriority (show all locations in dropdown)
    available_locations = get_location_priorities()
    # Also get any locations that exist in branches but don't have a priority entry yet
    all_branch_locations = get_all_locations()
    existing_location_names = {lp.location_name for lp in available_locations}
    unprioritized_locations = [loc for loc in all_branch_locations if loc not in existing_location_names]
    
    return render_template('add_branch.html', user=current_user, available_locations=available_locations, unprioritized_locations=unprioritized_locations)


@app.route('/it/branches/edit/<int:branch_id>', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_branch(branch_id):
    """Edit branch - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    branch = Branch.query.get_or_404(branch_id)
    
    if request.method == 'POST':
        name = request.form.get('name', '').strip()
        restaurant = request.form.get('restaurant', '').strip()
        is_active = request.form.get('is_active') == 'on'
        
        if not restaurant:
            flash('Location is required.', 'danger')
            return redirect(url_for('edit_branch', branch_id=branch_id))
        
        if not name:
            flash('Name is required.', 'danger')
            return redirect(url_for('edit_branch', branch_id=branch_id))
        
        # Check if another branch with same name exists
        existing = Branch.query.filter(Branch.name == name, Branch.id != branch_id).first()
        if existing:
            flash(f'Branch "{name}" already exists.', 'danger')
            return redirect(url_for('edit_branch', branch_id=branch_id))
        
        try:
            old_name = branch.name
            old_restaurant = branch.restaurant
            
            branch.name = name
            branch.restaurant = restaurant
            branch.is_active = is_active
            branch.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            # Log the action
            log_action(f'Updated branch: {old_name} ({old_restaurant}) -> {name} ({restaurant})')
            
            flash(f'Branch "{name}" updated successfully.', 'success')
            return redirect(url_for('manage_branches'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating branch: {str(e)}', 'danger')
            return redirect(url_for('edit_branch', branch_id=branch_id))
    
    # Get all available locations from LocationPriority (show all locations in dropdown)
    available_locations = get_location_priorities()
    # Also get any locations that exist in branches but don't have a priority entry yet
    all_branch_locations = get_all_locations()
    existing_location_names = {lp.location_name for lp in available_locations}
    unprioritized_locations = [loc for loc in all_branch_locations if loc not in existing_location_names]
    
    return render_template('edit_branch.html', branch=branch, user=current_user, available_locations=available_locations, unprioritized_locations=unprioritized_locations)


@app.route('/it/branches/<int:branch_id>/aliases/add', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_branch_alias(branch_id):
    """Add an alias name for a branch"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to perform this action.', 'danger')
        return redirect(url_for('dashboard'))

    branch = Branch.query.get_or_404(branch_id)
    alias_name = (request.form.get('alias_name') or '').strip()
    if not alias_name:
        flash('Alias name is required.', 'danger')
        return redirect(url_for('edit_branch', branch_id=branch_id))

    # Prevent duplicate alias for the same branch or alias equal to current name
    existing = BranchAlias.query.filter(
        db.func.lower(BranchAlias.alias_name) == alias_name.lower(),
        BranchAlias.branch_id == branch_id
    ).first()
    if existing or alias_name.lower() == (branch.name or '').lower():
        flash('This alias already exists or matches the current branch name.', 'warning')
        return redirect(url_for('edit_branch', branch_id=branch_id))

    try:
        new_alias = BranchAlias(branch_id=branch_id, alias_name=alias_name)
        db.session.add(new_alias)
        db.session.commit()
        log_action(f'Added alias "{alias_name}" for branch {branch.name} (ID {branch.id})')
        flash('Alias added successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error adding alias: {str(e)}', 'danger')

    return redirect(url_for('edit_branch', branch_id=branch_id))


@app.route('/it/branches/<int:branch_id>/aliases/<int:alias_id>/delete', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_branch_alias(branch_id, alias_id):
    """Delete an alias from a branch"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to perform this action.', 'danger')
        return redirect(url_for('dashboard'))

    alias = BranchAlias.query.get_or_404(alias_id)
    if alias.branch_id != branch_id:
        flash('Alias does not belong to the specified branch.', 'danger')
        return redirect(url_for('edit_branch', branch_id=branch_id))

    try:
        db.session.delete(alias)
        db.session.commit()
        log_action(f'Deleted alias "{alias.alias_name}" from branch ID {branch_id}')
        flash('Alias deleted successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting alias: {str(e)}', 'danger')

    return redirect(url_for('edit_branch', branch_id=branch_id))

@app.route('/it/branches/delete/<int:branch_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_branch(branch_id):
    """Delete branch - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    branch = Branch.query.get_or_404(branch_id)
    
    try:
        branch_name = branch.name
        db.session.delete(branch)
        db.session.commit()
        
        # Log the action
        log_action(f'Deleted branch: {branch_name}')
        
        flash(f'Branch "{branch_name}" deleted successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting branch: {str(e)}', 'danger')
    
    return redirect(url_for('manage_branches'))


@app.route('/it/branches/bulk-delete', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def bulk_delete_branches():
    """Bulk delete branches - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    branch_ids = request.form.getlist('branch_ids')
    
    if not branch_ids:
        flash('No branches selected for deletion.', 'warning')
        return redirect(url_for('manage_branches'))
    
    try:
        deleted_count = 0
        for branch_id in branch_ids:
            branch = Branch.query.get(branch_id)
            if branch:
                db.session.delete(branch)
                deleted_count += 1
        
        db.session.commit()
        
        # Log the action
        log_action(f'Bulk deleted {deleted_count} branches')
        
        flash(f'{deleted_count} branch(es) deleted successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting branches: {str(e)}', 'danger')
    
    return redirect(url_for('manage_branches'))


@app.route('/it/branches/toggle/<int:branch_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def toggle_branch(branch_id):
    """Toggle branch active status - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    branch = Branch.query.get_or_404(branch_id)
    
    try:
        branch.is_active = not branch.is_active
        branch.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        status = 'activated' if branch.is_active else 'deactivated'
        log_action(f'{status.title()} branch: {branch.name}')
        
        flash(f'Branch "{branch.name}" {status} successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error updating branch: {str(e)}', 'danger')
    
    return redirect(url_for('manage_branches'))


# ==================== LOCATION PRIORITY MANAGEMENT ROUTES ====================

def get_location_priorities():
    """Helper function to get location priorities ordered by priority (for filters - includes all locations)"""
    return LocationPriority.query.order_by(LocationPriority.priority, LocationPriority.location_name).all()

def get_active_location_priorities():
    """Helper function to get only active location priorities ordered by priority"""
    return LocationPriority.query.filter_by(is_active=True).order_by(LocationPriority.priority, LocationPriority.location_name).all()

def get_all_locations():
    """Helper function to get all unique location names from branches"""
    locations = db.session.query(Branch.restaurant).distinct().all()
    return [loc[0] for loc in locations]

def get_branches_ordered_by_location():
    """Helper function to get branches ordered by location priority from database"""
    from sqlalchemy import case
    
    # Get all location priorities from database
    location_priorities = LocationPriority.query.filter_by(is_active=True).all()
    
    # Build a mapping of location name to priority
    location_priority_map = {lp.location_name: lp.priority for lp in location_priorities}
    
    # Get the maximum priority to use as default for locations without priority
    max_priority = max([lp.priority for lp in location_priorities] + [999]) if location_priorities else 999
    
    # Build CASE statement dynamically
    when_conditions = []
    for location_name, priority in location_priority_map.items():
        when_conditions.append((Branch.restaurant == location_name, priority))
    
    # If we have priorities, use them; otherwise fall back to alphabetical
    if when_conditions:
        # Build case statement with proper syntax - unpack when_conditions as *args
        location_order = case(*when_conditions, else_=max_priority + 1)
        return Branch.query.filter_by(is_active=True).order_by(location_order, Branch.name).all()
    else:
        # Fallback: if no priorities exist, order alphabetically by restaurant then name
        return Branch.query.filter_by(is_active=True).order_by(Branch.restaurant, Branch.name).all()

def shift_location_priorities(new_priority, exclude_location_id=None):
    """
    Shift all locations with priority >= new_priority down by 1.
    Used when adding/editing a location to insert it at a specific priority.
    
    Args:
        new_priority: The priority value to insert at
        exclude_location_id: Location ID to exclude from shifting (for edit operations)
    """
    # Get all locations with priority >= new_priority
    # Exclude the location being edited if provided
    query = LocationPriority.query.filter(LocationPriority.priority >= new_priority)
    if exclude_location_id:
        query = query.filter(LocationPriority.id != exclude_location_id)
    
    locations_to_shift = query.order_by(LocationPriority.priority.desc()).all()
    
    # Shift each location down by 1 (increase priority by 1)
    for location in locations_to_shift:
        location.priority += 1
        location.updated_at = datetime.utcnow()
    
    return len(locations_to_shift)

@app.route('/it/locations')
@login_required
@role_required('IT Staff', 'Department Manager')
def manage_locations():
    """Manage location priorities - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    # Get all location priorities
    location_priorities = LocationPriority.query.order_by(LocationPriority.priority, LocationPriority.location_name).all()
    
    # Get all unique locations from branches that don't have a priority entry yet
    existing_location_names = {lp.location_name for lp in location_priorities}
    all_branch_locations = get_all_locations()
    unprioritized_locations = [loc for loc in all_branch_locations if loc not in existing_location_names]
    
    return render_template('manage_locations.html',
                         location_priorities=location_priorities,
                         unprioritized_locations=unprioritized_locations,
                         user=current_user)


@app.route('/it/locations/add', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def add_location():
    """Add new location priority - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        location_name = request.form.get('location_name', '').strip()
        priority = request.form.get('priority', type=int)
        # Default to active=True so new locations appear in filters immediately
        is_active = request.form.get('is_active', 'on') == 'on'
        
        if not location_name:
            flash('Location name is required.', 'danger')
            return redirect(url_for('add_location'))
        
        if priority is None:
            flash('Priority is required.', 'danger')
            return redirect(url_for('add_location'))
        
        # Check if location already exists
        existing = LocationPriority.query.filter_by(location_name=location_name).first()
        if existing:
            flash(f'Location "{location_name}" already exists. Please edit the existing entry instead.', 'danger')
            return redirect(url_for('manage_locations'))
        
        try:
            # Check if priority already exists - if so, shift existing locations down
            priority_exists = LocationPriority.query.filter_by(priority=priority).first()
            if priority_exists:
                shifted_count = shift_location_priorities(priority)
                if shifted_count > 0:
                    log_action(f'Shifted {shifted_count} location priority/priorities down to make room for new location at priority {priority}')
            
            location_priority = LocationPriority(
                location_name=location_name,
                priority=priority,
                is_active=is_active,
                created_by_user_id=current_user.user_id
            )
            
            db.session.add(location_priority)
            db.session.commit()
            
            log_action(f'Added location priority: {location_name} (priority={priority})')
            
            if priority_exists:
                flash(f'Location "{location_name}" added successfully with priority {priority}. {shifted_count} existing location(s) were shifted down.', 'success')
            else:
                flash(f'Location "{location_name}" added successfully with priority {priority}.', 'success')
            return redirect(url_for('manage_locations'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding location: {str(e)}', 'danger')
            return redirect(url_for('add_location'))
    
    # Get the next available priority (highest priority + 1)
    max_priority = db.session.query(db.func.max(LocationPriority.priority)).scalar()
    next_priority = (max_priority or 0) + 1
    
    return render_template('add_location.html', user=current_user, next_priority=next_priority)


@app.route('/it/locations/edit/<int:location_id>', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_location(location_id):
    """Edit location priority - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    location_priority = LocationPriority.query.get_or_404(location_id)
    
    if request.method == 'POST':
        location_name = request.form.get('location_name', '').strip()
        priority = request.form.get('priority', type=int)
        is_active = request.form.get('is_active') == 'on'
        
        if not location_name:
            flash('Location name is required.', 'danger')
            return redirect(url_for('edit_location', location_id=location_id))
        
        if priority is None:
            flash('Priority is required.', 'danger')
            return redirect(url_for('edit_location', location_id=location_id))
        
        # Check if another location with same name exists
        existing = LocationPriority.query.filter(
            LocationPriority.location_name == location_name,
            LocationPriority.id != location_id
        ).first()
        if existing:
            flash(f'Location "{location_name}" already exists.', 'danger')
            return redirect(url_for('edit_location', location_id=location_id))
        
        try:
            old_name = location_priority.location_name
            old_priority = location_priority.priority
            
            # If priority is changing, shift priorities accordingly
            if priority != old_priority:
                if priority < old_priority:
                    # Moving to a lower priority number (e.g., 5 -> 1)
                    # Shift locations between new and old priority up by 1 (1,2,3,4 -> 2,3,4,5)
                    locations_to_shift = LocationPriority.query.filter(
                        LocationPriority.priority >= priority,
                        LocationPriority.priority < old_priority,
                        LocationPriority.id != location_id
                    ).all()
                    
                    for location in locations_to_shift:
                        location.priority += 1
                        location.updated_at = datetime.utcnow()
                    
                    if locations_to_shift:
                        log_action(f'Shifted {len(locations_to_shift)} location priority/priorities up to make room for location at priority {priority}')
                else:
                    # Moving to a higher priority number (e.g., 1 -> 5)
                    # Shift locations between old and new priority down by 1 (2,3,4,5 -> 1,2,3,4)
                    locations_to_shift = LocationPriority.query.filter(
                        LocationPriority.priority > old_priority,
                        LocationPriority.priority <= priority,
                        LocationPriority.id != location_id
                    ).all()
                    
                    for location in locations_to_shift:
                        location.priority -= 1
                        location.updated_at = datetime.utcnow()
                    
                    if locations_to_shift:
                        log_action(f'Shifted {len(locations_to_shift)} location priority/priorities down to make room for location at priority {priority}')
            
            location_priority.location_name = location_name
            location_priority.priority = priority
            location_priority.is_active = is_active
            location_priority.updated_at = datetime.utcnow()
            
            db.session.commit()
            
            log_action(f'Updated location priority: {old_name} (priority {old_priority}) -> {location_name} (priority {priority})')
            
            if priority != old_priority:
                flash(f'Location "{location_name}" updated successfully. Priorities have been adjusted.', 'success')
            else:
                flash(f'Location "{location_name}" updated successfully.', 'success')
            return redirect(url_for('manage_locations'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating location: {str(e)}', 'danger')
            return redirect(url_for('edit_location', location_id=location_id))
    
    return render_template('edit_location.html', location_priority=location_priority, user=current_user)


@app.route('/it/locations/delete/<int:location_id>', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_location(location_id):
    """Delete location priority - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    location_priority = LocationPriority.query.get_or_404(location_id)
    
    # Check if any branches are using this location
    branches_using_location = Branch.query.filter_by(restaurant=location_priority.location_name).count()
    if branches_using_location > 0:
        flash(f'Cannot delete location "{location_priority.location_name}" because {branches_using_location} branch(es) are using it. Please update or delete those branches first.', 'danger')
        return redirect(url_for('manage_locations'))
    
    try:
        location_name = location_priority.location_name
        db.session.delete(location_priority)
        db.session.commit()
        
        log_action(f'Deleted location priority: {location_name}')
        
        flash(f'Location "{location_name}" deleted successfully.', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting location: {str(e)}', 'danger')
    
    return redirect(url_for('manage_locations'))


@app.route('/it/locations/reorder', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def reorder_locations():
    """Reorder location priorities via AJAX - IT only"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        return jsonify({'error': 'Permission denied'}), 403
    
    try:
        data = request.get_json()
        location_orders = data.get('orders', [])  # List of {id: int, priority: int}
        
        for order_item in location_orders:
            location_id = order_item.get('id')
            new_priority = order_item.get('priority')
            
            if location_id and new_priority is not None:
                location = LocationPriority.query.get(location_id)
                if location:
                    location.priority = new_priority
                    location.updated_at = datetime.utcnow()
        
        db.session.commit()
        log_action('Reordered location priorities')
        
        return jsonify({'success': True, 'message': 'Location priorities updated successfully'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 400


@app.route('/it/backup-database')
@login_required
@role_required('IT Staff', 'Department Manager')
def backup_database():
    """Create a backup of the database and download it"""
    try:
        # Restrict Department Managers to IT department only
        if current_user.role == 'Department Manager' and current_user.department != 'IT':
            flash('You do not have permission to perform this action.', 'danger')
            return redirect(url_for('dashboard'))
        
        # Get the database path directly from config
        from config import Config
        db_path = Config._DB_PATH
        
        # Check if database file exists
        if not os.path.exists(db_path):
            flash(f'Database file not found at: {db_path}', 'danger')
            return redirect(url_for('it_dashboard'))
        
        # Create backups directory if it doesn't exist (same directory as database)
        backups_dir = os.path.join(os.path.dirname(db_path), 'backups')
        os.makedirs(backups_dir, exist_ok=True)
        
        # Generate backup filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_filename = f'payment_system_backup_{timestamp}.db'
        backup_path = os.path.join(backups_dir, backup_filename)
        
        # Copy the database file using shutil
        import shutil
        shutil.copy2(db_path, backup_path)
        
        # Verify backup was created
        if not os.path.exists(backup_path):
            flash('Failed to create backup file.', 'danger')
            return redirect(url_for('it_dashboard'))
        
        # Log the backup action
        log_action(f"Database backup created: {backup_filename}")
        
        # Send the backup file for download
        return send_file(
            backup_path,
            as_attachment=True,
            download_name=backup_filename,
            mimetype='application/x-sqlite3'
        )
        
    except Exception as e:
        import traceback
        error_msg = f'Error creating backup: {str(e)}'
        print(f"Backup error: {error_msg}")
        print(traceback.format_exc())
        flash(error_msg, 'danger')
        try:
            log_action(f"Database backup failed: {str(e)}")
        except:
            pass
        return redirect(url_for('it_dashboard'))


@app.route('/project/dashboard')
@login_required
@role_required('Project Staff', 'Department Manager')
def project_dashboard():
    """Dashboard for project users - can request payments and view due dates"""
    # Ensure only Project department users can access this dashboard
    if current_user.role == 'Department Manager' and current_user.department != 'Project':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('department_dashboard'))
    
    # Check for recurring payments due today
    check_recurring_payments_due()
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    status_filter = request.args.get('status', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    tab = request.args.get('tab', 'all')  # 'all' tab shows all requests
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query with optional status and search filters
    # Exclude archived requests from all queries
    if current_user.role == 'Project Staff':
        # Project Staff see only their own requests
        query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
    elif current_user.role == 'Department Manager' and current_user.department == 'Project':
        # Project Manager sees all requests from Project department
        # plus any request where they are the temporary manager
        # plus any request where they are an authorized manager approver (even if department changed)
        user_dept = 'Project'
        
        # First, get all non-archived requests to check for authorized approver status
        all_non_archived = PaymentRequest.query.filter(
            PaymentRequest.is_archived == False
        ).all()
        
        # Find requests where user is an authorized approver (handles cases where department was edited)
        authorized_request_ids = set()
        department_match_ids = set()
        temp_manager_ids = set()
        
        for req in all_non_archived:
            # Check if requestor's department matches (this ensures we only show requests from their department)
            requestor_dept = (req.user.department or '').strip() if req.user else ''
            req_dept = (req.department or '').strip()
            
            # Only include if BOTH request department AND requestor's department match
            # This prevents showing requests where department was changed but requestor is from different department
            if req_dept.lower() == user_dept.lower() and requestor_dept.lower() == user_dept.lower():
                department_match_ids.add(req.request_id)
            
            # Check temporary manager
            if req.temporary_manager_id == current_user.user_id:
                temp_manager_ids.add(req.request_id)
            
            # Check if user is an authorized approver (based on requestor, not request department)
            authorized_approvers = get_authorized_manager_approvers(req)
            if current_user in authorized_approvers:
                authorized_request_ids.add(req.request_id)
        
        # Combine all request IDs
        all_visible_ids = department_match_ids | temp_manager_ids | authorized_request_ids
        
        # Build query with all visible request IDs
        if all_visible_ids:
            query = PaymentRequest.query.filter(
                PaymentRequest.request_id.in_(all_visible_ids),
                PaymentRequest.is_archived == False
            )
        else:
            # No requests visible - return empty query
            query = PaymentRequest.query.filter(
                PaymentRequest.request_id == -1  # Impossible condition
            )
    else:
        # Fallback - should not happen due to role_required decorator
        query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
    # Only apply status_filter for non-all tabs (All Requests tab shows all statuses)
    if status_filter and tab != 'all':
        query = query.filter(PaymentRequest.status == status_filter)
    if search_query:
        # Search by request ID or requestor name
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search by requestor name or other text fields
            search_term = f'%{search_query}%'
            query = query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = query.filter(PaymentRequest.status.in_(['Completed', 'Paid', 'Approved']))
    elif tab == 'rejected':
        query = query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'all':
        # 'all' tab (All Requests) shows all requests (no additional filtering)
        pass
    # Default case also shows all requests
    
    # Get paginated requests
    # For 'all' tab, sort by status priority then by date (Completed by completion_date, others by created_at)
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    # Get notifications for project users (only due date notifications)
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get separate queries for completed, rejected, and recurring requests for tab content
    # Exclude archived requests from all queries
    if current_user.role == 'Project Staff':
        # Project Staff see only their own requests
        completed_query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
        rejected_query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
        recurring_query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
    elif current_user.role == 'Department Manager' and current_user.department == 'Project':
        # Project Manager sees all requests from Project department
        # plus any request where they are the temporary manager
        # plus any request where they are an authorized manager approver (even if department changed)
        user_dept = 'Project'
        
        # Get all non-archived requests to check for authorized approver status
        all_non_archived = PaymentRequest.query.filter(
            PaymentRequest.is_archived == False
        ).all()
        
        # Find requests where user is an authorized approver (handles cases where department was edited)
        authorized_request_ids = set()
        department_match_ids = set()
        temp_manager_ids = set()
        
        for req in all_non_archived:
            # Check if requestor's department matches (this ensures we only show requests from their department)
            requestor_dept = (req.user.department or '').strip() if req.user else ''
            req_dept = (req.department or '').strip()
            
            # Only include if BOTH request department AND requestor's department match
            # This prevents showing requests where department was changed but requestor is from different department
            if req_dept.lower() == user_dept.lower() and requestor_dept.lower() == user_dept.lower():
                department_match_ids.add(req.request_id)
            
            # Check temporary manager
            if req.temporary_manager_id == current_user.user_id:
                temp_manager_ids.add(req.request_id)
            
            # Check if user is an authorized approver (based on requestor, not request department)
            authorized_approvers = get_authorized_manager_approvers(req)
            if current_user in authorized_approvers:
                authorized_request_ids.add(req.request_id)
        
        # Combine all request IDs
        all_visible_ids = department_match_ids | temp_manager_ids | authorized_request_ids
        
        # Build queries with all visible request IDs
        if all_visible_ids:
            completed_query = PaymentRequest.query.filter(
                PaymentRequest.request_id.in_(all_visible_ids),
                PaymentRequest.is_archived == False
            )
            rejected_query = PaymentRequest.query.filter(
                PaymentRequest.request_id.in_(all_visible_ids),
                PaymentRequest.is_archived == False
            )
            recurring_query = PaymentRequest.query.filter(
                PaymentRequest.request_id.in_(all_visible_ids),
                PaymentRequest.is_archived == False
            )
        else:
            # No requests visible - return empty queries
            completed_query = PaymentRequest.query.filter(
                PaymentRequest.request_id == -1  # Impossible condition
            )
            rejected_query = PaymentRequest.query.filter(
                PaymentRequest.request_id == -1  # Impossible condition
            )
            recurring_query = PaymentRequest.query.filter(
                PaymentRequest.request_id == -1  # Impossible condition
            )
    else:
        # Fallback - should not happen due to role_required decorator
        completed_query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
        rejected_query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
        recurring_query = PaymentRequest.query.filter(
            PaymentRequest.user_id == current_user.user_id,
            PaymentRequest.is_archived == False
        )
    
    completed_query = completed_query.filter(PaymentRequest.status == 'Completed')
    rejected_query = rejected_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    recurring_query = recurring_query.filter(PaymentRequest.recurring == 'Recurring')
    
    completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    rejected_requests = rejected_query.order_by(PaymentRequest.created_at.desc()).all()
    recurring_requests = recurring_query.order_by(PaymentRequest.created_at.desc()).all()
    
    return render_template('project_dashboard.html', 
                         requests=requests_pagination.items, 
                         pagination=requests_pagination,
                         user=current_user,
                         notifications=notifications,
                         unread_count=unread_count,
                         status_filter=status_filter,
                         search_query=search_query,
                         urgent_filter=urgent_filter,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         recurring_requests=recurring_requests,
                         active_tab=tab)


@app.route('/operation/dashboard')
@login_required
@role_required('Operation Manager')
def operation_dashboard():
    """Dashboard for operation manager - can view all requests but only in dashboard"""
    # Check for recurring payments due today
    check_recurring_payments_due()
    
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    status_filter = request.args.get('status', None)
    department_filter = request.args.get('department', None)
    search_query = request.args.get('search', None)
    urgent_filter = request.args.get('urgent', None)
    tab = request.args.get('tab', 'all')  # 'all' tab shows all requests
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query with optional status, department, and search filters - Operation Manager sees ALL departments
    # Exclude archived requests and drafts
    query = PaymentRequest.query.filter(
        PaymentRequest.is_archived == False,
        PaymentRequest.is_draft == False
    )
    
    if department_filter:
        query = query.filter(PaymentRequest.department == department_filter)
    if search_query:
        # Search by request ID or requestor name
        try:
            # Try to convert to integer for exact match
            search_id = int(search_query)
            query = query.filter(PaymentRequest.request_id == search_id)
        except ValueError:
            # If not a number, search by requestor name or other text fields
            search_term = f'%{search_query}%'
            query = query.filter(
                db.or_(
                    PaymentRequest.requestor_name.ilike(search_term),
                    PaymentRequest.purpose.ilike(search_term),
                    PaymentRequest.account_name.ilike(search_term)
                )
            )
    if urgent_filter:
        if urgent_filter == 'urgent':
            query = query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            query = query.filter(PaymentRequest.is_urgent == False)
    
    # Apply tab-based filtering
    if tab == 'completed':
        query = query.filter(PaymentRequest.status.in_(['Completed', 'Paid', 'Approved']))
    elif tab == 'rejected':
        query = query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    elif tab == 'recurring':
        query = query.filter(PaymentRequest.recurring == 'Recurring')
    elif tab == 'my_requests':
        # For 'my_requests' tab, show only the current user's requests
        query = query.filter(PaymentRequest.user_id == current_user.user_id)
    elif tab == 'all':
        # 'all' tab - apply status filter if provided (only on all tab)
        if status_filter:
            query = query.filter(PaymentRequest.status == status_filter)
    
    # Get paginated requests
    # For 'all' tab, sort by status priority then by per-status recency
    if tab == 'all':
        requests_pagination = query.order_by(
            get_status_priority_order(),
            get_all_tab_datetime_order()
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'completed':
        requests_pagination = query.order_by(get_completed_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'rejected':
        requests_pagination = query.order_by(get_rejected_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    elif tab == 'recurring':
        requests_pagination = query.order_by(get_recurring_datetime_order()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    else:
        requests_pagination = query.order_by(PaymentRequest.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
    
    # Get notifications for operation manager (all notifications, same as admin)
    notifications = get_notifications_for_user(current_user)
    unread_count = get_unread_count_for_user(current_user)
    
    # Get separate queries for completed and rejected requests for tab content (exclude archived)
    completed_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    rejected_query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    
    if department_filter:
        completed_query = completed_query.filter(PaymentRequest.department == department_filter)
        rejected_query = rejected_query.filter(PaymentRequest.department == department_filter)
    
    completed_query = completed_query.filter(PaymentRequest.status == 'Completed')
    rejected_query = rejected_query.filter(PaymentRequest.status.in_(['Rejected by Manager', 'Rejected by Finance', 'Proof Rejected']))
    
    completed_requests = completed_query.order_by(get_completed_datetime_order()).all()
    rejected_requests = rejected_query.order_by(get_rejected_datetime_order()).all()
    
    # Get user's own requests for the My Requests tab (exclude archived)
    my_requests_query = PaymentRequest.query.filter(
        PaymentRequest.user_id == current_user.user_id,
        PaymentRequest.is_archived == False
    )
    # Apply department filter to my_requests_query
    if department_filter:
        my_requests_query = my_requests_query.filter(PaymentRequest.department == department_filter)
    # Apply urgent filter to my_requests_query
    if urgent_filter:
        if urgent_filter == 'urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == True)
        elif urgent_filter == 'not_urgent':
            my_requests_query = my_requests_query.filter(PaymentRequest.is_urgent == False)
    my_requests_pagination = my_requests_query.order_by(PaymentRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('operation_dashboard.html', 
                         requests=requests_pagination.items, 
                         pagination=requests_pagination,
                         my_pagination=my_requests_pagination,
                         user=current_user,
                         notifications=notifications,
                         unread_count=unread_count,
                         status_filter=status_filter,
                         department_filter=department_filter,
                         search_query=search_query,
                         urgent_filter=urgent_filter,
                         completed_requests=completed_requests,
                         rejected_requests=rejected_requests,
                         my_requests=my_requests_pagination.items,
                         active_tab=tab)


# ==================== PAYMENT REQUEST ROUTES ====================

def draft_to_dict(draft):
    """Helper function to convert draft PaymentRequest object to dictionary for JSON serialization"""
    if not draft:
        return None
    import json
    # Parse receipt paths if they exist
    receipt_paths = []
    if draft.requestor_receipt_path:
        try:
            receipt_paths = json.loads(draft.requestor_receipt_path)
            if not isinstance(receipt_paths, list):
                receipt_paths = [draft.requestor_receipt_path] if draft.requestor_receipt_path else []
        except:
            receipt_paths = [draft.requestor_receipt_path] if draft.requestor_receipt_path else []
    
    return {
        'request_id': draft.request_id,
        'request_type': draft.request_type,
        'requestor_name': draft.requestor_name,
        'branch_name': draft.branch_name,
        'purpose': draft.purpose,
        'payment_method': draft.payment_method or 'Card',
        'account_name': draft.account_name,
        'account_number': draft.account_number,
        'bank_name': draft.bank_name,
        'amount': float(draft.amount) if draft.amount else None,
        'recurring': draft.recurring,
        'recurring_interval': draft.recurring_interval,
        'person_company': draft.person_company,
        'requestor_receipt_path': receipt_paths
    }

def get_available_request_types():
    """Helper function to get available request types for the current user"""
    # Get user's department and role
    user_department = current_user.department
    user_role = current_user.role
    
    # Query request types based on user's department and role
    if user_role in ['GM', 'CEO']:
        # Management roles see request types under the Management department
        return RequestType.query.filter(
            RequestType.department == 'Management',
            RequestType.is_active == True
        ).order_by(RequestType.id).all()
    elif user_role in ['Finance Admin', 'Finance Staff']:
        # Finance users can see Finance department request types
        return RequestType.query.filter(
            RequestType.department == 'Finance',
            RequestType.is_active == True
        ).order_by(RequestType.id).all()
    elif user_role == 'Operation Manager':
        # Operation Manager can see Operation and Project request types
        return RequestType.query.filter(
            RequestType.department.in_(['Operation', 'Project']),
            RequestType.is_active == True
        ).order_by(RequestType.id).all()
    elif user_role == 'Project Staff':
        # Project Staff can see Project request types
        return RequestType.query.filter(
            RequestType.department == 'Project',
            RequestType.is_active == True
        ).order_by(RequestType.id).all()
    elif user_role == 'Department Manager':
        # Department Managers can see their department's request types
        return RequestType.query.filter(
            RequestType.department == user_department,
            RequestType.is_active == True
        ).order_by(RequestType.id).all()
    else:
        # Other staff roles can see their department's request types
        return RequestType.query.filter(
            RequestType.department == user_department,
            RequestType.is_active == True
        ).order_by(RequestType.id).all()

@app.route('/request/new', methods=['GET', 'POST'])
@login_required
def new_request():
    """Create a new payment request"""
    if request.method == 'POST':
        # Check if this is a draft save
        is_draft = request.form.get('save_as_draft') == 'true'
        
        request_type = request.form.get('request_type')
        requestor_name = request.form.get('requestor_name')
        # Check for multiple branch names first (new format), then fall back to single branch_name (backward compatibility)
        branch_names = request.form.get('branch_names', '').strip()
        branch_name = request.form.get('branch_name', '').strip()
        # Use branch_names if available, otherwise use branch_name
        if branch_names:
            branch_name = branch_names
        date = datetime.utcnow().date()  # Automatically use today's date
        purpose = request.form.get('purpose')
        payment_method = request.form.get('payment_method', 'Card')  # Default to Card
        
        # For drafts, skip validation - allow saving incomplete forms
        if not is_draft:
            # Validate required fields only for submitted requests
            if not branch_name:
                flash('At least one branch name is required.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches)
        account_name = request.form.get('account_name')
        account_number = request.form.get('account_number')
        # Clear account_number if payment method is Cheque or Cash
        if payment_method == 'Cheque' or payment_method == 'Cash':
            account_number = ''
        bank_name = request.form.get('bank_name')
        amount = request.form.get('amount')
        recurring = request.form.get('recurring', 'One-Time')
        recurring_interval = request.form.get('recurring_interval')
        
        # Skip validation for drafts - allow saving incomplete forms
        if not is_draft:
            # Validate account number only if payment method is Card
            if payment_method == 'Card':
                if not account_number:
                    flash('Account number is required when payment method is Card.', 'error')
                    available_request_types = get_available_request_types()
                    available_branches = get_branches_ordered_by_location()
                    return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches)
            
            # Validate account number length (maximum 16 digits) - only if payment method is Card
            if payment_method == 'Card' and account_number and len(account_number) > 16:
                flash('Account number cannot exceed 16 digits.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches)
            
            # Validate account number contains only digits - only if payment method is Card
            if payment_method == 'Card' and account_number and not account_number.isdigit():
                flash('Account number must contain only numbers.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches)
            
            # Validate bank name is selected (required for all payment methods)
            if not bank_name:
                flash('Please select a bank name.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches)
            
            # Validate "Others" description if "Others" is selected
            if request_type == 'Others':
                others_description = request.form.get('others_description')
                if not others_description or not others_description.strip():
                    flash('Please specify the type of request when selecting "Others".', 'error')
                    available_request_types = get_available_request_types()
                    return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types)
            
            # Handle comma-formatted amount
            if amount:
                # Remove commas from amount for processing
                amount_clean = amount.replace(',', '')
                try:
                    amount_float = float(amount_clean)
                    if amount_float <= 0:
                        flash('Amount must be greater than 0.', 'error')
                        available_request_types = get_available_request_types()
                        return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types)
                except ValueError:
                    flash('Invalid amount format.', 'error')
                    available_request_types = get_available_request_types()
                    return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types)
        else:
            # For drafts, clean amount if provided but don't validate
            amount_clean = amount.replace(',', '') if amount else None
        
        # Handle multiple file uploads for receipts
        receipt_path = None  # Initialize receipt_path
        receipt_paths = []
        
        # Debug logging for draft saves
        if is_draft:
            print(f"DEBUG: Draft save - checking for receipt files")
            print(f"DEBUG: request.files keys: {list(request.files.keys())}")
        
        if 'receipt_files' in request.files:
            receipt_files = request.files.getlist('receipt_files')
            if is_draft:
                print(f"DEBUG: Draft save - receipt_files count: {len(receipt_files)}")
                for i, f in enumerate(receipt_files):
                    print(f"DEBUG: File {i}: filename={f.filename}, size={len(f.read()) if f else 0}")
                    if f:
                        f.seek(0)  # Reset file pointer
            
            if receipt_files and any(f.filename for f in receipt_files):
                import uuid
                import json
                import os
                
                # Create uploads directory if it doesn't exist
                upload_folder = os.path.join(app.root_path, 'uploads', 'receipts')
                os.makedirs(upload_folder, exist_ok=True)
                
                allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
                
                for receipt_file in receipt_files:
                    if receipt_file and receipt_file.filename:
                        # Validate file size (50MB max)
                        max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                        file_size = len(receipt_file.read())
                        if file_size > max_file_size:
                            file_size_mb = file_size / (1024 * 1024)
                            error_msg = f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB. Your file size is {file_size_mb:.2f}MB.'
                            # Check if this is a fetch request (FormData submission)
                            # Fetch requests with FormData typically don't have Accept: text/html
                            if 'text/html' not in request.headers.get('Accept', ''):
                                return jsonify({'error': 'File too large', 'message': error_msg}), 400
                            flash(error_msg, 'error')
                            available_request_types = get_available_request_types()
                            return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types)
                        
                        # Reset file pointer
                        receipt_file.seek(0)
                        
                        # Validate file extension
                        file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                        if file_extension not in allowed_extensions:
                            error_msg = f'Invalid file type for "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX'
                            # Check if this is a fetch request (FormData submission)
                            if 'text/html' not in request.headers.get('Accept', ''):
                                return jsonify({'error': 'Invalid file type', 'message': error_msg}), 400
                            flash(error_msg, 'error')
                            available_request_types = get_available_request_types()
                            return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types)
                        
                        # Generate unique filename
                        filename = f"{uuid.uuid4()}_{receipt_file.filename}"
                        
                        # Save file
                        full_path = os.path.join(upload_folder, filename)
                        receipt_file.save(full_path)
                        receipt_paths.append(filename)  # Store only the filename, not the full path
                
                # Convert list to JSON string for storage
                receipt_path = json.dumps(receipt_paths) if receipt_paths else None
        
        # Handle person_company - check both text input and dropdown
        person_company_value = request.form.get('person_company', '').strip()
        person_company_select = request.form.get('person_company_select', '').strip()
        # Use select value if available, otherwise use text input
        person_company = person_company_select if person_company_select else person_company_value
        
        # Debug logging for draft saves
        if is_draft:
            print(f"DEBUG: Draft save - person_company_value: '{person_company_value}'")
            print(f"DEBUG: Draft save - person_company_select: '{person_company_select}'")
            print(f"DEBUG: Draft save - final person_company: '{person_company}'")
            print(f"DEBUG: Draft save - request.form keys: {list(request.form.keys())}")
        others_description = request.form.get('others_description')
        
        # Set status based on whether it's a draft
        if is_draft:
            initial_status = 'Draft'
        else:
            # All departments go to their manager first for approval
            initial_status = 'Pending Manager Approval'
        
        # Create new request
        current_time = datetime.utcnow()
        
        # Handle "Others" request type with description
        final_request_type = request_type
        if request_type == 'Others' and others_description:
            final_request_type = f"Others: {others_description}"
        
        # For drafts, allow nullable fields
        new_req = PaymentRequest(
            request_type=final_request_type or 'Draft',
            requestor_name=requestor_name or current_user.name,
            branch_name=branch_name or '',
            person_company=person_company or None,  # Store person_company regardless of type
            department=current_user.department,
            date=date,
            purpose=purpose or '',
            payment_method=payment_method,
            account_name=account_name or '',
            account_number=account_number if payment_method == 'Card' else '',
            bank_name=bank_name or '',
            amount=amount_clean if amount_clean else (0 if is_draft else None),  # Use 0 for drafts if no amount
            recurring=recurring,
            recurring_interval=recurring_interval if recurring == 'Recurring' else None,
            status=initial_status,
            requestor_receipt_path=receipt_path,  # Store requestor receipts in separate column
            user_id=current_user.user_id,
            is_draft=is_draft,
            # Only start timing when request is actually submitted (not draft)
            manager_approval_start_time=current_time if not is_draft else None
        )
        
        
        db.session.add(new_req)
        db.session.commit()
        
        # Skip notifications and schedules for drafts
        if is_draft:
            log_action(f"Saved payment request #{new_req.request_id} as draft - {request_type or 'Draft'}")
            flash('Draft saved successfully! You can continue editing it later.', 'success')
            return redirect(url_for('drafts'))
        
        # Handle recurring payment schedules (both variable amounts and custom) - only for submitted requests
        if recurring == 'Recurring':
            recurring_interval = request.form.get('recurring_interval', '')
            print(f"[DEBUG] Processing recurring payment - interval: {recurring_interval}")
            
            # Check if it's a custom payment schedule
            if recurring_interval.startswith('custom:'):
                print(f"[DEBUG] Detected custom payment schedule")
                try:
                    # Parse custom payment schedule
                    custom_data = recurring_interval[7:]  # Remove 'custom:' prefix
                    print(f"[DEBUG] Custom data: {custom_data}")
                    payment_schedule_data = []
                    
                    if custom_data:
                        # Split by comma to get individual date:amount pairs
                        date_amount_pairs = custom_data.split(',')
                        print(f"[DEBUG] Date amount pairs: {date_amount_pairs}")
                        
                        for i, pair in enumerate(date_amount_pairs, 1):
                            if ':' in pair:
                                date_str, amount_str = pair.split(':', 1)
                                payment_schedule_data.append({
                                    'date': date_str,
                                    'amount': float(amount_str)
                                })
                                print(f"[DEBUG] Added payment {i}: {date_str} - {amount_str}")
                    
                    print(f"[DEBUG] Final payment schedule data: {payment_schedule_data}")
                    
                    # Create the payment schedule
                    if payment_schedule_data:
                        success = create_recurring_payment_schedule(new_req.request_id, amount_clean if amount else amount, payment_schedule_data)
                        if success:
                            print(f"[DEBUG] Successfully created custom payment schedule for request #{new_req.request_id}")
                            log_action(f"Created custom payment schedule for request #{new_req.request_id}")
                        else:
                            print(f"[DEBUG] Failed to create custom payment schedule for request #{new_req.request_id}")
                    else:
                        print(f"[DEBUG] No payment schedule data to create")
                        
                except Exception as e:
                    print(f"Error creating custom payment schedule: {e}")
                    import traceback
                    traceback.print_exc()
                    flash('Payment request created but custom schedule configuration failed. Please contact admin.', 'warning')
            
            # Handle variable amount recurring payments (monthly)
            elif request.form.get('variable_amounts') == 'true':
                try:
                    # Get the payment schedule data from the form
                    payment_schedule_data = []
                    schedule_data = request.form.get('payment_schedule', '[]')
                    import json
                    schedule_list = json.loads(schedule_data)
                    
                    for payment in schedule_list:
                        payment_schedule_data.append({
                            'date': payment['date'],
                            'amount': payment['amount']
                        })
                    
                    # Create the payment schedule
                    if payment_schedule_data:
                        create_recurring_payment_schedule(new_req.request_id, amount_clean if amount else amount, payment_schedule_data)
                        log_action(f"Created variable amount payment schedule for request #{new_req.request_id}")
                except Exception as e:
                    print(f"Error creating payment schedule: {e}")
                    flash('Payment request created but schedule configuration failed. Please contact admin.', 'warning')
        
        log_action(f"Created payment request #{new_req.request_id} - {request_type}")
        
        # Create notifications based on request status and RBAC rules
        try:
            if new_req.status == 'Completed':
                # Finance department requests are auto-approved - notify Finance Admin
                dept_text = get_department_text_for_notification(new_req)
                notify_users_by_role(
                    request=new_req,
                    notification_type="ready_for_finance_review",
                    title="New Payment Request Submitted",
                    message=f"New {request_type} request submitted by {requestor_name} {dept_text} department for OMR {amount}",
                    request_id=new_req.request_id
                )
            else:
                # Other departments - notify based on RBAC rules
                dept_text = get_department_text_for_notification(new_req)
                notify_users_by_role(
                    request=new_req,
                    notification_type="new_submission",
                    title="New Payment Request for Approval",
                    message=f"New {request_type} request submitted by {requestor_name} {dept_text} department for OMR {amount} - requires your approval",
                    request_id=new_req.request_id
                )
                
                
        except Exception as e:
            print(f"Error creating notifications: {e}")
            # Don't fail the request creation if notification fails
        
        # Emit real-time event to all users
        try:
            socketio.emit('new_request', {
                'request_id': new_req.request_id,
                'request_type': new_req.request_type,
                'requestor_name': new_req.requestor_name,
                'department': new_req.department,
                'amount': float(new_req.amount),
                'status': new_req.status,
                'date': new_req.date.strftime('%Y-%m-%d')
            }, room='all_users')
            
            # Also emit specifically to finance admin room for immediate updates
            socketio.emit('new_request', {
                'request_id': new_req.request_id,
                'request_type': new_req.request_type,
                'requestor_name': new_req.requestor_name,
                'department': new_req.department,
                'amount': float(new_req.amount),
                'status': new_req.status,
                'date': new_req.date.strftime('%Y-%m-%d')
            }, room='finance_admin')
            
            # Also emit to department staff room for department dashboard users
            socketio.emit('new_request', {
                'request_id': new_req.request_id,
                'request_type': new_req.request_type,
                'requestor_name': new_req.requestor_name,
                'department': new_req.department,
                'amount': float(new_req.amount),
                'status': new_req.status,
                'date': new_req.date.strftime('%Y-%m-%d')
            }, room='department_staff')
            
            # Also emit to department managers room
            socketio.emit('new_request', {
                'request_id': new_req.request_id,
                'request_type': new_req.request_type,
                'requestor_name': new_req.requestor_name,
                'department': new_req.department,
                'amount': float(new_req.amount),
                'status': new_req.status,
                'date': new_req.date.strftime('%Y-%m-%d')
            }, room='department_managers')
            
            print(f"DEBUG: Emitted new_request event to all_users, finance_admin, department_staff, and department_managers rooms")
        except Exception as e:
            print(f"Error emitting real-time notification: {e}")
            # Don't fail the request creation if real-time notification fails
        
        flash('Payment request submitted successfully!', 'success')
        return redirect(url_for('dashboard'))
    
    # Handle GET request - check if editing a draft
    draft_id = request.args.get('draft_id')
    draft_data = None
    if draft_id:
        draft = PaymentRequest.query.filter_by(request_id=draft_id, is_draft=True, user_id=current_user.user_id).first()
        if draft:
            draft_data = draft_to_dict(draft)
    
    # Get available request types and branches for the New Request page
    available_request_types = get_available_request_types()
    available_branches = get_branches_ordered_by_location()
    today = datetime.utcnow().date().strftime('%Y-%m-%d')
    return render_template('new_request.html', user=current_user, today=today, available_request_types=available_request_types, available_branches=available_branches, draft=draft_data)


@app.route('/drafts')
@login_required
def drafts():
    """View all drafts created by the current user"""
    # Get payment request drafts
    payment_drafts = PaymentRequest.query.filter_by(
        is_draft=True,
        user_id=current_user.user_id,
        is_archived=False
    ).order_by(PaymentRequest.updated_at.desc()).all()
    
    # Get item request drafts
    item_drafts = ProcurementItemRequest.query.filter_by(
        is_draft=True,
        user_id=current_user.user_id
    ).order_by(ProcurementItemRequest.updated_at.desc()).all()
    
    return render_template('drafts.html', 
                         drafts=payment_drafts, 
                         item_drafts=item_drafts,
                         user=current_user)


@app.route('/draft/<int:draft_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_draft(draft_id):
    """Edit a draft"""
    draft = PaymentRequest.query.filter_by(
        request_id=draft_id,
        is_draft=True,
        user_id=current_user.user_id
    ).first_or_404()
    
    if request.method == 'POST':
        # Check if this is a draft save or submit
        is_draft = request.form.get('save_as_draft') == 'true'
        submit_draft = request.form.get('submit_draft') == 'true'
        
        # Update draft fields
        request_type = request.form.get('request_type') or draft.request_type
        others_description = request.form.get('others_description')
        
        # Handle "Others" request type with description
        if request_type == 'Others' and others_description:
            final_request_type = f"Others: {others_description}"
        else:
            final_request_type = request_type
        
        draft.request_type = final_request_type
        draft.requestor_name = request.form.get('requestor_name') or draft.requestor_name
        
        # Handle branch name - check for multiple branch names first (new format), then fall back to single branch_name
        branch_names = request.form.get('branch_names', '').strip()
        branch_name = request.form.get('branch_name', '').strip()
        if branch_names:
            draft.branch_name = branch_names
        elif branch_name:
            draft.branch_name = branch_name
        # If both are empty and this is not a draft save, keep existing value (for validation errors)
        # For draft saves, allow empty branch_name
        
        draft.purpose = request.form.get('purpose') or draft.purpose
        draft.payment_method = request.form.get('payment_method', 'Card')
        draft.account_name = request.form.get('account_name') or draft.account_name
        draft.account_number = request.form.get('account_number') if draft.payment_method == 'Card' else ''
        draft.bank_name = request.form.get('bank_name') or draft.bank_name
        amount = request.form.get('amount')
        if amount:
            amount_clean = amount.replace(',', '')
            try:
                draft.amount = float(amount_clean)
            except ValueError:
                pass
        
        draft.recurring = request.form.get('recurring', 'One-Time')
        draft.recurring_interval = request.form.get('recurring_interval') if draft.recurring == 'Recurring' else None
        
        # Handle person_company - check both text input and dropdown
        # Store regardless of request type to preserve data across edits
        person_company_value = request.form.get('person_company', '').strip()
        person_company_select = request.form.get('person_company_select', '').strip()
        # Use select value if available, otherwise use text input
        final_person_company = person_company_select if person_company_select else person_company_value
        
        draft.person_company = final_person_company if final_person_company else None  # Store regardless of type
        
        # Handle file deletions first
        import uuid
        import json
        import os
        
        delete_files = request.form.getlist('delete_files')
        existing_receipts = []
        if draft.requestor_receipt_path:
            try:
                existing_receipts = json.loads(draft.requestor_receipt_path)
                if not isinstance(existing_receipts, list):
                    existing_receipts = [draft.requestor_receipt_path] if draft.requestor_receipt_path else []
            except (json.JSONDecodeError, TypeError):
                existing_receipts = [draft.requestor_receipt_path] if draft.requestor_receipt_path else []
        
        # Remove deleted files and delete physical files
        if delete_files:
            upload_folder = os.path.join(app.root_path, 'uploads', 'receipts')
            deleted_file_names = []
            for filename_to_delete in delete_files:
                if filename_to_delete in existing_receipts:
                    existing_receipts.remove(filename_to_delete)
                    # Delete the physical file
                    filepath = os.path.join(upload_folder, filename_to_delete)
                    if os.path.exists(filepath):
                        try:
                            os.remove(filepath)
                            deleted_file_names.append(filename_to_delete)
                        except Exception as e:
                            print(f"Error deleting file {filename_to_delete}: {e}")
            
            if deleted_file_names:
                log_action(f"Deleted {len(deleted_file_names)} receipt file(s) from draft #{draft_id}")
        
        # Handle file uploads - add new files to existing ones (after deletions)
        receipt_files = request.files.getlist('receipt_files')
        receipt_paths = existing_receipts.copy()  # Start with existing receipts (minus deleted ones)
        
        if receipt_files and any(f.filename for f in receipt_files):
            upload_folder = os.path.join(app.root_path, 'uploads', 'receipts')
            os.makedirs(upload_folder, exist_ok=True)
            allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
            
            for receipt_file in receipt_files:
                if receipt_file and receipt_file.filename:
                    # Validate file size (50MB max)
                    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                    file_size = len(receipt_file.read())
                    if file_size > max_file_size:
                        flash(f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
                        receipt_file.seek(0)
                        continue
                    
                    # Reset file pointer
                    receipt_file.seek(0)
                    
                    # Validate file extension
                    file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                    if file_extension in allowed_extensions:
                        filename = f"{uuid.uuid4()}_{receipt_file.filename}"
                        full_path = os.path.join(upload_folder, filename)
                        receipt_file.save(full_path)
                        receipt_paths.append(filename)
        
        # Update receipt path (includes existing minus deleted plus new)
        if receipt_paths:
            draft.requestor_receipt_path = json.dumps(receipt_paths)
        else:
            draft.requestor_receipt_path = None
        
        draft.updated_at = datetime.utcnow()
        
        # If submitting draft, convert to regular request
        if submit_draft:
            # Validate required fields
            if not draft.branch_name:
                flash('At least one branch name is required.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches, draft=draft_to_dict(draft))
            
            if draft.payment_method == 'Card' and not draft.account_number:
                flash('Account number is required when payment method is Card.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches, draft=draft_to_dict(draft))
            
            if not draft.bank_name:
                flash('Please select a bank name.', 'error')
                available_request_types = get_available_request_types()
                available_branches = get_branches_ordered_by_location()
                return render_template('new_request.html', user=current_user, today=datetime.utcnow().date().strftime('%Y-%m-%d'), available_request_types=available_request_types, available_branches=available_branches, draft=draft_to_dict(draft))
            
            # Convert draft to regular request
            draft.is_draft = False
            draft.status = 'Pending Manager Approval'
            draft.manager_approval_start_time = datetime.utcnow()
            
            db.session.commit()
            
            log_action(f"Submitted draft #{draft_id} as payment request")
            
            # Create notifications
            try:
                dept_text = get_department_text_for_notification(draft)
                notify_users_by_role(
                    request=draft,
                    notification_type="new_submission",
                    title="New Payment Request for Approval",
                    message=f"New {draft.request_type} request submitted by {draft.requestor_name} {dept_text} department for OMR {draft.amount} - requires your approval",
                    request_id=draft.request_id
                )
            except Exception as e:
                print(f"Error creating notifications: {e}")
            
            flash('Draft submitted successfully!', 'success')
            return redirect(url_for('dashboard'))
        else:
            # Save as draft
            db.session.commit()
            log_action(f"Updated draft #{draft_id}")
            flash('Draft updated successfully!', 'success')
            return redirect(url_for('drafts'))
    
    # GET request - show edit form
    available_request_types = get_available_request_types()
    available_branches = get_branches_ordered_by_location()
    today = datetime.utcnow().date().strftime('%Y-%m-%d')
    return render_template('new_request.html', user=current_user, today=today, available_request_types=available_request_types, available_branches=available_branches, draft=draft_to_dict(draft))


@app.route('/draft/<int:draft_id>/delete', methods=['POST'])
@login_required
def delete_draft(draft_id):
    """Delete a draft"""
    draft = PaymentRequest.query.filter_by(
        request_id=draft_id,
        is_draft=True,
        user_id=current_user.user_id
    ).first_or_404()
    
    db.session.delete(draft)
    db.session.commit()
    
    log_action(f"Deleted draft #{draft_id}")
    flash('Draft deleted successfully!', 'success')
    return redirect(url_for('drafts'))


@app.route('/edit-item-draft/<int:draft_id>', methods=['GET', 'POST'])
@login_required
def edit_item_draft(draft_id):
    """Edit an item request draft"""
    draft = ProcurementItemRequest.query.filter_by(
        id=draft_id,
        is_draft=True,
        user_id=current_user.user_id
    ).first_or_404()
    
    if request.method == 'POST':
        # Update draft with form data
        draft.requestor_name = request.form.get('requestor_name', '').strip() or draft.requestor_name
        draft.category = request.form.get('category', '').strip() or draft.category
        
        # Handle item names
        item_names = request.form.get('item_names', '').strip()
        item_name_value = request.form.get('item_name_value', '').strip()
        item_name = request.form.get('item_name', '').strip()
        if item_names:
            draft.item_name = item_names
        elif item_name_value:
            draft.item_name = item_name_value
        elif item_name:
            draft.item_name = item_name
        
        # Handle quantities - convert JSON input into a formatted string and store (avoid raw JSON)
        item_quantities_json = request.form.get('item_quantities', '').strip()
        quantity = None
        if item_quantities_json:
            try:
                import json
                quantities = json.loads(item_quantities_json)
                # Combine quantities into a formatted string if multiple items
                if draft.item_name and ',' in draft.item_name and len(quantities) > 1:
                    # Store only the numeric quantities in order, separated by semicolons
                    quantity_parts = []
                    for qty in quantities:
                        if qty and qty.strip():
                            quantity_parts.append(qty.strip())
                    if quantity_parts:
                        quantity = '; '.join(quantity_parts)
                    elif len(quantities) == 1 and quantities[0]:
                        quantity = quantities[0]
                elif len(quantities) == 1 and quantities[0]:
                    quantity = quantities[0]
            except Exception:
                # If parsing fails, fallback to leaving the field unchanged
                quantity = None
        if quantity:
            draft.procurement_quantities = quantity
        draft.purpose = request.form.get('purpose', '').strip() or draft.purpose
        
        # Handle branch names
        branch_names = request.form.get('branch_names', '').strip()
        branch_name = request.form.get('branch_name', '').strip()
        if branch_names:
            draft.branch_name = branch_names
        elif branch_name:
            draft.branch_name = branch_name
        
        draft.notes = request.form.get('notes', '').strip() or draft.notes
        
        # Check if submitting or saving as draft
        is_save_draft = request.form.get('action') == 'save_draft'
        
        # Validation for submit (more strict) vs draft (more lenient)
        if not is_save_draft:
            if not all([draft.requestor_name, draft.category, draft.item_name, draft.purpose, draft.branch_name]):
                flash('Please fill in all required fields to submit.', 'danger')
                return redirect(url_for('edit_item_draft', draft_id=draft_id))
        
        if not is_save_draft:
            # Submit the draft
            draft.is_draft = False
            draft.status = 'Pending Manager Approval'
            draft.manager_approval_start_time = datetime.utcnow()
            db.session.commit()
            
            # Send notifications (similar to new item request)
            if current_user:
                create_notification(
                    user_id=current_user.user_id,
                    title="Item Request Submitted",
                    message=f"Your item request for {draft.item_name} has been submitted successfully and is awaiting manager approval.",
                    notification_type="new_submission",
                    item_request_id=draft.id
                )
            
            authorized_approvers = get_authorized_manager_approvers_for_item_request(draft)
            for approver in authorized_approvers:
                try:
                    create_notification(
                        user_id=approver.user_id,
                        title="New Item Request for Approval",
                        message=f"New item request submitted by {draft.requestor_name} from {draft.department} department for {draft.item_name} - requires your approval",
                        notification_type="item_request_submission",
                        item_request_id=draft.id
                    )
                except Exception as e:
                    pass
            
            flash(f'Item request submitted successfully! Item: {draft.item_name}', 'success')
            log_action(f'Submitted item request draft #{draft_id}: {draft.item_name}')
            return redirect(url_for('procurement_item_requests'))
        else:
            # Just save as draft
            db.session.commit()
            flash('Item request draft updated and saved!', 'success')
            log_action(f'Updated item request draft #{draft_id}: {draft.item_name}')
            return redirect(url_for('drafts') + '#item-requests')
    
    # GET request - show form with draft data
    available_branches = get_branches_ordered_by_location()
    user_department = current_user.department if current_user else None
    procurement_categories = []
    procurement_items = []
    
    if user_department:
        procurement_categories = ProcurementCategory.query.filter_by(
            department=user_department,
            is_active=True
        ).order_by(ProcurementCategory.name).all()
        
        procurement_items = ProcurementItem.query.filter_by(
            department=user_department,
            is_active=True
        ).order_by(ProcurementItem.name).all()
    
    return render_template(
        'edit_item_draft.html',
        draft=draft,
        available_branches=available_branches,
        procurement_categories=procurement_categories,
        procurement_items=procurement_items,
        user=current_user
    )


@app.route('/delete-item-draft/<int:draft_id>', methods=['POST'])
@login_required
def delete_item_draft(draft_id):
    """Delete an item request draft"""
    draft = ProcurementItemRequest.query.filter_by(
        id=draft_id,
        is_draft=True,
        user_id=current_user.user_id
    ).first_or_404()
    
    db.session.delete(draft)
    db.session.commit()
    
    log_action(f"Deleted item request draft #{draft_id}")
    flash('Item request draft deleted successfully!', 'success')
    return redirect(url_for('drafts', _anchor='item-requests'))


@app.route('/populate-request-types')
@login_required
@role_required('IT Staff', 'Department Manager')
def populate_request_types_route():
    """Populate request types in the database"""
    try:
        from populate_request_types import populate_request_types, verify_population
        
        # Populate request types
        populate_request_types()
        
        # Verify population
        verify_population()
        
        flash('Request types populated successfully!', 'success')
        return redirect(url_for('it_dashboard'))
        
    except Exception as e:
        flash(f'Error populating request types: {str(e)}', 'error')
        return redirect(url_for('it_dashboard'))

@app.route('/add-finance-request-types')
@login_required
@role_required('IT Staff', 'Department Manager')
def add_finance_request_types_route():
    """Add new Finance Department request types in bulk"""
    try:
        from add_finance_request_types import add_finance_request_types, verify_addition
        
        # Add Finance request types
        add_finance_request_types()
        
        # Verify addition
        verify_addition()
        
        flash('Finance Department request types added successfully!', 'success')
        return redirect(url_for('manage_request_types', department='Finance'))
        
    except Exception as e:
        flash(f'Error adding Finance request types: {str(e)}', 'error')
        return redirect(url_for('it_dashboard'))

@app.route('/add-petrol-request-type')
@login_required
@role_required('IT Staff', 'Department Manager')
def add_petrol_request_type_route():
    """Add Petrol request type for Finance Department"""
    try:
        from add_petrol_request_type import add_petrol_request_type
        
        # Add Petrol request type
        add_petrol_request_type()
        
        flash('Petrol request type added successfully for Finance Department!', 'success')
        return redirect(url_for('manage_request_types', department='Finance'))
        
    except Exception as e:
        flash(f'Error adding Petrol request type: {str(e)}', 'error')
        return redirect(url_for('it_dashboard'))

@app.route('/add-rental-expenses-request-type')
@login_required
@role_required('IT Staff', 'Department Manager')
def add_rental_expenses_request_type_route():
    """Add Rental Expenses request type for Finance Department"""
    try:
        from add_rental_expenses_request_type import add_rental_expenses_request_type
        
        # Add Rental Expenses request type
        add_rental_expenses_request_type()
        
        flash('Rental Expenses request type added successfully for Finance Department!', 'success')
        return redirect(url_for('manage_request_types', department='Finance'))
        
    except Exception as e:
        flash(f'Error adding Rental Expenses request type: {str(e)}', 'error')
        return redirect(url_for('it_dashboard'))

@app.route('/add-social-insurance-salary-request-types')
@login_required
@role_required('IT Staff', 'Department Manager')
def add_social_insurance_salary_request_types_route():
    """Add Social Insurance and Salary Expenses request types for Finance Department"""
    try:
        from add_social_insurance_salary_request_types import add_social_insurance_salary_request_types
        
        # Add Social Insurance and Salary Expenses request types
        add_social_insurance_salary_request_types()
        
        flash('Social Insurance and Salary Expenses request types added successfully for Finance Department!', 'success')
        return redirect(url_for('manage_request_types', department='Finance'))
        
    except Exception as e:
        flash(f'Error adding request types: {str(e)}', 'error')
        return redirect(url_for('it_dashboard'))

@app.route('/test-timezone')
def test_timezone():
    """Test timezone conversion"""
    from datetime import datetime
    test_time = datetime(2025, 10, 20, 6, 36, 21)
    local_time = utc_to_local(test_time)
    return f"UTC: {test_time}, Local: {local_time}"

@app.route('/fix-durations')
@login_required
@role_required('Admin')
def fix_durations():
    """Fix existing incorrect duration calculations in the database"""
    try:
        # Get all requests with timing data
        requests = PaymentRequest.query.filter(
            PaymentRequest.manager_approval_start_time.isnot(None),
            PaymentRequest.manager_approval_end_time.isnot(None)
        ).all()
        
        fixed_count = 0
        
        for req in requests:
            # Recalculate manager approval duration
            if req.manager_approval_start_time and req.manager_approval_end_time:
                duration = req.manager_approval_end_time - req.manager_approval_start_time
                correct_duration_seconds = int(duration.total_seconds())
                
                # If the stored duration is much larger than the actual duration,
                # it was likely calculated in minutes instead of seconds
                if req.manager_approval_duration_minutes and req.manager_approval_duration_minutes > correct_duration_seconds:
                    req.manager_approval_duration_minutes = correct_duration_seconds
                    fixed_count += 1
            
            # Recalculate finance approval duration
            if req.finance_approval_start_time and req.finance_approval_end_time:
                duration = req.finance_approval_end_time - req.finance_approval_start_time
                correct_duration_seconds = int(duration.total_seconds())
                
                # If the stored duration is much larger than the actual duration,
                # it was likely calculated in minutes instead of seconds
                if req.finance_approval_duration_minutes and req.finance_approval_duration_minutes > correct_duration_seconds:
                    req.finance_approval_duration_minutes = correct_duration_seconds
                    fixed_count += 1
        
        db.session.commit()
        return f"Fixed {fixed_count} duration calculations"
        
    except Exception as e:
        return f"Error fixing durations: {str(e)}"

@app.route('/api/timing/<int:request_id>')
@login_required
def get_timing_api(request_id):
    """API endpoint to get real-time timing data for a request"""
    try:
        req = PaymentRequest.query.get_or_404(request_id)
        current_time = datetime.utcnow()
        
        timing_data = {}
        
        # Manager approval timing
        if req.manager_approval_start_time:
            if req.manager_approval_end_time:
                # Completed - show final duration
                duration = req.manager_approval_end_time - req.manager_approval_start_time
                timing_data['manager'] = {
                    'status': 'completed',
                    'start_time': req.manager_approval_start_time.isoformat(),
                    'end_time': req.manager_approval_end_time.isoformat(),
                    'duration_seconds': int(duration.total_seconds()),
                    'duration_minutes': req.manager_approval_duration_minutes
                }
            else:
                # In progress - calculate elapsed time
                elapsed = current_time - req.manager_approval_start_time
                timing_data['manager'] = {
                    'status': 'in_progress',
                    'start_time': req.manager_approval_start_time.isoformat(),
                    'elapsed_seconds': int(elapsed.total_seconds())
                }
        
        # Finance approval timing
        if req.finance_approval_start_time:
            if req.finance_approval_end_time:
                # Completed - show final duration
                duration = req.finance_approval_end_time - req.finance_approval_start_time
                timing_data['finance'] = {
                    'status': 'completed',
                    'start_time': req.finance_approval_start_time.isoformat(),
                    'end_time': req.finance_approval_end_time.isoformat(),
                    'duration_seconds': int(duration.total_seconds()),
                    'duration_minutes': req.finance_approval_duration_minutes
                }
            else:
                # In progress - calculate elapsed time
                elapsed = current_time - req.finance_approval_start_time
                timing_data['finance'] = {
                    'status': 'in_progress',
                    'start_time': req.finance_approval_start_time.isoformat(),
                    'elapsed_seconds': int(elapsed.total_seconds())
                }
        
        return jsonify(timing_data)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/payment-schedule/<int:request_id>')
@login_required
def get_payment_schedule_api(request_id):
    """API endpoint to get payment schedule for a request"""
    try:
        schedule = get_payment_schedule(request_id)
        return jsonify({'success': True, 'schedule': schedule})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})


@app.route('/admin/check-timing-alerts')
@login_required
@role_required('Finance Admin')
def check_timing_alerts():
    """Manual endpoint to check and send timing alerts (for testing and manual triggers)"""
    try:
        check_finance_approval_timing_alerts()
        flash('Timing alerts check completed successfully.', 'success')
        return redirect(url_for('admin_dashboard'))
    except Exception as e:
        flash(f'Error checking timing alerts: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard')), 500


@app.route('/admin/overdue-requests')
@login_required
@role_required('Finance Admin', 'Finance Staff')
def overdue_requests():
    """Display all overdue finance approval requests"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 50, type=int)  # Default to 50 to show more requests
        
        # Validate per_page to prevent abuse - allow higher limits to show all overdue requests
        if per_page not in [10, 20, 50, 100, 200, 500]:
            per_page = 50
        
        # Get ALL overdue requests (no limit in the query)
        overdue_requests_list = get_overdue_requests()
        overdue_count = len(overdue_requests_list)
        
        # Calculate pagination
        total_pages = (overdue_count + per_page - 1) // per_page if overdue_count > 0 else 1  # Ceiling division
        start_index = (page - 1) * per_page
        end_index = start_index + per_page
        
        # Get paginated results
        paginated_overdue_requests = overdue_requests_list[start_index:end_index]
        
        return render_template('overdue_requests.html', 
                             overdue_requests=paginated_overdue_requests,
                             overdue_count=overdue_count,
                             page=page,
                             per_page=per_page,
                             total_pages=total_pages)
    except Exception as e:
        flash(f'Error loading overdue requests: {str(e)}', 'error')
        import traceback
        traceback.print_exc()
        return redirect(url_for('admin_dashboard'))


@app.route('/favicon.ico')
def favicon():
    """Serve favicon to prevent 404 errors"""
    return '', 204  # No content response


@app.route('/write-cheque', methods=['GET', 'POST'])
@login_required
@role_required('GM', 'CEO', 'Operation Manager')
def write_cheque():
    """Write a cheque for approved payment requests"""
    if request.method == 'POST':
        # Handle cheque writing logic here
        flash('Cheque written successfully!', 'success')
        return redirect(url_for('dashboard'))
    
    # Get approved payment requests that need cheques
    approved_requests = PaymentRequest.query.filter_by(status='Approved').all()
    
    return render_template('write_cheque.html', 
                         user=current_user, 
                         approved_requests=approved_requests)


@app.route('/generate-cheque-pdf', methods=['POST'])
@login_required
@role_required('GM', 'CEO', 'Operation Manager')
def generate_cheque_pdf():
    """Generate PDF from cheque data"""
    try:
        data = request.get_json()
        
        # Extract cheque data
        cheque_date = data.get('chequeDate', '')
        payee_name = data.get('payeeName', '')
        amount = data.get('amount', '')
        currency = data.get('currency', 'OMR')
        crossing = data.get('crossing', '')
        bank = data.get('bank', 'dhofar_islamic')
        show_date = data.get('showDate', True)  # Default to True if not provided
        
        # Format date (only if show_date is True)
        formatted_date = ''
        if show_date and cheque_date:
            try:
                date_obj = datetime.strptime(cheque_date, '%Y-%m-%d')
                formatted_date = date_obj.strftime('%d/%m/%Y')
            except:
                formatted_date = cheque_date
        
        # Format amount (do not show currency in cheque overlay)
        formatted_amount = ''
        if amount:
            try:
                numeric = float(amount)
                formatted_amount = f"{numeric:,.3f}".replace(',', '')
            except:
                formatted_amount = amount
        
        # Get language for amount in words
        amount_words_language = data.get('amountWordsLanguage', 'english')
        
        # Convert amount to words
        amount_words = ''
        if amount:
            try:
                numeric = float(amount)
                amount_words = convert_amount_to_words(numeric, currency, amount_words_language)
            except:
                pass
        
        # Get bank-specific positions
        bank_positions = {
            'dhofar_islamic': {
                'date': {'top': '90px', 'left': '220px'},  # Moved slightly higher (92->90)
                'payee': {'top': '132px', 'left': '40px'},  # Moved 5px lower (127->132)
                'amount': {'top': '165px', 'left': '367px'},  # Moved 3px left (370->367)
                'amountWords': {'top': '155px', 'left': '41px'},  # Moved 3px right (38->41)
                'crossing': {'top': '20px', 'left': '60px'}
            },
            'oman_arab': {
                'date': {'top': '62px', 'left': '365px', 'extra': 'font-size: 11px;'},  # +20px right (345->365)
                'payee': {'top': '130px', 'left': '-5px', 'extra': 'font-size: 13px;'},   # Nudge ~1px down (129->130)
                'amount': {'top': '135px', 'left': '383px', 'extra': 'font-size: 12px;'}, # 8px down (127->135), 3px right (380->383), smaller font
                'amountWords': {'top': '157px', 'left': '58px', 'extra': 'max-width: 230px; width: 230px; line-height: 2.5;'},  # Bigger line-height
                'crossing': {'top': '20px', 'left': '60px'}  # Same as Dhofar Islamic Bank for testing
            },
            'sohar': {
                'date': {'top': '52px', 'left': '365px'},  # Moved 50px more left: 415 - 50 = 365
                'payee': {'top': '116px', 'left': '55px'},  # Moved 60px left: 115 - 60 = 55
                'amount': {'top': '163px', 'left': '378px'},  # Moved 50px more left: 428 - 50 = 378
                'amountWords': {'top': '153px', 'left': '20px'},  # Moved 60px left: 80 - 60 = 20
                'crossing': {'top': '25px', 'left': '10px'}  # Moved 60px left: 70 - 60 = 10
            }
        }
        
        positions = bank_positions.get(bank, bank_positions['dhofar_islamic'])
        
        # Get bank image
        bank_images = {
            'dhofar_islamic': 'DHOFAR-ISLAMIC-BANK.png',
            'oman_arab': 'OMAN-ARAB-BANK.png',
            'sohar': 'SOHAR-BANK.png'
        }
        bank_image = bank_images.get(bank, 'DHOFAR-ISLAMIC-BANK.png')
        
        # Get full path to bank image
        bank_image_path = os.path.join(app.static_folder, 'cheque_templates', bank_image)
        bank_image_url = url_for('static', filename=f'cheque_templates/{bank_image}', _external=True)
        
        # Convert image to base64 for xhtml2pdf compatibility
        bank_image_base64 = ''
        if os.path.exists(bank_image_path):
            with open(bank_image_path, 'rb') as img_file:
                img_data = img_file.read()
                bank_image_base64 = base64.b64encode(img_data).decode('utf-8')
                bank_image_base64 = f"data:image/png;base64,{bank_image_base64}"
        
        # Render PDF template
        html_content = render_template('cheque_pdf.html',
                                     cheque_date=formatted_date,
                                     show_date=show_date,
                                     payee_name=payee_name,
                                     amount=formatted_amount,
                                     amount_words=amount_words,
                                     crossing=crossing,
                                     bank_image_base64=bank_image_base64,
                                     positions=positions)
        
        # Generate PDF using Playwright
        pdf_buffer = BytesIO()
        
        with sync_playwright() as p:
            # Launch browser
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()
            
            # Set page size to cheque dimensions (7.5in x 3.5in)
            page.set_viewport_size({"width": 720, "height": 336})  # 7.5in * 96dpi = 720px, 3.5in * 96dpi = 336px
            
            # Load HTML content
            page.set_content(html_content, wait_until='networkidle')
            
            # Generate PDF with exact page size
            # Using scale: 1.0 to ensure actual size (100% scale)
            pdf_bytes = page.pdf(
                format=None,
                width='7.5in',
                height='3.5in',
                margin={'top': '0', 'right': '0', 'bottom': '0', 'left': '0'},
                print_background=True,
                scale=1.0  # Force 100% scale (actual size)
            )
            
            browser.close()
            
            # Write PDF to buffer
            pdf_buffer.write(pdf_bytes)
            pdf_buffer.seek(0)
        
        # Return PDF
        return Response(
            pdf_buffer.getvalue(),
            mimetype='application/pdf',
            headers={
                'Content-Disposition': 'inline; filename=cheque.pdf'
            }
        )
        
    except Exception as e:
        print(f"Error generating PDF: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


def get_currency_name(currency, language='english'):
    """Get currency name in words based on currency code"""
    if language == 'arabic':
        # For Arabic, keep OMR as is for now (can be extended later)
        return 'ÿ±ŸäÿßŸÑÿßŸã ÿπŸÖÿßŸÜŸäÿßŸã'
    else:
        # English currency names
        if currency == 'USD':
            return 'US Dollar'
        elif currency == 'EUR':
            return 'Euro'
        else:  # OMR or default
            return 'Rial Omani'

def convert_amount_to_words(amount, currency='OMR', language='english'):
    """Convert numeric amount to words"""
    ones = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 
            'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 
            'seventeen', 'eighteen', 'nineteen']
    tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']
    
    def number_to_words(n):
        if n < 20:
            return ones[int(n)]
        if n < 100:
            t = int(n // 10)
            r = int(n % 10)
            return f"{tens[t]}-{ones[r]}" if r else tens[t]
        if n < 1000:
            h = int(n // 100)
            r = int(n % 100)
            return f"{ones[h]} hundred {number_to_words(r)}" if r else f"{ones[h]} hundred"
        
        units = [
            (1_000_000_000_000, 'trillion'),
            (1_000_000_000, 'billion'),
            (1_000_000, 'million'),
            (1_000, 'thousand')
        ]
        
        for unit_value, unit_name in units:
            if n >= unit_value:
                q = int(n // unit_value)
                r = int(n % unit_value)
                return f"{number_to_words(q)} {unit_name} {number_to_words(r)}" if r else f"{number_to_words(q)} {unit_name}"
        return ''
    
    try:
        currency_name = get_currency_name(currency, language)
        
        fixed = f"{amount:.3f}"
        int_str, dec_str = fixed.split('.')
        int_num = int(int_str)
        
        words = number_to_words(abs(int_num))
        if int_num == 0:
            words = 'zero'
        
        if amount < 0:
            words = f"minus {words}"
        
        # Capitalize first letter of each word (including words with dashes)
        capitalized = ' '.join([word.capitalize() for word in words.split()])
        
        # Format with currency name (matching frontend format)
        if dec_str and int(dec_str) > 0:
            if currency == 'OMR':
                return f"{capitalized} {currency_name} & #{dec_str}# Baisa Only"
            else:
                return f"{capitalized} {currency_name} & #{dec_str}# Cents Only"
        else:
            return f"{capitalized} {currency_name} Only"
    except:
        return ''


@app.route('/request/<int:request_id>')
@login_required
def view_request(request_id):
    """View a specific payment request"""
    # Use eager loading to reduce database queries
    req = PaymentRequest.query.options(
        db.joinedload(PaymentRequest.user)
    ).get_or_404(request_id)
    
    # If request is archived, only IT department can view it (they can access via archives page)
    if req.is_archived:
        it_allowed = (current_user.role == 'IT Staff') or (current_user.role == 'Department Manager' and current_user.department == 'IT')
        if not it_allowed:
            flash('This request has been archived and is only accessible from the Archives page (IT Department only).', 'warning')
            return redirect(url_for('dashboard'))
    
    # Hard restriction: CEO requests are viewable by Finance Admins, GM, Operation Manager, IT roles, or the CEO themself
    if getattr(req.user, 'role', None) == 'CEO':
        it_allowed = (current_user.role == 'IT Staff') or (current_user.role == 'Department Manager' and current_user.department == 'IT')
        if current_user.user_id != req.user_id and current_user.role not in ['Finance Admin', 'GM', 'Operation Manager'] and not it_allowed:
            return render_template('403.html'), 403

    # Check permissions
    # Quick allow: if current user is the department-level temporary manager for this request's department,
    # grant view access regardless of their role (this mirrors item-request behavior).
    try:
        _dept_temp = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.department == (req.department or ''),
            db.or_(
                DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).first()
    except Exception:
        _dept_temp = None
    allowed_by_dept_temp = bool(_dept_temp and getattr(_dept_temp, 'temporary_manager_id', None) == current_user.user_id)

    # Allow Operation Manager, IT users, and IT Department Managers to view all requests (same as GM visibility)
    if not allowed_by_dept_temp and current_user.role not in ['Finance Admin', 'Finance Staff', 'GM', 'CEO', 'IT Staff', 'Project Staff', 'Operation Manager']:
        # Auditing Department users (Staff and Department Manager) can view their own requests OR Completed/Recurring requests from other departments
        if current_user.department == 'Auditing' and (current_user.role == 'Auditing Staff' or current_user.role == 'Department Manager'):
            # Allow if:
            # 1. It's their own request, OR
            # 2. (For Department Manager) It's from Auditing department, OR
            # 3. It's Completed/Recurring from another department, OR
            # 4. They are temporary manager
            if req.user_id != current_user.user_id:
                # Not their own request
                if current_user.role == 'Department Manager':
                    # Department Manager can also view their department's requests
                    if req.department == 'Auditing' or getattr(req, 'temporary_manager_id', None) == current_user.user_id:
                        pass  # Allow access
                    elif req.status not in ['Completed', 'Recurring', 'Proof Pending', 'Proof Sent', 'Proof Rejected']:
                        flash('You do not have permission to view this request.', 'danger')
                        return redirect(url_for('dashboard'))
                else:
                    # Auditing Staff - check if it's Completed/Recurring from another department
                    if req.department == 'Auditing' or req.status not in ['Completed', 'Recurring', 'Proof Pending', 'Proof Sent', 'Proof Rejected']:
                        flash('You do not have permission to view this request.', 'danger')
                        return redirect(url_for('dashboard'))
        # Other Department Managers can view requests from their department
        elif current_user.role == 'Department Manager':
            # IT Department Managers can view all requests
            if current_user.department == 'IT':
                pass  # Allow access to all requests
            # Temporary manager may view regardless of department
            elif getattr(req, 'temporary_manager_id', None) == current_user.user_id:
                pass
            # Check if user is an authorized manager approver (regardless of department match)
            # This allows managers to view requests they can approve even if department was changed
            else:
                authorized_approvers = get_authorized_manager_approvers(req)
                if current_user in authorized_approvers:
                    pass  # Allow access - user is authorized to approve this request
                # Normalize department comparison (case-insensitive, trimmed) to handle whitespace/case issues
                elif req.department and current_user.department:
                    req_dept_normalized = req.department.strip().lower()
                    user_dept_normalized = current_user.department.strip().lower()
                    if req_dept_normalized != user_dept_normalized:
                        flash('You do not have permission to view this request.', 'danger')
                        return redirect(url_for('dashboard'))
                elif req.department != current_user.department:
                    flash('You do not have permission to view this request.', 'danger')
                    return redirect(url_for('dashboard'))
        # Regular users can only view their own requests
        elif req.user_id != current_user.user_id:
            flash('You do not have permission to view this request.', 'danger')
            return redirect(url_for('dashboard'))
    elif current_user.role in ['Finance Admin', 'Finance Staff']:
        # If assigned as temporary manager, allow viewing regardless of finance status rules
        if getattr(req, 'temporary_manager_id', None) == current_user.user_id:
            pass
        else:
            # Always allow finance users to view their own requests regardless of status
            if req.user_id == current_user.user_id:
                pass
            else:
                # Finance users can only view requests in finance-related statuses
                finance_statuses = ['Pending Finance Approval', 'Returned to Manager', 'Proof Pending', 'Proof Sent', 'Proof Rejected', 'Recurring', 'Completed', 'Rejected by Finance']
                
                # For Abdalaziz, also allow viewing PMA/Rejected-by-Manager for Finance dept, his own, and GM/CEO/Operation Manager submissions
                if current_user.name == 'Abdalaziz Al-Brashdi' and req.status in ['Pending Manager Approval', 'Rejected by Manager']:
                    if (req.department == 'Finance' or req.user_id == current_user.user_id or getattr(req.user, 'role', None) in ['GM', 'CEO', 'Operation Manager']):
                        pass  # Allow access
                    else:
                        flash('You do not have permission to view this request.', 'danger')
                        return redirect(url_for('dashboard'))
                elif req.status not in finance_statuses:
                    flash('You do not have permission to view this request.', 'danger')
                    return redirect(url_for('dashboard'))
    
    # Mark notifications related to this request as read for Finance and Admin users
    if current_user.role in ['Finance Staff', 'Finance Admin']:
        # Use a more efficient update query
        db.session.query(Notification).filter_by(
            user_id=current_user.user_id,
            request_id=request_id,
            is_read=False
        ).update({'is_read': True})
        db.session.commit()
    
    # Determine if current user can schedule a one-time payment date
    can_schedule_one_time = False
    one_time_scheduled_by = None

    try:
        # Authorization for scheduling one-time payment date
        # 1) If a temporary manager is assigned, only they can schedule
        if getattr(req, 'temporary_manager_id', None):
            can_schedule_one_time = (req.temporary_manager_id == current_user.user_id)
        else:
            # 2) Global roles
            if current_user.role in ['GM', 'Operation Manager']:
                can_schedule_one_time = True
            # 3) IT department (IT Staff and IT Department Manager)
            elif current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']:
                can_schedule_one_time = True
            # 4) Assigned manager of the requestor
            elif getattr(req.user, 'manager_id', None) == current_user.user_id:
                can_schedule_one_time = True
            # 5) Department Manager of the same department as the requestor
            elif current_user.role == 'Department Manager' and current_user.department == req.department:
                can_schedule_one_time = True

        # Resolve the name of the scheduler from audit logs (latest)
        if req.payment_date:
            from models import AuditLog
            keyword = f"request #{request_id}"
            log = (
                AuditLog.query
                .filter(AuditLog.action.like('%Scheduled one-time payment date%'))
                .filter(AuditLog.action.like(f"%{keyword}%"))
                .order_by(AuditLog.timestamp.desc())
                .first()
            )
            if log:
                one_time_scheduled_by = getattr(log.user, 'name', None) or log.username_snapshot or 'Unknown'
    except Exception as e:
        # Fail-safe: do not break view if any of the above fails
        print(f"DEBUG: Error computing can_schedule_one_time or scheduled_by: {e}")

    # Get schedule rows for variable payments - show for Admin review, but only allow payments when approved
    schedule_rows = []
    total_paid_amount = 0
    
    # Process schedule if it's a recurring payment (monthly or custom)
    print(f"[DEBUG] view_request - recurring_interval: {req.recurring_interval}")
    if req.recurring_interval and ('monthly' in req.recurring_interval or req.recurring_interval.startswith('custom:')):
        print(f"[DEBUG] Processing recurring payment schedule")
        # Get variable payment schedule if exists - use single query with ordering
        schedule = RecurringPaymentSchedule.query.filter_by(
            request_id=request_id
        ).order_by(RecurringPaymentSchedule.payment_order).all()
        print(f"[DEBUG] Found {len(schedule)} schedule entries")
        
        if schedule:
            # Optimize: Get all paid notifications and late installments in single queries
            # Use list comprehension for better performance
            paid_notifications = PaidNotification.query.filter_by(request_id=request_id).all()
            late_installments = LateInstallment.query.filter_by(request_id=request_id).all()
            
            # Create sets for O(1) lookup instead of O(n) list search
            paid_dates = {paid.paid_date for paid in paid_notifications}
            late_dates = {late.payment_date for late in late_installments}
            
            # Calculate total paid and remaining amounts
            total_paid_amount = 0
            
            # Use list comprehension for better performance
            for entry in schedule:
                # Check if this installment is already paid (use the is_paid field from the schedule)
                is_paid = entry.is_paid
                # Check if this installment is marked late (optimized lookup)
                is_late = entry.payment_date in late_dates
                
                # If this installment is paid, add its amount to total paid
                if is_paid:
                    total_paid_amount += entry.amount
                
                schedule_rows.append({
                    'schedule_id': entry.schedule_id,
                    'date': entry.payment_date,
                    'payment_date': entry.payment_date,  # Add both for compatibility
                    'amount': entry.amount,
                    'is_paid': is_paid,
                    'is_late': is_late,
                    'receipt_path': entry.receipt_path,
                    'invoice_path': entry.invoice_path,
                    'has_been_edited': entry.has_been_edited
                })
    
    # Determine the manager's name for display
    manager_name = None
    temporary_manager_name = None
    
    # CRITICAL: For PAYMENT REQUESTS, check department-level temporary manager based on request_type
    # This applies to ALL requests (old and new), regardless of per-request temporary manager
    # Priority: Department-level temporary manager (based on request_type) > Per-request temporary manager
    # For payment requests, only show temporary managers assigned for:
    #   - "Finance Payment Request" OR
    #   - "Both Payment and Item Request"
    # DO NOT show temporary managers assigned only for "Procurement Item Request"
    dt = None
    try:
        req_dept = (req.department or '').strip()
        print(f"=== PAYMENT REQUEST TEMP MANAGER LOOKUP ===")
        print(f"Request ID: {request_id}, Department: '{req_dept}' (length: {len(req_dept)})")
        print(f"Per-request temporary_manager_id: {req.temporary_manager_id}")
        
        if req_dept:
            # Step 1: Query ONLY temporary managers that are valid for payment requests
            # This explicitly excludes "Procurement Item Request" only entries
            payment_temp_managers = DepartmentTemporaryManager.query.filter(
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).all()
            
            print(f"Found {len(payment_temp_managers)} temporary manager(s) for payment requests")
            
            # Normalize request department for comparison
            req_dept_normalized = req_dept.lower().strip()
            
            # Step 2: Priority 1 - Look for exact "Finance Payment Request" match first
            for temp_dt in payment_temp_managers:
                dt_dept = (temp_dt.department or '').strip()
                dt_dept_normalized = dt_dept.lower().strip()
                
                print(f"  Checking: dept='{dt_dept}' (normalized: '{dt_dept_normalized}'), request_type='{temp_dt.request_type}', manager_id={temp_dt.temporary_manager_id}")
                
                if dt_dept_normalized == req_dept_normalized and temp_dt.request_type == 'Finance Payment Request':
                    dt = temp_dt
                    print(f"  ‚úì MATCHED 'Finance Payment Request'! Selected: manager_id={dt.temporary_manager_id}")
                    break
            
            # Step 3: Priority 2 - If no exact match, look for "Both Payment and Item Request"
            if not dt:
                for temp_dt in payment_temp_managers:
                    dt_dept = (temp_dt.department or '').strip()
                    dt_dept_normalized = dt_dept.lower().strip()
                    
                    if dt_dept_normalized == req_dept_normalized and temp_dt.request_type == 'Both Payment and Item Request':
                        dt = temp_dt
                        print(f"  ‚úì MATCHED 'Both Payment and Item Request'! Selected: manager_id={dt.temporary_manager_id}")
                        break
            
            if not dt:
                print(f"  ‚úó No matching payment request temporary manager found for department '{req_dept}'")
                # Show all available for debugging
                print(f"  Available payment request temp managers:")
                for temp_dt in payment_temp_managers:
                    dt_dept = (temp_dt.department or '').strip()
                    print(f"    - dept='{dt_dept}', request_type='{temp_dt.request_type}', manager_id={temp_dt.temporary_manager_id}")
    except Exception as e:
        print(f"ERROR: Exception finding payment request temporary manager: {e}")
        import traceback
        traceback.print_exc()
        dt = None
    
    # Step 4: Get the user name for the selected department-level temporary manager
    # This takes priority over per-request temporary manager for display purposes
    if dt:
        try:
            temp_user = User.query.get(dt.temporary_manager_id)
            if temp_user:
                temporary_manager_name = temp_user.name
                print(f"=== FINAL RESULT: temporary_manager_name = '{temp_user.name}' (ID: {dt.temporary_manager_id}, request_type: '{dt.request_type}') ===")
            else:
                print(f"WARNING: Temporary manager user not found for ID: {dt.temporary_manager_id}")
        except Exception as e:
            print(f"ERROR: Exception getting temporary manager user: {e}")
            pass
    else:
        # Fallback: If no department-level temporary manager, check per-request temporary manager
        if req.temporary_manager_id:
            temp_manager = User.query.get(req.temporary_manager_id)
            if temp_manager:
                temporary_manager_name = temp_manager.name
                print(f"=== FALLBACK: Using per-request temporary manager: '{temp_manager.name}' (ID: {req.temporary_manager_id}) ===")
        else:
            print(f"=== FINAL RESULT: No temporary manager found, temporary_manager_name = None ===")
    
    # Determine manager name for all statuses (pending and completed)
    if req.user.manager_id:
        # Get the manager's name from the manager_id
        manager = User.query.get(req.user.manager_id)
        if manager:
            manager_name = manager.name
        else:
            # If manager_id exists but user not found, try to find Department Manager
            dept_manager = User.query.filter_by(role='Department Manager', department=req.department).first()
            if dept_manager:
                manager_name = dept_manager.name
    else:
        # If no manager_id is set, find the Department Manager for the requestor's department
        dept_manager = User.query.filter_by(role='Department Manager', department=req.department).first()
        if dept_manager:
            manager_name = dept_manager.name
        elif req.department in ['Operation', 'Project']:
            # For Operation and Project, try Operation Manager as fallback
            operation_manager = User.query.filter_by(role='Operation Manager').first()
            if operation_manager:
                manager_name = operation_manager.name
        elif req.department == 'Office':
            # For Office, fallback to the General Manager
            gm_user_fallback = User.query.filter_by(role='GM').first()
            if gm_user_fallback:
                manager_name = gm_user_fallback.name
        
    # Also resolve GM and Operation Manager names (used for Department Manager submissions)
    gm_user = User.query.filter_by(role='GM').first()
    gm_name = gm_user.name if gm_user else 'General Manager'
    op_manager_user = User.query.filter_by(role='Operation Manager').first()
    op_manager_name = op_manager_user.name if op_manager_user else 'Operation Manager'
    
    # Get all proof files for this request grouped by batch
    proof_files = []
    proof_batches = []
    if req.status in ['Proof Sent', 'Proof Rejected', 'Completed', 'Recurring']:
        import os
        import glob
        upload_folder = app.config['UPLOAD_FOLDER']
        # Look for all proof files for this request (files starting with proof_{request_id}_)
        proof_pattern = os.path.join(upload_folder, f"proof_{request_id}_*")
        all_files = [os.path.basename(f) for f in glob.glob(proof_pattern)]
        # Parse batch numbers from filenames
        from collections import defaultdict
        batches = defaultdict(list)
        for fname in all_files:
            batch_num = 1
            try:
                prefix = f"proof_{request_id}_"
                if fname.startswith(prefix + "b"):
                    after = fname[len(prefix)+1:]  # skip 'b'
                    part = after.split('_', 1)[0]
                    batch_num = int(part)
            except Exception:
                batch_num = 1
            batches[batch_num].append(fname)

        # Sort files within each batch by filename (timestamp included)
        for bn in batches:
            batches[bn].sort(reverse=True)

        # Build ordered list of batches, latest first
        ordered_batch_nums = sorted(batches.keys(), reverse=True)
        for bn in ordered_batch_nums:
            proof_batches.append({
                'batch_num': bn,
                'files': batches[bn]
            })

        # Also keep a flat list for legacy sections if any
        proof_files = [f for bn in ordered_batch_nums for f in batches[bn]]
    
    # Get current server time for timer calculations
    current_server_time = datetime.utcnow()
    
    # Get finance admin notes for this request (ordered by creation date, newest first)
    finance_notes = FinanceAdminNote.query.filter_by(request_id=request_id).order_by(FinanceAdminNote.created_at.desc()).all()
    
    # Ensure finance approval duration is calculated if needed
    calculate_finance_approval_duration(req)
    if req.finance_approval_duration_minutes is not None:
        db.session.commit()
    
    # Get list of managers for IT dropdown (only if user is IT Staff or IT Department Manager)
    available_managers = []
    if current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']:
        available_managers = User.query.filter(
            User.role.in_(['Department Manager', 'GM', 'Operation Manager', 'Finance Admin'])
        ).order_by(User.department, User.name).all()
    
    # Prepare receipt files for template (both requestor and finance admin receipts)
    requestor_receipts = []
    finance_admin_receipts = []
    import json
    
    # Get requestor receipts
    if req.requestor_receipt_path:
        try:
            requestor_receipts = json.loads(req.requestor_receipt_path)
        except (json.JSONDecodeError, TypeError, ValueError):
            # Fallback: try Python literal (in case it's a repr list)
            try:
                import ast
                parsed = ast.literal_eval(req.requestor_receipt_path)
                if isinstance(parsed, list):
                    requestor_receipts = parsed
                elif isinstance(parsed, str) and parsed:
                    requestor_receipts = [parsed]
            except Exception:
                # Final fallback: split on commas
                if isinstance(req.requestor_receipt_path, str) and req.requestor_receipt_path:
                    if ',' in req.requestor_receipt_path:
                        requestor_receipts = [p.strip() for p in req.requestor_receipt_path.split(',') if p.strip()]
                    else:
                        requestor_receipts = [req.requestor_receipt_path]
    
    # Get finance admin receipts
    if req.finance_admin_receipt_path:
        try:
            finance_admin_receipts = json.loads(req.finance_admin_receipt_path)
        except (json.JSONDecodeError, TypeError, ValueError):
            # Fallback: try Python literal (in case it's a repr list)
            try:
                import ast
                parsed = ast.literal_eval(req.finance_admin_receipt_path)
                if isinstance(parsed, list):
                    finance_admin_receipts = parsed
                elif isinstance(parsed, str) and parsed:
                    finance_admin_receipts = [parsed]
            except Exception:
                # Final fallback: split on commas
                if isinstance(req.finance_admin_receipt_path, str) and req.finance_admin_receipt_path:
                    if ',' in req.finance_admin_receipt_path:
                        finance_admin_receipts = [p.strip() for p in req.finance_admin_receipt_path.split(',') if p.strip()]
                    else:
                        finance_admin_receipts = [req.finance_admin_receipt_path]
    
    # Backward compatibility: If new columns are empty but legacy receipt_path exists,
    # try to determine which column it should be in based on request status
    if not requestor_receipts and not finance_admin_receipts and req.receipt_path:
        try:
            legacy_receipts = json.loads(req.receipt_path)
            if isinstance(legacy_receipts, list):
                # Check status to determine if it's from requestor or finance admin
                finance_statuses = ['Proof Pending', 'Proof Sent', 'Proof Rejected', 'Recurring', 'Completed']
                if req.approver and req.status in finance_statuses:
                    finance_admin_receipts = legacy_receipts
                else:
                    requestor_receipts = legacy_receipts
        except (json.JSONDecodeError, TypeError):
            # Handle legacy single file format
            if isinstance(req.receipt_path, str):
                finance_statuses = ['Proof Pending', 'Proof Sent', 'Proof Rejected', 'Recurring', 'Completed']
                if req.approver and req.status in finance_statuses:
                    finance_admin_receipts = [req.receipt_path]
                else:
                    requestor_receipts = [req.receipt_path]
    
    # Provide the same option lists used by the New Request form so edit UI can mirror creation behavior
    from models import RequestType, Branch
    # IMPORTANT: Request Type options should be based on the ORIGINAL requestor department,
    # not on later changes to the request's Department field (e.g., when a manager updates it).
    original_department_for_types = getattr(req.user, 'department', None) or req.department
    # Map Office ‚Üí Management for request type catalog
    effective_department = 'Management' if original_department_for_types == 'Office' else original_department_for_types
    available_request_types = RequestType.query.filter_by(department=effective_department, is_active=True).order_by(RequestType.name).all()
    available_branches = get_branches_ordered_by_location()
    # Department options for manager/approver department changes
    departments = ['Management', 'Finance', 'Operation', 'PR', 'Maintenance', 'Marketing',
                   'Logistic', 'HR', 'Quality Control', 'Procurement', 'IT', 'Customer Service',
                   'Project', 'Sales']

    was_just_edited = request.args.get('edited') == '1'
    edited_fields_param = request.args.get('edited_fields', '')
    edited_fields = [f for f in edited_fields_param.split(',') if f]
    # Fetch all-time edited fields from audit table (created on demand)
    try:
        result = db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS request_field_edits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                request_id INTEGER NOT NULL,
                field_name TEXT NOT NULL,
                first_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(request_id, field_name)
            );
        '''))
        result.close()
        rows = db.session.execute(db.text('SELECT field_name FROM request_field_edits WHERE request_id = :rid'), { 'rid': req.request_id }).fetchall()
        cumulative_fields = [r[0] for r in rows]
    except Exception:
        cumulative_fields = []
    # Union of current-save markers and cumulative markers
    edited_fields_all = sorted(set(edited_fields) | set(cumulative_fields))
    
    # Fetch return reason history (for multiple returns)
    return_reason_history = ReturnReasonHistory.query.filter_by(request_id=req.request_id).order_by(ReturnReasonHistory.returned_at.desc()).all()
    
    # Check if current user can edit this request (for "Returned to Manager" or "Returned to Requestor" status)
    can_edit_request = False
    # Flag used in the template: when status is "Pending Manager Approval", certain approvers
    # (GM, Operation Manager, assigned managers, temporary manager) can only edit the Department field
    can_edit_department_only = False
    if req.status == 'Returned to Manager':
        # IT can always edit
        if current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']:
            can_edit_request = True
        else:
            # Check if user is an authorized manager approver
            authorized_approvers = get_authorized_manager_approvers(req)
            if current_user in authorized_approvers:
                can_edit_request = True
    elif req.status == 'Returned to Requestor':
        # Only the requestor can edit their returned request
        if req.user_id == current_user.user_id:
            can_edit_request = True
    elif req.status == 'Pending Manager Approval':
        # IT can always edit
        if current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']:
            can_edit_request = True
        # GM, Operation Manager, assigned managers, temporary manager (including IT Department Manager
        # when they are the assigned manager) can edit Department only
        authorized_approvers = get_authorized_manager_approvers(req)
        if current_user in authorized_approvers:
            can_edit_department_only = True
    
    # Determine if current user is the department-level temporary manager for this request's department
    try:
        _dt_for_req = DepartmentTemporaryManager.query.filter(
            DepartmentTemporaryManager.department == (req.department or ''),
            db.or_(
                DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
            )
        ).first()
    except Exception:
        _dt_for_req = None
    is_dept_temp_for_req = bool(_dt_for_req and getattr(_dt_for_req, 'temporary_manager_id', None) == current_user.user_id)

    return render_template('view_request.html', request=req, user=current_user, schedule_rows=schedule_rows, total_paid_amount=float(total_paid_amount), manager_name=manager_name, temporary_manager_name=temporary_manager_name, available_managers=available_managers, proof_files=proof_files, proof_batches=proof_batches, current_server_time=current_server_time, finance_notes=finance_notes, gm_name=gm_name, op_manager_name=op_manager_name, requestor_receipts=requestor_receipts, finance_admin_receipts=finance_admin_receipts, available_request_types=available_request_types, available_branches=available_branches, departments=departments, was_just_edited=was_just_edited, edited_fields=edited_fields_all, can_schedule_one_time=can_schedule_one_time, one_time_scheduled_by=one_time_scheduled_by, can_edit_request=can_edit_request, return_reason_history=return_reason_history, can_edit_department_only=can_edit_department_only, is_dept_temp_for_req=is_dept_temp_for_req)


@app.route('/request/<int:request_id>/schedule_one_time_payment', methods=['POST'])
@login_required
def schedule_one_time_payment(request_id):
    """Allow authorized users to set a payment date for ONE-TIME requests (optional)."""
    req = PaymentRequest.query.get_or_404(request_id)

    # Only for One-Time requests
    if req.recurring == 'Recurring':
        flash('You can only schedule a payment date for one-time requests.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    # Only allowed when request is in these statuses
    if req.status not in ['Pending Manager Approval', 'Pending Finance Approval']:
        flash('Payment date can only be scheduled when status is Pending Manager Approval or Pending Finance Approval.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    # Authorization logic mirrors the view logic
    authorized = False
    if getattr(req, 'temporary_manager_id', None):
        authorized = (req.temporary_manager_id == current_user.user_id)
    else:
        if current_user.role in ['GM', 'Operation Manager']:
            authorized = True
        elif current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']:
            authorized = True
        elif getattr(req.user, 'manager_id', None) == current_user.user_id:
            authorized = True
        elif current_user.role == 'Department Manager' and current_user.department == req.department:
            authorized = True

    if not authorized:
        flash('You are not authorized to schedule a payment date for this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    payment_date_str = request.form.get('payment_date', '').strip()
    if not payment_date_str:
        flash('Please select a payment date.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    try:
        from datetime import datetime as _dt
        payment_date_val = _dt.strptime(payment_date_str, '%Y-%m-%d').date()
    except Exception:
        flash('Invalid payment date format.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    # Persist - automatically change payment type to "Scheduled One-Time" when payment date is set
    req.payment_date = payment_date_val
    # Automatically update payment type to "Scheduled One-Time" if it's currently "One-Time" or None
    if req.recurring != 'Recurring':
        req.recurring = 'Scheduled One-Time'
    req.updated_at = datetime.utcnow()
    db.session.commit()

    # Audit and realtime
    dept_text = get_department_text_for_notification(req)
    log_action(
        f"Request #{request_id} from {getattr(req.user, 'name', 'Unknown')} {dept_text} department has been scheduled for {payment_date_val} by {current_user.name}"
    )
    
    # Notify all authorized users
    try:
        title = "One-time Payment Date Scheduled"
        msg = (
            f"Request #{request_id} from {getattr(req.user, 'name', 'Unknown')} {dept_text} department "
            f"has been scheduled for {payment_date_val.strftime('%B %d, %Y')} by {current_user.name}."
        )
        notified_user_ids = set()

        def add_user(u):
            if u and getattr(u, 'user_id', None):
                notified_user_ids.add(u.user_id)

        # Requestor
        add_user(req.user)

        # Department Manager of the requestor's department (all in that role/department)
        try:
            dept_managers = User.query.filter_by(role='Department Manager', department=req.user.department).all()
        except Exception:
            dept_managers = []
        for u in dept_managers:
            add_user(u)

        # Assigned Manager (manager_id)
        if getattr(req.user, 'manager_id', None):
            assigned_manager = User.query.get(req.user.manager_id)
            add_user(assigned_manager)

        # General Managers (all)
        try:
            gms = User.query.filter_by(role='GM').all()
        except Exception:
            gms = []
        for u in gms:
            add_user(u)

        # Operation Managers (all)
        try:
            opms = User.query.filter_by(role='Operation Manager').all()
        except Exception:
            opms = []
        for u in opms:
            add_user(u)

        # Temporary Manager (if any)
        if getattr(req, 'temporary_manager_id', None):
            temp_manager = User.query.get(req.temporary_manager_id)
            add_user(temp_manager)

        # Finance Admin notifications (conditional rules)
        try:
            finance_admins = User.query.filter_by(role='Finance Admin').all()
        except Exception:
            finance_admins = []
        # Find Abdalaziz specifically
        abdalaziz = next((u for u in finance_admins if u and u.name == 'Abdalaziz Al-Brashdi'), None)
        others_finance_admins = [u for u in finance_admins if u and (not abdalaziz or u.user_id != abdalaziz.user_id)]

        # Notify Abdalaziz only if (is requestor OR assigned manager) AND status is PFA
        if abdalaziz and req.status == 'Pending Finance Approval':
            if (req.user_id == abdalaziz.user_id) or (getattr(req.user, 'manager_id', None) == abdalaziz.user_id):
                add_user(abdalaziz)

        # Notify other Finance Admins only if they are the requestor AND status is PFA
        if req.status == 'Pending Finance Approval':
            for fa in others_finance_admins:
                if req.user_id == fa.user_id:
                    add_user(fa)

        # IT Department: IT Staff + IT Department Managers
        try:
            it_staff = User.query.filter_by(department='IT', role='IT Staff').all()
        except Exception:
            it_staff = []
        try:
            it_mgrs = User.query.filter_by(department='IT', role='Department Manager').all()
        except Exception:
            it_mgrs = []
        for u in it_staff + it_mgrs:
            add_user(u)

        # Create notifications (deduped)
        for uid in notified_user_ids:
            create_notification(
                user_id=uid,
                title=title,
                message=msg,
                notification_type='one_time_payment_scheduled',
                request_id=request_id
            )

        # Emit broadcast signal for clients to refresh notifications
        try:
            socketio.emit('new_notification', {
                'title': title,
                'message': msg,
                'type': 'one_time_payment_scheduled',
                'request_id': request_id
            }, room='all_users')
            socketio.emit('notification_update', {
                'action': 'new_notification',
                'type': 'one_time_payment_scheduled'
            }, room='all_users')
        except Exception as e:
            print(f"DEBUG: WebSocket emit failed for notifications: {e}")
    except Exception as e:
        print(f"DEBUG: Failed to create notifications for schedule_one_time_payment: {e}")
    try:
        socketio.emit('request_updated', {
            'request_id': request_id,
            'one_time_payment_scheduled': True,
            'payment_date': payment_date_val.isoformat()
        })
    except Exception as e:
        print(f"DEBUG: socket emit failed for schedule_one_time_payment: {e}")

    flash('Payment date scheduled successfully.', 'success')
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/edit', methods=['POST'])
@login_required
def edit_request(request_id):
    """Save inline edits by IT users, assigned managers, GM, and Operation Manager when status is Pending Manager Approval or Returned to Manager. Also allows Finance Admin to edit Request Type only when status is Pending Finance Approval. Allows requestors to edit when status is Returned to Requestor."""
    req = PaymentRequest.query.get_or_404(request_id)

    # Check if Finance Admin is editing Request Type only for Pending Finance Approval status
    is_finance_admin_edit = (current_user.role == 'Finance Admin' and req.status == 'Pending Finance Approval')
    
    # Check if requestor is editing their own returned request
    is_requestor_edit = (req.user_id == current_user.user_id and req.status == 'Returned to Requestor')
    
    # Status gate - allow editing when status is "Pending Manager Approval" or "Returned to Manager" or "Returned to Requestor"
    # OR when Finance Admin is editing Request Type for "Pending Finance Approval"
    if req.status not in ['Pending Manager Approval', 'Returned to Manager', 'Pending Finance Approval', 'Returned to Requestor']:
        flash('This request cannot be edited in its current status.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)

    # If status is "Pending Finance Approval" but user is not Finance Admin, deny access
    if req.status == 'Pending Finance Approval' and not is_finance_admin_edit:
        flash('This request cannot be edited in its current status.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    # If status is "Returned to Requestor" but user is not the requestor, deny access
    if req.status == 'Returned to Requestor' and not is_requestor_edit:
        flash('Only the requestor can edit a request that has been returned to them.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)

    # Authorization: 
    # - IT Staff and IT Department Manager can always edit when status is "Pending Manager Approval" or "Returned to Manager"
    # - Assigned managers, GM, and Operation Manager can edit when status is "Returned to Manager"
    # - Finance Admin can edit Request Type only when status is "Pending Finance Approval"
    # - Requestor can edit when status is "Returned to Requestor"
    is_authorized = False
    # Flag for manager/GM/Operation Manager/temporary manager editing ONLY department while status is Pending Manager Approval
    is_manager_pending_edit = False
    
    # Finance Admin can edit Request Type only for Pending Finance Approval
    if is_finance_admin_edit:
        is_authorized = True
    # IT department can always edit
    elif current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']:
        is_authorized = True
    # For "Returned to Manager" status, also allow assigned managers, GM, and Operation Manager
    elif req.status == 'Returned to Manager':
        # Check if user is an authorized manager approver
        authorized_approvers = get_authorized_manager_approvers(req)
        if current_user in authorized_approvers:
            is_authorized = True
    # For "Pending Manager Approval" status, allow assigned managers, GM, Operation Manager, and temporary manager,
    # but they will only be able to edit the Department field (handled below)
    elif req.status == 'Pending Manager Approval':
        authorized_approvers = get_authorized_manager_approvers(req)
        if current_user in authorized_approvers:
            is_authorized = True
            # IT already handled above with full-edit permissions; here we restrict only non-IT approvers
            if not (current_user.department == 'IT' and current_user.role in ['IT Staff', 'Department Manager']):
                is_manager_pending_edit = True
    # For "Returned to Requestor" status, allow the requestor to edit
    elif is_requestor_edit:
        is_authorized = True
    
    if not is_authorized:
        flash('You are not authorized to edit this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    # Collect form fields (only those we allow)
    # Track original values to compute which fields changed
    # Normalize amount for comparison (format to 3 decimal places to match display)
    def norm_amount(v):
        if not v:
            return ''
        try:
            # Convert to float and format consistently
            return f"{float(v):.3f}"
        except (ValueError, TypeError):
            return str(v).strip()
    original = {
        'request_type': req.request_type or '',
        'branch_name': req.branch_name or '',
        'person_company': req.person_company or '',
        'company_name': req.person_company or '',
        'purpose': req.purpose or '',
        'bank_name': req.bank_name or '',
        'account_name': req.account_name or '',
        'account_number': req.account_number or '',
        'amount': norm_amount(req.amount),
        'department': req.department or '',
        'payment_method': req.payment_method or ''
    }

    # If this is a manager/GM/Operation Manager/temporary manager editing while status is
    # "Pending Manager Approval", restrict them so they can ONLY change the Department field.
    if is_manager_pending_edit and req.status == 'Pending Manager Approval':
        new_department = (request.form.get('department') or '').strip()
        if new_department:
            req.department = new_department

    # For all other cases (IT, Returned to Manager, Finance Admin as configured),
    # apply the normal Request Type editing logic.
    if not (is_manager_pending_edit and req.status == 'Pending Manager Approval'):
        new_request_type = request.form.get('request_type') or req.request_type
        others_description = (request.form.get('others_description') or '').strip()
        if new_request_type == 'Others':
            if not others_description:
                flash('Please specify the type of request for "Others".', 'error')
                return redirect(url_for('view_request', request_id=request_id))
            new_request_type = f"Others: {others_description}"

        req.request_type = new_request_type

    # For all non-Finance-Admin edits, if a Department value was submitted, apply it.
    # This covers IT users (including IT Department Manager) and any other flows where
    # the Department field is legitimately editable.
    if not is_finance_admin_edit:
        new_department_general = (request.form.get('department') or '').strip()
        if new_department_general:
            req.department = new_department_general
    
    # For Finance Admin editing Request Type only in Pending Finance Approval status,
    # skip updating all other fields
    if not is_finance_admin_edit and not (is_manager_pending_edit and req.status == 'Pending Manager Approval'):
        req.branch_name = request.form.get('branch_name') or req.branch_name
        req.person_company = request.form.get('person_company') or req.person_company
        req.person_company = request.form.get('company_name') or req.person_company
        req.purpose = request.form.get('purpose') or req.purpose
        req.account_name = request.form.get('account_name') or req.account_name
        req.payment_method = request.form.get('payment_method') or req.payment_method
        
        # Handle payment method specific fields
        if req.payment_method == 'Cheque':
            # Clear account_number for Cheque, keep bank_name
            req.account_number = ''
            req.bank_name = request.form.get('bank_name') or req.bank_name
        elif req.payment_method == 'Cash':
            # Clear account_number for Cash, keep bank_name
            req.account_number = ''
            req.bank_name = request.form.get('bank_name') or req.bank_name
        else:
            # Card - keep both account_number and bank_name
            req.account_number = request.form.get('account_number') or req.account_number
            req.bank_name = request.form.get('bank_name') or req.bank_name
        
        # Handle amount field
        amount_str = request.form.get('amount', '').strip()
        if amount_str:
            try:
                amount_float = float(amount_str)
                if amount_float >= 0:
                    req.amount = amount_float
            except (ValueError, TypeError):
                # Invalid amount, keep existing value
                pass

        # Server-side validation: prevent saving if any core fields become empty.
        # This mirrors the required fields on the New Request form.
        def _empty(val):
            if val is None:
                return True
            if isinstance(val, str):
                return val.strip() == ''
            return False

        if req.status in ['Pending Manager Approval', 'Returned to Manager', 'Returned to Requestor']:
            missing_fields = []

            # Helper: prefer submitted value if the field was part of this form post;
            # only fall back to current DB value if the user didn't touch the field.
            def field_empty(field_name, current_value):
                submitted = request.form.get(field_name, None)
                if submitted is not None:
                    # User submitted this field; treat blank/placeholder as empty
                    return _empty(submitted)
                return _empty(current_value)

            # Request Type
            if field_empty('request_type', req.request_type):
                missing_fields.append('Request Type')
            # Person/Company Name ‚Äì also consider select placeholder
            submitted_person = request.form.get('person_company', None)
            submitted_person_select = request.form.get('person_company_select_edit', None)
            if (submitted_person is not None or submitted_person_select is not None):
                # User interacted with this field; both must be non-empty/meaningful
                if _empty(submitted_person) and _empty(submitted_person_select):
                    missing_fields.append('Person/Company Name')
            elif _empty(req.person_company):
                missing_fields.append('Person/Company Name')
            # Department
            if field_empty('department', req.department):
                missing_fields.append('Department')
            # Purpose
            if field_empty('purpose', req.purpose):
                missing_fields.append('Purpose/Description')
            # Payment Method
            if field_empty('payment_method', req.payment_method):
                missing_fields.append('Payment Method')
            # Bank Name
            if field_empty('bank_name', req.bank_name):
                missing_fields.append('Bank Name')
            # Account Name
            if field_empty('account_name', req.account_name):
                missing_fields.append('Account Name')
            # Account Number
            if field_empty('account_number', req.account_number):
                missing_fields.append('Account Number')
            # Amount (allow 0 but not None/blank)
            submitted_amount = request.form.get('amount', None)
            if submitted_amount is not None:
                if _empty(submitted_amount):
                    missing_fields.append('Amount')
            elif req.amount is None or _empty(str(req.amount)):
                missing_fields.append('Amount')

            if missing_fields:
                friendly_list = ', '.join(missing_fields)
                flash(f'The following fields cannot be empty when saving edits: {friendly_list}.', 'error')
                return redirect(url_for('view_request', request_id=request_id))

    # Handle file management (only when status is "Returned to Manager" or "Returned to Requestor" and not Finance Admin edit).
    # Manager/GM/Operation Manager/temporary manager restricted to Department only while
    # status is "Pending Manager Approval" so file handling is unaffected.
    if req.status in ['Returned to Manager', 'Returned to Requestor'] and not is_finance_admin_edit:
        # Handle file deletions
        delete_files = request.form.getlist('delete_files')
        if delete_files:
            # Get existing requestor receipts
            existing_receipts = []
            if req.requestor_receipt_path:
                try:
                    existing_receipts = json.loads(req.requestor_receipt_path)
                    if not isinstance(existing_receipts, list):
                        existing_receipts = [req.requestor_receipt_path]
                except (json.JSONDecodeError, TypeError):
                    existing_receipts = [req.requestor_receipt_path] if req.requestor_receipt_path else []
            
            # Remove deleted files and log each deletion
            deleted_file_names = []
            for filename_to_delete in delete_files:
                if filename_to_delete in existing_receipts:
                    existing_receipts.remove(filename_to_delete)
                    # Extract readable filename (remove timestamp prefix if present)
                    readable_filename = filename_to_delete.split('_', 3)[-1] if '_' in filename_to_delete else filename_to_delete
                    deleted_file_names.append(readable_filename)
                    # Delete the physical file
                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename_to_delete)
                    if os.path.exists(filepath):
                        try:
                            os.remove(filepath)
                        except Exception as e:
                            app.logger.warning(f"Failed to delete file {filename_to_delete}: {e}")
            
            # Log file deletions in audit log
            if deleted_file_names:
                requestor_name = getattr(req.user, 'name', 'Unknown')
                files_list = ', '.join(deleted_file_names)
                log_action(
                    f"Deleted receipt file(s) from payment request #{request_id} ({requestor_name}): {files_list}"
                )
            
            # Update database
            if existing_receipts:
                req.requestor_receipt_path = json.dumps(existing_receipts)
            else:
                req.requestor_receipt_path = None
        
        # Handle file uploads
        if 'receipt_files' in request.files:
            receipt_files = request.files.getlist('receipt_files')
            if receipt_files and any(f.filename for f in receipt_files):
                uploaded_files = []
                allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
                max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                
                # Get existing requestor receipts (after deletions)
                existing_receipts = []
                if req.requestor_receipt_path:
                    try:
                        existing_receipts = json.loads(req.requestor_receipt_path)
                        if not isinstance(existing_receipts, list):
                            existing_receipts = [req.requestor_receipt_path]
                    except (json.JSONDecodeError, TypeError):
                        existing_receipts = [req.requestor_receipt_path] if req.requestor_receipt_path else []
                
                # Process new files
                for receipt_file in receipt_files:
                    if receipt_file and receipt_file.filename:
                        # Validate file extension first
                        file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                        if file_extension not in allowed_extensions:
                            flash(f'Invalid file type for "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
                            return redirect(url_for('view_request', request_id=request_id))
                        
                        # Read file content once for size check and save
                        file_content = receipt_file.read()
                        file_size = len(file_content)
                        if file_size > max_file_size:
                            flash(f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
                            return redirect(url_for('view_request', request_id=request_id))
                        
                        # Generate unique filename
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        filename = secure_filename(receipt_file.filename)
                        filename = f"receipt_{request_id}_{timestamp}_{filename}"
                        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                        
                        # Save file content
                        with open(filepath, 'wb') as f:
                            f.write(file_content)
                        
                        uploaded_files.append(filename)
                
                # Combine existing and new files
                if uploaded_files:
                    all_receipts = existing_receipts + uploaded_files
                    req.requestor_receipt_path = json.dumps(all_receipts)
                    log_action(f"Manager added {len(uploaded_files)} file(s) to request #{request_id}")

    # If requestor is editing a "Returned to Requestor" request, change status back to "Pending Manager Approval"
    if is_requestor_edit and req.status == 'Returned to Requestor':
        req.status = 'Pending Manager Approval'
        req.rejection_reason = None  # Clear the return reason
        req.updated_at = datetime.utcnow()
        # Start manager approval timing
        req.manager_approval_start_time = datetime.utcnow()
        log_action(f"Request #{request_id} resubmitted by requestor after editing - status changed to Pending Manager Approval")
        
        # Notify all authorized managers who can approve this request
        authorized_approvers = get_authorized_manager_approvers(req)
        dept_text = get_department_text_for_notification(req)
        for approver in authorized_approvers:
            create_notification(
                user_id=approver.user_id,
                title="Request Resubmitted After Editing",
                message=f"Payment request #{request_id} {dept_text} department has been edited and resubmitted by {req.user.name} - requires your approval",
                notification_type="new_submission",
                request_id=request_id
            )

    db.session.commit()

    # Build edited_fields list for UI badges: only fields submitted AND changed this save
    def norm(v):
        return (v or '').strip()
    # Use norm_amount function defined above for amount normalization
    updated = {
        'request_type': req.request_type or '',
        'branch_name': req.branch_name or '',
        'person_company': req.person_company or '',
        'company_name': req.person_company or '',
        'purpose': req.purpose or '',
        'bank_name': req.bank_name or '',
        'account_name': req.account_name or '',
        'account_number': req.account_number or '',
        'amount': norm_amount(req.amount),  # Normalize amount for consistent comparison
        'department': req.department or '',
        'payment_method': req.payment_method or ''
    }
    submitted_keys = set(request.form.keys())
    # Map form field names to our keys
    form_to_key = {
        'request_type': 'request_type',
        'others_description': 'request_type',  # affects request_type
        'branch_name': 'branch_name',
        'person_company': 'person_company',
        'company_name': 'company_name',
        'purpose': 'purpose',
        'bank_name': 'bank_name',
        'account_name': 'account_name',
        'account_number': 'account_number',
        'amount': 'amount',
        'item_name': 'item_name',
        'department': 'department',
        'payment_method': 'payment_method'
    }
    candidate_keys = set(form_to_key[k] for k in submitted_keys if k in form_to_key)
    # Use special normalization for amount field
    edited_fields = []
    for key in candidate_keys:
        if key == 'amount':
            # Use amount-specific normalization
            if norm_amount(original.get(key, '')) != norm_amount(updated.get(key, '')):
                edited_fields.append(key)
        else:
            # Use standard normalization for other fields
            if norm(original.get(key, '')) != norm(updated.get(key, '')):
                edited_fields.append(key)

    # Persist cumulative edited fields (create table if missing, upsert per field)
    try:
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS request_field_edits (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                request_id INTEGER NOT NULL,
                field_name TEXT NOT NULL,
                first_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_edited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(request_id, field_name)
            );
        '''))
        for key in edited_fields:
            db.session.execute(db.text('''
                INSERT INTO request_field_edits (request_id, field_name) VALUES (:rid, :fname)
                ON CONFLICT(request_id, field_name) DO UPDATE SET last_edited_at = CURRENT_TIMESTAMP
            '''), { 'rid': request_id, 'fname': key })
        # Also persist detailed edit history per field (old/new values)
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS request_field_edit_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                request_id INTEGER NOT NULL,
                field_name TEXT NOT NULL,
                old_value TEXT,
                new_value TEXT,
                edited_by_user_id INTEGER,
                edited_by_name TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        '''))
        for key in edited_fields:
            db.session.execute(db.text('''
                INSERT INTO request_field_edit_logs (request_id, field_name, old_value, new_value, edited_by_user_id, edited_by_name)
                VALUES (:rid, :fname, :oldv, :newv, :uid, :uname)
            '''), {
                'rid': request_id,
                'fname': key,
                'oldv': str(original.get(key, '')),
                'newv': str(updated.get(key, '')),
                'uid': current_user.user_id,
                'uname': current_user.name
            })
        db.session.commit()
    except Exception as e:
        app.logger.warning(f"Failed to persist edited fields: {e}")

    # Create notifications for all authorized persons
    try:
        recipients = set()
        # Requestor
        recipients.add(req.user_id)
        # All IT department users (Staff + Department Manager)
        it_users = User.query.filter(User.department == 'IT', User.role.in_(['IT Staff', 'Department Manager'])).all()
        for u in it_users:
            recipients.add(u.user_id)
        # Assigned manager (direct manager)
        if getattr(req.user, 'manager_id', None):
            recipients.add(req.user.manager_id)
        # Department Manager(s) of the requestor's department (in addition to direct manager)
        dept_manager_users = User.query.filter_by(role='Department Manager', department=req.user.department).all()
        for u in dept_manager_users:
            if u.user_id != req.user_id:
                recipients.add(u.user_id)
        # Temporary manager
        if getattr(req, 'temporary_manager_id', None):
            recipients.add(req.temporary_manager_id)
        # GM(s)
        for u in User.query.filter_by(role='GM').all():
            recipients.add(u.user_id)
        # Operation Manager(s)
        for u in User.query.filter_by(role='Operation Manager').all():
            recipients.add(u.user_id)
        # Finance Admins are NOT notified here (unless they are the requestor, handled above)
        # EXCEPTION: Notify Finance Admins when status is "Returned to Manager" (they returned it and need to know if it's edited)
        finance_admin_user_ids = set()
        if req.status == 'Returned to Manager':
            finance_admin_users = User.query.filter_by(role='Finance Admin').all()
            for u in finance_admin_users:
                finance_admin_user_ids.add(u.user_id)
                recipients.add(u.user_id)

        title = 'Request Updated'
        requestor_name = getattr(req.user, 'name', 'Unknown')
        for user_id in recipients:
            if not user_id or user_id == current_user.user_id:
                continue
            if user_id == req.user_id:
                # Personalized message for the requestor
                message = f"Your request #{req.request_id} has been edited by {current_user.name}."
            elif req.status == 'Returned to Manager' and user_id in finance_admin_user_ids:
                # Special message for Finance Admin when request was returned
                message = f"Payment request #{req.request_id} from {requestor_name} (which you returned to manager) has been edited by {current_user.name}. Please review the changes."
            else:
                # Include requestor name for all others
                message = f"{requestor_name}'s request #{req.request_id} has been edited by {current_user.name}."
            create_notification(user_id, title, message, 'status_changed', request_id=req.request_id)
    except Exception as e:
        app.logger.warning(f"Failed to create edit notifications: {e}")

    # Real-time emit to all relevant rooms
    try:
        emit_request_update_to_all_rooms('request_updated', {
            'request_id': req.request_id,
            'status': req.status,
            'department': req.department,
            'request_type': req.request_type,
            'branch_name': req.branch_name,
            'action': 'edited'
        })
    except Exception:
        pass

    # Audit log entry
    try:
        requestor_name = getattr(req.user, 'name', 'Unknown')
        log_action(f"{requestor_name}'s request #{request_id} edited by {current_user.name} - type: {req.request_type}, branch: {req.branch_name}")
    except Exception:
        pass

    flash('Edits saved successfully.', 'success')
    # Preserve return_url if it was provided
    return_url = request.form.get('return_url') or request.args.get('return_url')
    redirect_params = {'request_id': request_id, 'tab': 'submit', 'edited': '1', 'edited_fields': ','.join(edited_fields)}
    if return_url:
        redirect_params['return_url'] = return_url
    return redirect(url_for('view_request', **redirect_params))


@app.route('/request/<int:request_id>/manager-add-file', methods=['POST'])
@login_required
def manager_add_file(request_id):
    """Manager adds a file to request when status is Returned to Manager"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check authorization - only managers can add files when status is "Returned to Manager"
    if req.status != 'Returned to Manager':
        flash('Files can only be added when request status is "Returned to Manager".', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Check if user is an authorized manager approver
    authorized_approvers = get_authorized_manager_approvers(req)
    if current_user not in authorized_approvers:
        flash('You are not authorized to add files to this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Handle file uploads
    if 'receipt_files' not in request.files:
        flash('No files selected.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    receipt_files = request.files.getlist('receipt_files')
    if not receipt_files or not any(f.filename for f in receipt_files):
        flash('No files selected.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    uploaded_files = []
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
    
    # Get existing requestor receipts
    existing_receipts = []
    if req.requestor_receipt_path:
        try:
            existing_receipts = json.loads(req.requestor_receipt_path)
            if not isinstance(existing_receipts, list):
                existing_receipts = [req.requestor_receipt_path]
        except (json.JSONDecodeError, TypeError):
            existing_receipts = [req.requestor_receipt_path] if req.requestor_receipt_path else []
    
    # Process new files
    for receipt_file in receipt_files:
        if receipt_file and receipt_file.filename:
            # Validate file size
            file_size = len(receipt_file.read())
            if file_size > max_file_size:
                flash(f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
                return redirect(url_for('view_request', request_id=request_id))
            
            receipt_file.seek(0)
            
            # Validate file extension
            file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
            if file_extension not in allowed_extensions:
                flash(f'Invalid file type for "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
                return redirect(url_for('view_request', request_id=request_id))
            
            # Generate unique filename
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = secure_filename(receipt_file.filename)
            filename = f"receipt_{request_id}_{timestamp}_{filename}"
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            receipt_file.save(filepath)
            uploaded_files.append(filename)
    
    if not uploaded_files:
        flash('No valid files were uploaded.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Combine existing and new files
    all_receipts = existing_receipts + uploaded_files
    req.requestor_receipt_path = json.dumps(all_receipts)
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Manager added {len(uploaded_files)} file(s) to request #{request_id}")
    flash(f'Successfully added {len(uploaded_files)} file(s) to the request.', 'success')
    
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/manager-delete-file', methods=['POST'])
@login_required
def manager_delete_file(request_id):
    """Manager deletes a file from request when status is Returned to Manager"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check authorization - only managers can delete files when status is "Returned to Manager"
    if req.status != 'Returned to Manager':
        flash('Files can only be deleted when request status is "Returned to Manager".', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Check if user is an authorized manager approver
    authorized_approvers = get_authorized_manager_approvers(req)
    if current_user not in authorized_approvers:
        flash('You are not authorized to delete files from this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    filename_to_delete = request.form.get('filename', '').strip()
    if not filename_to_delete:
        flash('No file specified for deletion.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Get existing requestor receipts
    existing_receipts = []
    if req.requestor_receipt_path:
        try:
            existing_receipts = json.loads(req.requestor_receipt_path)
            if not isinstance(existing_receipts, list):
                existing_receipts = [req.requestor_receipt_path]
        except (json.JSONDecodeError, TypeError):
            existing_receipts = [req.requestor_receipt_path] if req.requestor_receipt_path else []
    
    # Remove the file from the list
    if filename_to_delete not in existing_receipts:
        flash('File not found in request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    existing_receipts.remove(filename_to_delete)
    
    # Delete the physical file
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename_to_delete)
    if os.path.exists(filepath):
        try:
            os.remove(filepath)
        except Exception as e:
            flash(f'Warning: File deleted from database but could not delete physical file: {str(e)}', 'warning')
    
    # Update database
    if existing_receipts:
        req.requestor_receipt_path = json.dumps(existing_receipts)
    else:
        req.requestor_receipt_path = None
    
    req.updated_at = datetime.utcnow()
    db.session.commit()
    
    # Log file deletion in audit log with readable filename
    requestor_name = getattr(req.user, 'name', 'Unknown')
    # Extract readable filename (remove timestamp prefix if present)
    readable_filename = filename_to_delete.split('_', 3)[-1] if '_' in filename_to_delete else filename_to_delete
    log_action(
        f"Deleted receipt file from payment request #{request_id} ({requestor_name}): {readable_filename}"
    )
    
    flash('File deleted successfully.', 'success')
    
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/field_history')
@login_required
def request_field_history(request_id: int):
    """Return JSON history entries for a specific field for this request."""
    field = request.args.get('field', '').strip()
    if not field:
        return jsonify({'success': False, 'error': 'Missing field parameter'}), 400

    # Basic permission: reuse view permission; if user can't view the request, block
    req = PaymentRequest.query.get_or_404(request_id)
    # Minimal reuse: allow anyone who can open the view_request page (same route did checks)
    # Here, we do a simplified check: if current user is the requestor or IT/GM/Operation Manager/Finance Admin/Department Manager
    if not (
        current_user.user_id == req.user_id or
        current_user.department == 'IT' or
        current_user.role in ['GM', 'Operation Manager', 'Finance Admin', 'Department Manager']
    ):
        return jsonify({'success': False, 'error': 'Not authorized'}), 403

    try:
        db.session.execute(db.text('''
            CREATE TABLE IF NOT EXISTS request_field_edit_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                request_id INTEGER NOT NULL,
                field_name TEXT NOT NULL,
                old_value TEXT,
                new_value TEXT,
                edited_by_user_id INTEGER,
                edited_by_name TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        '''))
        rows = db.session.execute(
            db.text('''SELECT old_value, new_value, edited_by_name, created_at
                       FROM request_field_edit_logs
                       WHERE request_id = :rid AND field_name = :fname
                       ORDER BY created_at DESC'''),
            {'rid': request_id, 'fname': field}
        ).fetchall()
        history = [
            {
                'old_value': r[0],
                'new_value': r[1],
                'edited_by': r[2],
                'edited_at': r[3]
            }
            for r in rows
        ]
        return jsonify({'success': True, 'field': field, 'history': history})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/request/<int:request_id>/approve', methods=['POST'])
@login_required
@role_required('Finance Admin')
def approve_request(request_id):
    """Approve a payment request (Finance approval)"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is in correct status for Finance approval
    if req.status not in ['Pending Manager Approval', 'Pending Finance Approval', 'Proof Sent']:
        flash('This request is not ready for Finance approval.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    # Get form data
    approval_status = request.form.get('approval_status')
    
    if approval_status == 'return_to_manager':
        # Return to Manager - set status to "Returned to Manager"
        return_reason = request.form.get('return_reason', '').strip()
        if not return_reason:
            flash('Please provide a reason for returning this request to the manager.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        # Save current return reason to history if it exists (for multiple returns)
        # Check if there's already a return reason (could be from a previous return)
        if req.rejection_reason:
            # There's already a return reason, save it to history before overwriting
            # Check if this return reason is already in history to avoid duplicates
            existing_history = ReturnReasonHistory.query.filter_by(
                request_id=request_id,
                return_reason=req.rejection_reason
            ).first()
            
            if not existing_history:
                # Only save if not already in history (avoid duplicates)
                # Use original return date if available, otherwise use current time
                if req.manager_rejection_date:
                    # Convert date to datetime (use start of day)
                    from datetime import time as dt_time
                    returned_at = datetime.combine(req.manager_rejection_date, dt_time.min)
                else:
                    returned_at = datetime.utcnow()
                
                return_history = ReturnReasonHistory(
                    request_id=request_id,
                    return_reason=req.rejection_reason,
                    returned_by_user_id=req.manager_rejector_user_id if req.manager_rejector_user_id else current_user.user_id,
                    returned_by_name=req.manager_rejector if req.manager_rejector else current_user.name,
                    returned_at=returned_at
                )
                db.session.add(return_history)
        
        # Update request status
        req.status = 'Returned to Manager'
        req.rejection_reason = return_reason  # Store the new return reason in rejection_reason field
        req.manager_rejection_date = datetime.utcnow().date()  # Track when returned
        req.manager_rejector = current_user.name  # Track who returned it
        req.manager_rejector_user_id = current_user.user_id
        req.updated_at = datetime.utcnow()
        
        # Reset manager approval timing since it's going back
        req.manager_approval_end_time = None
        req.manager_approval_duration_minutes = None
        
        db.session.commit()
        
        log_action(f"Finance Admin returned payment request #{request_id} to manager - Reason: {return_reason}")
        
        # Notify the requestor
        create_notification(
            user_id=req.user_id,
            title="Request Returned to Manager",
            message=f"Your payment request #{request_id} has been returned to the manager for review. Reason: {return_reason}",
            notification_type="request_returned",
            request_id=request_id
        )
        
        # Notify ALL authorized managers who can approve this request
        authorized_approvers = get_authorized_manager_approvers(req)
        notified_user_ids = {req.user_id}  # Track notified users to avoid duplicates
        notification_count = 0
        
        print(f"DEBUG: Returning request #{request_id} to manager. Found {len(authorized_approvers)} authorized approvers.")
        
        # Notify all authorized manager approvers
        for approver in authorized_approvers:
            if approver.user_id not in notified_user_ids:
                try:
                    print(f"DEBUG: Notifying authorized approver: {approver.name} (ID: {approver.user_id}, Role: {approver.role}, Department: {approver.department})")
                    dept_text = get_department_text_for_notification(req)
                    notification = create_notification(
                        user_id=approver.user_id,
                        title="Request Returned for Review",
                        message=f"Payment request #{request_id} {dept_text} department has been returned by Finance Admin for review. Reason: {return_reason}",
                        notification_type="request_returned",
                        request_id=request_id
                    )
                    if notification:
                        print(f"DEBUG: Successfully created notification {notification.notification_id} for user {approver.user_id}")
                        notification_count += 1
                    else:
                        print(f"DEBUG: ERROR - Failed to create notification for user {approver.user_id}")
                    notified_user_ids.add(approver.user_id)
                except Exception as e:
                    print(f"DEBUG: ERROR - Exception while creating notification for user {approver.user_id}: {str(e)}")
                    app.logger.error(f"Failed to create notification for user {approver.user_id} when returning request #{request_id}: {str(e)}")
        
        # Also notify IT Department Manager if request is from IT department (they can edit and reassign managers)
        if req.user.department == 'IT':
            it_managers = User.query.filter_by(
                department='IT',
                role='Department Manager'
            ).all()
            for it_manager in it_managers:
                if it_manager.user_id not in notified_user_ids:
                    try:
                        dept_text = get_department_text_for_notification(req)
                        create_notification(
                            user_id=it_manager.user_id,
                            title="Request Returned for Review",
                            message=f"Payment request #{request_id} {dept_text} department has been returned by Finance Admin for review. Reason: {return_reason}",
                            notification_type="request_returned",
                            request_id=request_id
                        )
                        notification_count += 1
                        notified_user_ids.add(it_manager.user_id)
                    except Exception as e:
                        print(f"DEBUG: ERROR - Exception while creating notification for IT manager {it_manager.user_id}: {str(e)}")
                        app.logger.error(f"Failed to create notification for IT manager {it_manager.user_id} when returning request #{request_id}: {str(e)}")
        
        print(f"DEBUG: Total notifications sent: {notification_count} out of {len(authorized_approvers)} authorized approvers")
        log_action(f"Finance Admin returned request #{request_id} to manager - Notified {notification_count} authorized approvers")
        
        # Emit real-time update
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Returned to Manager',
            'returned': True
        })
        
        flash(f'Payment request #{request_id} has been returned to the manager.', 'info')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    elif approval_status == 'approve':
        # Automatically assign the logged-in finance admin user as the approver
        approver = current_user.name
        proof_required = request.form.get('proof_required') == 'on'
        today = datetime.utcnow().date()
        
        # Require reference number for Finance Admin approval
        reference_number = request.form.get('reference_number', '').strip()
        if not reference_number:
            flash('Reference number is required for Finance Admin approval.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        # Validate reference number is alphanumeric
        if not re.match(r'^[A-Za-z0-9]+$', reference_number):
            flash('Reference number must contain only letters and numbers.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        # Require cash receiver for Cash payment method
        cash_receiver = request.form.get('cash_receiver', '').strip()
        if req.payment_method == 'Cash' and not cash_receiver:
            flash('Cash Receiver is required when payment method is Cash.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        # Require receipt upload for Finance Admin approval
        if 'receipt_files' not in request.files:
            flash('Receipt upload is required for Finance Admin approval.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        receipt_files = request.files.getlist('receipt_files')
        if not receipt_files or not any(f.filename for f in receipt_files):
            flash('Receipt upload is required for Finance Admin approval.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        # Handle multiple receipt uploads
        uploaded_files = []
        allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
        
        for receipt_file in receipt_files:
            if receipt_file and receipt_file.filename:
                # Validate file size (50MB max)
                max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                if len(receipt_file.read()) > max_file_size:
                    flash(f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
                    return redirect(url_for('view_request', request_id=request_id))
                
                # Reset file pointer
                receipt_file.seek(0)
                
                # Validate file extension
                file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                if file_extension not in allowed_extensions:
                    flash(f'Invalid file type for "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
                    return redirect(url_for('view_request', request_id=request_id))
                
                # Generate unique filename
                filename = secure_filename(receipt_file.filename)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"receipt_{timestamp}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                receipt_file.save(filepath)
                uploaded_files.append(filename)
        
        if not uploaded_files:
            flash('No valid receipt files were uploaded.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Store all finance admin receipts as JSON string in finance_admin_receipt_path
        # Never overwrite requestor receipts - they stay in requestor_receipt_path
        import json
        finance_receipt_path = json.dumps(uploaded_files)
        req.finance_admin_receipt_path = finance_receipt_path
        
        # Save reference number
        req.reference_number = reference_number
        
        # Save cash receiver (only for Cash payment method)
        cash_receiver = request.form.get('cash_receiver', '').strip()
        if req.payment_method == 'Cash' and cash_receiver:
            req.cash_receiver = cash_receiver
        elif req.payment_method != 'Cash':
            # Clear cash_receiver if payment method is not Cash
            req.cash_receiver = None
        
        req.approver = approver
        req.proof_required = proof_required
        req.updated_at = datetime.utcnow()
        
        if proof_required:
            # Proof is required - set status to Proof Pending
            req.status = 'Proof Pending'
            flash(f'Payment request #{request_id} approved. Waiting for proof of payment from department.', 'info')
            log_action(f"Approved payment request #{request_id} - Proof required")
            
            # Notify the requestor
            create_notification(
                user_id=req.user_id,
                title="Proof of Payment Required",
                message=f"Your payment request #{request_id} has been approved. Please upload proof of payment.",
                notification_type="proof_required",
                request_id=request_id
            )
            
            # Emit real-time update
            socketio.emit('request_updated', {
                'request_id': request_id,
                'status': 'Proof Pending',
                'approver': approver
            })
        else:
            # No proof required - check if it's a recurring payment
            if req.recurring == 'Recurring':
                # Recurring payment - set status to Recurring
                req.status = 'Recurring'
                req.approval_date = today  # Set approval_date when status becomes Recurring
                
                # End finance approval timing when recurring payment is approved
                if req.finance_approval_start_time and not req.finance_approval_end_time:
                    current_time = datetime.utcnow()
                    req.finance_approval_end_time = current_time
                    duration = current_time - req.finance_approval_start_time
                    req.finance_approval_duration_minutes = int(duration.total_seconds())
                
                # Automatically mark the first installment as paid
                first_installment = RecurringPaymentSchedule.query.filter_by(
                    request_id=request_id
                ).order_by(RecurringPaymentSchedule.payment_order).first()
                
                if first_installment:
                    first_installment.is_paid = True
                    first_installment.paid_date = today
                    # Copy the finance admin receipt to the first installment (only if it doesn't already have one)
                    if not first_installment.receipt_path and req.finance_admin_receipt_path:
                        import json
                        finance_receipts = json.loads(req.finance_admin_receipt_path)
                        if finance_receipts:
                            first_installment.receipt_path = finance_receipts[0]
                    
                    # Create a paid notification for the first installment
                    create_notification(
                        user_id=req.user_id,
                        title="First Installment Paid",
                        message=f'First installment for {first_installment.payment_date} has been automatically marked as paid (Amount: {first_installment.amount} OMR)',
                        notification_type="installment_paid",
                        request_id=request_id
                    )
                    
                    # Also notify Finance Admin and Finance Staff
                    finance_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
                    for user in finance_users:
                        create_notification(
                            user_id=user.user_id,
                            title="First Installment Paid",
                            message=f'First installment for {first_installment.payment_date} has been automatically marked as paid (Amount: {first_installment.amount} OMR)',
                            notification_type="installment_paid",
                            request_id=request_id
                        )
                
                flash(f'Recurring payment request #{request_id} approved. First installment automatically marked as paid. Payment schedule will be managed.', 'success')
                log_action(f"Approved recurring payment request #{request_id} - No proof required - First installment marked as paid")
                
                # Notify the requestor
                create_notification(
                    user_id=req.user_id,
                    title="Recurring Payment Approved",
                    message=f"Your recurring payment request #{request_id} has been approved. Payment schedule will be managed.",
                    notification_type="recurring_approved",
                    request_id=request_id
                )
                
                # Notify Auditing Staff and Auditing Department Manager
                auditing_users = User.query.filter(
                    db.and_(
                        User.department == 'Auditing',
                        User.role.in_(['Auditing Staff', 'Department Manager'])
                    )
                ).all()
                for auditing_user in auditing_users:
                    dept_text = get_department_text_for_notification(req)
                    create_notification(
                        user_id=auditing_user.user_id,
                        title="Recurring Payment Approved",
                        message=f"Recurring payment request #{request_id} {dept_text} department has been approved by Finance. Payment schedule will be managed.",
                        notification_type="recurring_approved",
                        request_id=request_id
                    )
                
                # Check if all installments are now paid and mark as completed if so
                check_recurring_payment_completion(request_id)
                
                # Emit real-time update
                socketio.emit('request_updated', {
                    'request_id': request_id,
                    'status': 'Recurring',
                    'approver': approver,
                    'recurring': True
                })
            else:
                # One-time payment - set status to Completed
                req.status = 'Completed'
                req.completion_date = today
                req.approval_date = today  # Set approval_date when status becomes Completed
                
                # End finance approval timing when completed
                if req.finance_approval_start_time and not req.finance_approval_end_time:
                    current_time = datetime.utcnow()
                    req.finance_approval_end_time = current_time
                    duration = current_time - req.finance_approval_start_time
                    req.finance_approval_duration_minutes = int(duration.total_seconds())
                flash(f'Payment request #{request_id} approved and completed. No proof of payment required.', 'success')
                log_action(f"Approved and completed payment request #{request_id} - No proof required")
                
                # Notify the requestor
                create_notification(
                    user_id=req.user_id,
                    title="Request Completed",
                    message=f"Your payment request #{request_id} has been approved and completed. No proof of payment was required.",
                    notification_type="request_completed",
                    request_id=request_id
                )
                
                # Notify Auditing Staff and Auditing Department Manager
                auditing_users = User.query.filter(
                    db.and_(
                        User.department == 'Auditing',
                        User.role.in_(['Auditing Staff', 'Department Manager'])
                    )
                ).all()
                for auditing_user in auditing_users:
                    dept_text = get_department_text_for_notification(req)
                    create_notification(
                        user_id=auditing_user.user_id,
                        title="Request Completed",
                        message=f"Payment request #{request_id} {dept_text} department has been completed.",
                        notification_type="request_completed",
                        request_id=request_id
                    )
                
                # Emit real-time update
                socketio.emit('request_updated', {
                    'request_id': request_id,
                    'status': 'Completed',
                    'approver': approver,
                    'completed': True
                })
    
    
    elif approval_status == 'paid':
        # Mark as paid - requires receipt upload
        if 'receipt_files' not in request.files:
            flash('Receipt upload is required to mark as paid.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        receipt_files = request.files.getlist('receipt_files')
        if not receipt_files or not any(f.filename for f in receipt_files):
            flash('Receipt upload is required to mark as paid.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Require reference number when marking as paid
        reference_number = request.form.get('reference_number', '').strip()
        if not reference_number:
            flash('Reference number is required when marking as paid.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Validate reference number is alphanumeric
        if not re.match(r'^[A-Za-z0-9]+$', reference_number):
            flash('Reference number must contain only letters and numbers.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Handle multiple receipt uploads
        uploaded_files = []
        allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
        
        for receipt_file in receipt_files:
            if receipt_file and receipt_file.filename:
                # Validate file size (50MB max)
                max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
                if len(receipt_file.read()) > max_file_size:
                    flash(f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
                    return redirect(url_for('view_request', request_id=request_id))
                
                # Reset file pointer
                receipt_file.seek(0)
                
                # Validate file extension
                file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
                if file_extension not in allowed_extensions:
                    flash(f'Invalid file type for "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
                    return redirect(url_for('view_request', request_id=request_id))
                
                # Generate unique filename
                filename = secure_filename(receipt_file.filename)
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f"receipt_{timestamp}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                receipt_file.save(filepath)
                uploaded_files.append(filename)
        
        if not uploaded_files:
            flash('No valid receipt files were uploaded.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Store all finance admin receipts as JSON string in finance_admin_receipt_path
        # Never overwrite requestor receipts - they stay in requestor_receipt_path
        import json
        finance_receipt_path = json.dumps(uploaded_files)
        req.finance_admin_receipt_path = finance_receipt_path
        
        # Save reference number
        req.reference_number = reference_number
        
        req.status = 'Completed'
        req.approval_date = datetime.utcnow().date()  # Set approval_date when status becomes Completed
        req.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        log_action(f"Finance admin marked payment request #{request_id} as completed")
        
        # Emit real-time update to all users
        emit_request_update_to_all_rooms('request_updated', {
            'request_id': request_id,
            'status': 'Completed',
            'paid': True
        })
        
        flash(f'Payment request #{request_id} has been marked as paid.', 'success')
    
    elif approval_status == 'proof_sent_approve':
        # Approve proof sent by requestor
        current_time = datetime.utcnow()
        
        # Check if this is a recurring payment
        if req.recurring == 'Recurring':
            # For recurring payments, set status to Recurring and handle payment schedule
            req.status = 'Recurring'
            req.approval_date = current_time.date()  # Set approval_date when status becomes Recurring
            
            # End finance approval timing when recurring payment is approved
            if req.finance_approval_start_time and not req.finance_approval_end_time:
                req.finance_approval_end_time = current_time
                duration = current_time - req.finance_approval_start_time
                req.finance_approval_duration_minutes = int(duration.total_seconds())
            
            # Automatically mark the first installment as paid
            first_installment = RecurringPaymentSchedule.query.filter_by(
                request_id=request_id
            ).order_by(RecurringPaymentSchedule.payment_order).first()
            
            if first_installment:
                first_installment.is_paid = True
                first_installment.paid_date = current_time.date()
                # Copy the finance admin receipt to the first installment (only if it doesn't already have one)
                if not first_installment.receipt_path and req.finance_admin_receipt_path:
                    import json
                    finance_receipts = json.loads(req.finance_admin_receipt_path)
                    if finance_receipts:
                        first_installment.receipt_path = finance_receipts[0]
                
                # Create a paid notification for the first installment
                create_notification(
                    user_id=req.user_id,
                    title="First Installment Paid",
                    message=f'First installment for {first_installment.payment_date} has been automatically marked as paid (Amount: {first_installment.amount} OMR)',
                    notification_type="installment_paid",
                    request_id=request_id
                )
                
                # Also notify Finance Admin and Finance Staff
                finance_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
                for user in finance_users:
                    create_notification(
                        user_id=user.user_id,
                        title="First Installment Paid",
                        message=f'First installment for {first_installment.payment_date} has been automatically marked as paid (Amount: {first_installment.amount} OMR)',
                        notification_type="installment_paid",
                        request_id=request_id
                    )
            
            req.updated_at = current_time
            db.session.commit()
            
            log_action(f"Finance admin approved proof for recurring payment request #{request_id}")
            
            # Notify the requestor
            create_notification(
                user_id=req.user_id,
                title="Recurring Payment Approved",
                message=f"Your proof for recurring payment request #{request_id} has been approved. Payment schedule is now active.",
                notification_type="proof_approved",
                request_id=request_id
            )
            
            # Emit real-time update
            socketio.emit('request_updated', {
                'request_id': request_id,
                'status': 'Recurring',
                'proof_approved': True,
                'recurring': True
            })
            
            flash(f'Recurring payment request #{request_id} has been approved. Payment schedule is now active.', 'success')
        else:
            # For non-recurring payments, set status to Completed when proof is approved
            # Don't end finance approval timing here - it should continue until completed
            # The timer should continue running until status is Completed
            
            req.status = 'Completed'
            req.updated_at = current_time
            req.completion_date = datetime.utcnow().date()
            
            db.session.commit()
            
            log_action(f"Finance admin approved proof for payment request #{request_id}")
            
            # Notify the requestor
            create_notification(
                user_id=req.user_id,
                title="Proof Approved",
                message=f"Your proof for payment request #{request_id} has been approved. Status updated to Completed.",
                notification_type="proof_approved",
                request_id=request_id
            )
            
            # Notify Auditing Staff and Auditing Department Manager
            auditing_users = User.query.filter(
                db.and_(
                    User.department == 'Auditing',
                    User.role.in_(['Auditing Staff', 'Department Manager'])
                )
            ).all()
            for auditing_user in auditing_users:
                dept_text = get_department_text_for_notification(req)
                create_notification(
                    user_id=auditing_user.user_id,
                    title="Request Completed",
                    message=f"Payment request #{request_id} {dept_text} department has been completed (proof approved).",
                    notification_type="request_completed",
                    request_id=request_id
                )
            
            # Emit real-time update
            socketio.emit('request_updated', {
                'request_id': request_id,
                'status': 'Completed',
                'proof_approved': True
            })
            
            flash(f'Proof for payment request #{request_id} has been approved.', 'success')
    
    elif approval_status == 'proof_sent_reject':
        # Reject proof sent by requestor
        rejection_reason = request.form.get('rejection_reason', '').strip()
        if not rejection_reason:
            flash('Please provide a reason for rejection.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        req.status = 'Proof Rejected'  # Set to Proof Rejected status
        req.rejection_reason = rejection_reason
        req.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        log_action(f"Finance admin rejected proof for payment request #{request_id} - Reason: {rejection_reason}")
        
        # Notify the requestor
        create_notification(
            user_id=req.user_id,
            title="Proof Rejected",
            message=f"Your proof for payment request #{request_id} has been rejected. Please review the feedback and resubmit.",
            notification_type="proof_rejected",
            request_id=request_id
        )
        
        # Emit real-time update
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Proof Pending',
            'proof_rejected': True
        })
        
        flash(f'Proof for payment request #{request_id} has been rejected.', 'success')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    elif approval_status == 'reject':
        # Finance admin rejects - request is rejected
        rejection_reason = request.form.get('rejection_reason', '').strip()
        if not rejection_reason:
            flash('Please provide a reason for rejection.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        current_time = datetime.utcnow()
        
        # End finance approval timing (rejection stops the timer)
        if req.finance_approval_start_time:
            req.finance_approval_end_time = current_time
            duration = current_time - req.finance_approval_start_time
            req.finance_approval_duration_minutes = int(duration.total_seconds())
        
        req.status = 'Rejected by Finance'
        req.rejection_reason = rejection_reason
        req.finance_rejection_date = current_time.date()
        req.updated_at = current_time
        
        db.session.commit()
        
        log_action(f"Finance admin rejected payment request #{request_id} - Reason: {rejection_reason}")
        
        # Notify the requestor
        create_notification(
            user_id=req.user_id,
            title="Payment Request Rejected",
            message=f"Your payment request #{request_id} has been rejected by Finance. Please review the feedback.",
            notification_type="request_rejected",
            request_id=request_id
        )
        
        # Emit real-time update
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Rejected by Finance',
            'finance_rejected': True
        })
        
        flash(f'Payment request #{request_id} has been rejected by Finance.', 'success')
    
    
    else:
        flash('Invalid approval status selected.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    db.session.commit()
    return redirect_with_return_url('view_request', request_id=request_id)


@app.route('/request/<int:request_id>/upload_additional_files', methods=['POST'])
@login_required
@role_required('Finance Admin')
def upload_additional_files(request_id):
    """Upload additional files to an approved request"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is in correct status for additional file upload
    if req.status not in ['Proof Pending', 'Proof Sent', 'Proof Rejected', 'Completed', 'Recurring']:
        flash('This request is not in a state that allows file uploads.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Get the note about the files
    file_note = request.form.get('file_note', '').strip()
    
    # Handle file uploads
    files = request.files.getlist('additional_files')
    print(f"DEBUG: Received {len(files)} files from request")
    for i, file in enumerate(files):
        print(f"DEBUG: File {i}: {file.filename if file else 'None'}")
    
    uploaded_files = []
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    
    # First, validate all files and collect valid ones
    valid_files = []
    validation_errors = []
    
    for file in files:
        if file and file.filename:
            # Validate file size (50MB max)
            max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
            if len(file.read()) > max_file_size:
                validation_errors.append(f'File "{file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.')
                continue
            
            # Reset file pointer
            file.seek(0)
            
            # Validate file extension
            file_extension = file.filename.rsplit('.', 1)[1].lower() if '.' in file.filename else ''
            if file_extension not in allowed_extensions:
                validation_errors.append(f'Invalid file type for "{file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX')
                continue
            
            # File is valid, add to valid files list
            valid_files.append(file)
    
    # Show validation errors if any
    if validation_errors:
        for error in validation_errors:
            flash(error, 'error')
    
    # Process only valid files
    for file in valid_files:
        filename = secure_filename(file.filename)
        # Add timestamp to filename to avoid conflicts
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"additional_{timestamp}_{filename}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)
        uploaded_files.append(filename)
    
    if uploaded_files:
        # Store additional files in the database
        import json
        
        # Get existing additional files
        existing_files = []
        if req.additional_files:
            try:
                existing_files = json.loads(req.additional_files)
            except (json.JSONDecodeError, TypeError):
                existing_files = []
        
        # Create file entries with notes
        new_file_entries = []
        for filename in uploaded_files:
            file_entry = {
                'filename': filename,
                'uploaded_at': datetime.utcnow().isoformat(),
                'uploaded_by': current_user.name,
                'note': file_note if file_note else None
            }
            new_file_entries.append(file_entry)
        
        # Add new files to existing ones
        all_files = existing_files + new_file_entries
        
        # Store as JSON string
        req.additional_files = json.dumps(all_files)
        req.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        note_text = f" with note: '{file_note}'" if file_note else ""
        log_action(f"Finance admin uploaded {len(uploaded_files)} additional files to request #{request_id}{note_text}")
        flash(f'Successfully uploaded {len(uploaded_files)} additional files.', 'success')
    else:
        flash('No valid files were uploaded.', 'warning')
    
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/mark_as_paid', methods=['POST'])
@login_required
@role_required('Finance Admin')
def mark_as_paid(request_id):
    """Mark a payment pending request as paid"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is in correct status (Proof Sent means proof has been submitted and can be marked as paid/completed)
    if req.status not in ['Proof Sent', 'Proof Pending']:
        flash('This request is not in a valid status for marking as paid.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Mark as completed
    req.status = 'Completed'
    req.approval_date = datetime.utcnow().date()  # Set approval_date when status becomes Completed
    req.completion_date = datetime.utcnow().date()
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Finance admin marked payment request #{request_id} as paid")
    
    # Notify the requestor
    create_notification(
        user_id=req.user_id,
        title="Payment Completed",
        message=f"Your payment request #{request_id} has been paid.",
        notification_type="payment_completed",
        request_id=request_id
    )
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'status': 'Approved',
        'paid': True
    })
    
    flash(f'Payment request #{request_id} has been marked as paid.', 'success')
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/close', methods=['POST'])
@login_required
@role_required('Finance Admin')
def close_request(request_id):
    """Close a request (mark as completed)"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is in correct status
    if req.status not in ['Proof Pending', 'Proof Sent', 'Proof Rejected']:
        flash('This request cannot be closed in its current status.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Close the request
    req.status = 'Completed'
    req.completion_date = datetime.utcnow().date()
    req.approval_date = datetime.utcnow().date()  # Set approval_date when status becomes Completed
    req.updated_at = datetime.utcnow()
    
    # End finance approval timing when completed
    if req.finance_approval_start_time and not req.finance_approval_end_time:
        current_time = datetime.utcnow()
        req.finance_approval_end_time = current_time
        duration = current_time - req.finance_approval_start_time
        req.finance_approval_duration_minutes = int(duration.total_seconds())
    
    db.session.commit()
    
    log_action(f"Finance admin closed payment request #{request_id}")
    
    # Notify the requestor
    create_notification(
        user_id=req.user_id,
        title="Request Completed",
        message=f"Your payment request #{request_id} has been completed and closed.",
        notification_type="request_completed",
        request_id=request_id
    )
    
    # Notify Auditing Staff and Auditing Department Manager
    auditing_users = User.query.filter(
        db.and_(
            User.department == 'Auditing',
            User.role.in_(['Auditing Staff', 'Department Manager'])
        )
    ).all()
    for auditing_user in auditing_users:
        dept_text = get_department_text_for_notification(req)
        create_notification(
            user_id=auditing_user.user_id,
            title="Request Completed",
            message=f"Payment request #{request_id} {dept_text} department has been completed and closed.",
            notification_type="request_completed",
            request_id=request_id
        )
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'status': 'Completed',
        'completed': True
    })
    
    flash(f'Payment request #{request_id} has been closed.', 'success')
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/pending', methods=['POST'])
@login_required
@role_required('Admin')
def mark_pending(request_id):
    """Mark a payment request as pending with reason"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    reason = request.form.get('reason_pending')
    
    if not reason:
        flash('Please provide a reason for marking as pending.', 'warning')
        return redirect(url_for('view_request', request_id=request_id))
    
    req.status = 'Pending'
    req.reason_pending = reason
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Marked payment request #{request_id} as pending")
    
    # Emit real-time update for pending status
    socketio.emit('request_updated', {
        'request_id': request_id,
        'status': 'Pending',
        'reason': reason
    })
    
    flash(f'Payment request #{request_id} has been marked as pending.', 'info')
    return redirect(url_for('admin_dashboard'))


@app.route('/request/<int:request_id>/upload_proof', methods=['POST'])
@login_required
def upload_proof(request_id):
    """Department user uploads proof of payment"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if user owns this request
    if req.user_id != current_user.user_id:
        flash('You can only upload proof for your own requests.', 'error')
        return redirect(url_for('dashboard'))
    
    # Check if request is in "Proof Pending" or "Proof Rejected" status
    if req.status not in ['Proof Pending', 'Proof Rejected']:
        flash('This request does not require proof upload.', 'error')
        return redirect(url_for('dashboard'))
    
    # Handle multiple file uploads
    if 'proof_files' not in request.files:
        flash('No files uploaded.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    proof_files = request.files.getlist('proof_files')
    
    if not proof_files or not any(f.filename for f in proof_files):
        flash('No files selected.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    uploaded_files = []
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    
    # Determine next batch number for this request
    import glob, os
    existing_files_pattern = os.path.join(app.config['UPLOAD_FOLDER'], f"proof_{request_id}_*")
    existing_files = [os.path.basename(f) for f in glob.glob(existing_files_pattern)]
    max_batch = 0
    for ef in existing_files:
        # Expect formats:
        #  - proof_{request_id}_b{batch}_{timestamp}_{original}
        #  - legacy: proof_{request_id}_{timestamp}_{original}
        try:
            if ef.startswith(f"proof_{request_id}_b"):
                after_prefix = ef[len(f"proof_{request_id}_b"):]
                batch_str = after_prefix.split('_', 1)[0]
                batch_num = int(batch_str)
                if batch_num > max_batch:
                    max_batch = batch_num;
            elif ef.startswith(f"proof_{request_id}_"):
                # Treat legacy as batch 1 candidate
                if 1 > max_batch:
                    max_batch = 1
        except Exception:
            pass

    next_batch = max(1, max_batch + 1) if existing_files else 1

    for file in proof_files:
        if file and file.filename:
            # Validate file size (50MB max)
            max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
            if len(file.read()) > max_file_size:
                flash(f'File "{file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
                return redirect(url_for('view_request', request_id=request_id))
            
            # Reset file pointer
            file.seek(0)
            
            # Validate file extension
            file_extension = file.filename.rsplit('.', 1)[1].lower() if '.' in file.filename else ''
            if file_extension not in allowed_extensions:
                flash(f'Invalid file type for "{file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
                return redirect(url_for('view_request', request_id=request_id))
            
            # Generate unique filename
            filename = secure_filename(f"proof_{request_id}_b{next_batch}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{file.filename}")
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(filepath)
            uploaded_files.append(filename)
    
    if uploaded_files:
        # Update request - store the first file as primary proof, others are additional
        req.proof_of_payment = uploaded_files[0]
        req.status = 'Proof Sent'
        req.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        log_action(f"Uploaded {len(uploaded_files)} proof files for payment request #{request_id}")
        
        # Notify Finance Admin and requestor about proof upload
        notify_users_by_role(
            request=req,
            notification_type="proof_uploaded",
            title="Proof of Payment Uploaded",
            message=f"{len(uploaded_files)} proof file(s) have been uploaded for request #{request_id} by {current_user.name}",
            request_id=request_id
        )
        
        # Emit real-time update to all users
        emit_request_update_to_all_rooms('request_updated', {
            'request_id': request_id,
            'status': 'Proof Sent',
            'requestor': current_user.username
        })
        
        flash(f'Successfully uploaded {len(uploaded_files)} proof file(s)! Finance will review your proof.', 'success')
    else:
        flash('No valid files were uploaded.', 'error')
    
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/save_finance_note', methods=['POST'])
@login_required
@role_required('Finance Admin')
def save_finance_note(request_id):
    """Save a note from Finance Admin for a request in Pending Finance Approval status"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is in correct status for Finance admin to add notes
    if req.status != 'Pending Finance Approval':
        flash('Notes can only be added to requests in Pending Finance Approval status.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Get the note from form data
    note = request.form.get('finance_note', '').strip()
    
    if not note:
        flash('Note cannot be empty.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Create a new finance admin note entry
    finance_note = FinanceAdminNote(
        request_id=request_id,
        note_content=note,
        added_by=current_user.name,
        added_by_id=current_user.user_id,
        created_at=datetime.utcnow()
    )
    
    db.session.add(finance_note)
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Finance admin added note to payment request #{request_id}")
    
    # Notify all authorized persons about the note: requestor, assigned managers (incl. temporary), and other finance admins
    notification_title = "Finance Admin Note Added"
    # Include who added the note for clarity
    notification_message = f"{current_user.name} added a finance admin note to payment request #{request_id}."
    # Notify requestor
    create_notification(
        user_id=req.user_id,
        title=notification_title,
        message=notification_message,
        notification_type="finance_note_added",
        request_id=request_id
    )
    
    # Notify assigned managers and temporary manager (if any)
    try:
        authorized_managers = get_authorized_manager_approvers(req)
    except Exception as e:
        authorized_managers = []
        print(f"DEBUG: get_authorized_manager_approvers failed in save_finance_note: {e}")
    
    notified_user_ids = {req.user_id}
    for manager_user in authorized_managers:
        if manager_user and manager_user.user_id not in notified_user_ids:
            create_notification(
                user_id=manager_user.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="finance_note_added",
                request_id=request_id
            )
            notified_user_ids.add(manager_user.user_id)
    
    # Notify other Finance Admins
    try:
        other_finance_admins = User.query.filter_by(role='Finance Admin').all()
    except Exception as e:
        other_finance_admins = []
        print(f"DEBUG: querying Finance Admins failed in save_finance_note: {e}")
    for fa_user in other_finance_admins:
        if fa_user and fa_user.user_id not in notified_user_ids and fa_user.user_id != current_user.user_id:
            create_notification(
                user_id=fa_user.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="finance_note_added",
                request_id=request_id
            )
            notified_user_ids.add(fa_user.user_id)

    # Notify ALL IT Staff regardless of request owner
    try:
        it_staff_users = User.query.filter_by(role='IT Staff').all()
    except Exception as e:
        it_staff_users = []
        print(f"DEBUG: querying IT Staff failed in save_finance_note: {e}")
    for it_user in it_staff_users:
        if it_user and it_user.user_id not in notified_user_ids:
            create_notification(
                user_id=it_user.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="finance_note_added",
                request_id=request_id
            )
            notified_user_ids.add(it_user.user_id)

    # Notify IT Department Manager(s) regardless of request owner
    try:
        it_managers = User.query.filter_by(role='Department Manager', department='IT').all()
    except Exception as e:
        it_managers = []
        print(f"DEBUG: querying IT Department Managers failed in save_finance_note: {e}")
    for mgr in it_managers:
        if mgr and mgr.user_id not in notified_user_ids:
            create_notification(
                user_id=mgr.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="finance_note_added",
                request_id=request_id
            )
            notified_user_ids.add(mgr.user_id)

    # Notify General Managers (ALL GMs)
    try:
        gm_users = User.query.filter_by(role='GM').all()
    except Exception as e:
        gm_users = []
        print(f"DEBUG: querying GM users failed in save_finance_note: {e}")
    for gm in gm_users:
        if gm and gm.user_id not in notified_user_ids:
            create_notification(
                user_id=gm.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="finance_note_added",
                request_id=request_id
            )
            notified_user_ids.add(gm.user_id)

    # Notify Operation Managers (ALL Operation Managers)
    try:
        op_manager_users = User.query.filter_by(role='Operation Manager').all()
    except Exception as e:
        op_manager_users = []
        print(f"DEBUG: querying Operation Managers failed in save_finance_note: {e}")
    for opm in op_manager_users:
        if opm and opm.user_id not in notified_user_ids:
            create_notification(
                user_id=opm.user_id,
                title=notification_title,
                message=notification_message,
                notification_type="finance_note_added",
                request_id=request_id
            )
            notified_user_ids.add(opm.user_id)
    
    # Emit real-time notification events
    try:
        socketio.emit('new_notification', {
            'title': notification_title,
            'message': notification_message,
            'type': 'finance_note_added',
            'request_id': request_id
        }, room='all_users')
        socketio.emit('notification_update', {
            'action': 'new_notification',
            'type': 'finance_note_added'
        }, room='all_users')
    except Exception as e:
        print(f"Error emitting finance_note_added WebSocket events: {e}")
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'finance_note_added': True,
        'note': note
    })
    
    flash('Note saved successfully.', 'success')
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/final_approve', methods=['POST'])
@login_required
@role_required('Admin')
def final_approve_request(request_id):
    """Admin final approval after receiving proof"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is in "Proof Sent" status
    if req.status != 'Proof Sent':
        flash('This request is not ready for final approval.', 'error')
        return redirect(url_for('admin_dashboard'))
    
    # Final approval - set to Completed
    req.status = 'Completed'
    req.approval_date = datetime.utcnow().date()  # Set approval_date when status becomes Completed
    req.completion_date = datetime.utcnow().date()
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Final approved payment request #{request_id}")
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'status': 'Completed',
        'final_approval': True
    })
    
    flash(f'Payment request #{request_id} has been finally approved.', 'success')
    return redirect(url_for('admin_dashboard'))


@app.route('/request/<int:request_id>/manager_approve', methods=['POST'])
@login_required
def manager_approve_request(request_id):
    """Manager approves a payment request"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Debug information
    print(f"DEBUG: Current user: {current_user.name} (ID: {current_user.user_id}, Role: {current_user.role}, Department: {current_user.department})")
    print(f"DEBUG: Request submitter: {req.user.name} (ID: {req.user.user_id}, Role: {req.user.role}, Department: {req.user.department})")
    print(f"DEBUG: Request submitter's manager_id: {req.user.manager_id}")
    print(f"DEBUG: Request status: {req.status}")
    
    # Check if current user is authorized to approve this request
    is_authorized = False
    is_temp_manager = False
    dept_temp = None
    
    # First, enforce temporary manager exclusivity (IT Department feature)
    if req.temporary_manager_id:
        if req.temporary_manager_id == current_user.user_id:
            is_authorized = True
            is_temp_manager = True
            print("DEBUG: Authorized via temporary manager assignment")
        else:
            # When a temporary manager is assigned for this specific request, only they can approve it
            print("DEBUG: Approval blocked - temporary manager is assigned and current user is not the assignee")
            is_authorized = False
    else:
        # No per-request temporary manager assigned - check for department-level temporary manager
        try:
            dept_temp = DepartmentTemporaryManager.query.filter(
                DepartmentTemporaryManager.department == (req.department or ''),
                db.or_(
                    DepartmentTemporaryManager.request_type == 'Finance Payment Request',
                    DepartmentTemporaryManager.request_type == 'Both Payment and Item Request'
                )
            ).first()
        except Exception:
            dept_temp = None
        if dept_temp and dept_temp.temporary_manager_id == current_user.user_id:
            is_authorized = True
            is_temp_manager = True
            print("DEBUG: Authorized via department-level temporary manager assignment")
    
    # Never allow users to approve their own requests at the manager stage
    # EXCEPTION: Allow temporary managers to approve their own requests when assigned as temp manager for their own department
    if req.user_id == current_user.user_id and not is_temp_manager:
        flash('You cannot approve your own request at the manager stage.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    # Continue with standard authorization checks even when a department-level temporary manager exists.
    # This ensures GM and Operation Manager remain authorized as before.
    # Hard rule: Requests submitted by GM/CEO/Operation Manager can ONLY be approved by Abdalaziz (Finance Admin)
    # Exception: Department-level temporary managers can still approve these requests
    if not is_authorized:
        if req.user.role in ['GM', 'CEO', 'Operation Manager']:
            if current_user.name == 'Abdalaziz Al-Brashdi':
                is_authorized = True
                print("DEBUG: Authorized via Abdalaziz-only rule for GM/CEO/Operation Manager submitter")
            elif dept_temp and dept_temp.temporary_manager_id == current_user.user_id:
                # Department-level temporary manager exception for GM/CEO/Operation Manager requests
                is_authorized = True
                print("DEBUG: Authorized via department-level temporary manager for GM/CEO/Operation Manager submitter")
            else:
                is_authorized = False
                print("DEBUG: Blocked - only Abdalaziz or department-level temporary manager can approve GM/CEO/Operation Manager submitter")
        # General rule for other requests
        elif current_user.role in ['GM', 'Operation Manager']:
            is_authorized = True
            print("DEBUG: Authorized via global GM/Operation Manager rule")
        else:
            # Check if current user is the manager of the request submitter
            if req.user.manager_id and req.user.manager_id == current_user.user_id:
                is_authorized = True
                print("DEBUG: Authorized via manager_id relationship")
    
    # If not yet authorized and no temporary manager restriction applied, check special cases
    if not is_authorized and not req.temporary_manager_id:
        # Special case: General Manager can approve Department Manager requests
        if (current_user.role == 'GM' and req.user.role == 'Department Manager'):
            is_authorized = True
            print("DEBUG: Authorized via GM role for Department Manager")
        # Special case: Operation Manager can also approve Department Manager requests (global)
        elif (current_user.role == 'Operation Manager' and req.user.role == 'Department Manager'):
            is_authorized = True
            print("DEBUG: Authorized via Operation Manager role for Department Manager")
        # Special case: Abdalaziz can approve General Manager and CEO requests
        elif (current_user.name == 'Abdalaziz Al-Brashdi' and req.user.role in ['GM','CEO']):
            is_authorized = True
            print("DEBUG: Authorized via Abdalaziz role for GM/CEO")
        # Special case: Abdalaziz can approve Finance Staff requests
        elif (current_user.name == 'Abdalaziz Al-Brashdi' and req.user.role == 'Finance Staff'):
            is_authorized = True
            print("DEBUG: Authorized via Abdalaziz role for Finance Staff")
        # Special case: Abdalaziz can approve Operation Manager requests
        elif (current_user.name == 'Abdalaziz Al-Brashdi' and req.user.role == 'Operation Manager'):
            is_authorized = True
            print("DEBUG: Authorized via Abdalaziz role for Operation Manager")
        # Special case: Operation Manager can approve Operation department and Project requests
        elif (current_user.role == 'Operation Manager' and 
              (req.user.department == 'Operation' or req.user.department == 'Project') and 
              req.user.role != 'Operation Manager'):  # Operation Manager can't approve their own requests
            is_authorized = True
            print("DEBUG: Authorized via Operation Manager role")
        # Special case: Finance Admin can approve Finance department requests
        elif (current_user.role == 'Finance Admin' and 
              req.user.department == 'Finance' and 
              req.user.role != 'Finance Admin'):  # Finance Admin can't approve their own requests
            is_authorized = True
            print("DEBUG: Authorized via Finance Admin role")
        # Special case: Department Manager can approve same department requests
        elif (current_user.role == 'Department Manager' and 
              req.user.department == current_user.department and 
              req.user.role != 'Department Manager'):  # Department Manager can't approve their own requests
            is_authorized = True
            print("DEBUG: Authorized via Department Manager role")
    
    print(f"DEBUG: Authorization result: {is_authorized}")
    
    if not is_authorized:
        flash('You are not authorized to approve this request.', 'error')
        return redirect(url_for('dashboard'))
    
    # Check if request is in correct status
    # Allow approval when status is "Pending Manager Approval", "Returned to Manager", or "On Hold" (if put on hold by manager)
    if req.status not in ['Pending Manager Approval', 'Returned to Manager', 'On Hold']:
        flash('This request is not pending manager approval.', 'error')
        return redirect(url_for('dashboard'))
    
    # If status is "On Hold", verify it was put on hold by a manager (not finance)
    if req.status == 'On Hold' and not req.manager_on_hold_by_user_id:
        flash('This request is on hold but not by a manager. You cannot take action on it.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    # Get form data
    approval_status = request.form.get('approval_status')
    
    if approval_status == 'on_hold':
        # Manager puts request on hold
        on_hold_reason = request.form.get('on_hold_reason', '').strip()
        if not on_hold_reason:
            flash('Please provide a reason for putting this request on hold.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        current_time = datetime.utcnow()
        
        # Update request - change status to 'On Hold'
        req.status = 'On Hold'
        req.manager_on_hold_date = current_time.date()
        req.manager_on_hold_by = current_user.name
        req.manager_on_hold_by_user_id = current_user.user_id
        req.manager_on_hold_reason = on_hold_reason
        req.updated_at = current_time
        
        db.session.commit()
        
        log_action(f"Manager put payment request #{request_id} on hold")
        
        # Build message
        message_base = f"Payment request #{request_id} has been put on hold by {current_user.name}."
        if on_hold_reason:
            message_base += f" Reason: {on_hold_reason}"
        
        # Notify requestor
        if req.user_id:
            create_notification(
                user_id=req.user_id,
                title="Payment Request On Hold",
                message=f"Your {message_base.lower()}",
                notification_type="request_on_hold",
                request_id=request_id
            )
        
        # Notify all authorized managers (including temporary managers, Operation Manager, GM)
        authorized_approvers = get_authorized_manager_approvers(req)
        for approver in authorized_approvers:
            if approver.user_id != current_user.user_id:  # Don't notify the person who put it on hold
                create_notification(
                    user_id=approver.user_id,
                    title="Payment Request On Hold",
                    message=message_base,
                    notification_type="request_on_hold",
                    request_id=request_id
                )
        
        # Notify IT Department (all IT Staff and IT Department Manager)
        it_users = User.query.filter(
            User.department == 'IT'
        ).filter(
            User.role.in_(['IT Staff', 'Department Manager'])
        ).all()
        
        for it_user in it_users:
            create_notification(
                user_id=it_user.user_id,
                title="Payment Request On Hold",
                message=message_base,
                notification_type="request_on_hold",
                request_id=request_id
            )
        
        # Notify General Managers (ALL GMs) - always notified when any payment request is put on hold
        try:
            gm_users = User.query.filter_by(role='GM').all()
        except Exception as e:
            gm_users = []
            print(f"DEBUG: querying GM users failed in manager_approve_request (on_hold): {e}")
        for gm in gm_users:
            if gm and gm.user_id != current_user.user_id:  # Don't notify the person who put it on hold
                create_notification(
                    user_id=gm.user_id,
                    title="Payment Request On Hold",
                    message=message_base,
                    notification_type="request_on_hold",
                    request_id=request_id
                )
        
        # Notify Operation Managers (ALL Operation Managers) - always notified when any payment request is put on hold
        try:
            op_manager_users = User.query.filter_by(role='Operation Manager').all()
        except Exception as e:
            op_manager_users = []
            print(f"DEBUG: querying Operation Managers failed in manager_approve_request (on_hold): {e}")
        for opm in op_manager_users:
            if opm and opm.user_id != current_user.user_id:  # Don't notify the person who put it on hold
                create_notification(
                    user_id=opm.user_id,
                    title="Payment Request On Hold",
                    message=message_base,
                    notification_type="request_on_hold",
                    request_id=request_id
                )
        
        # Emit real-time update
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'On Hold',
            'manager_on_hold': True
        })
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'On Hold',
            'manager_on_hold': True
        }, room='gm')
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'On Hold',
            'manager_on_hold': True
        }, room='operation_manager')
        
        flash(f'Payment request #{request_id} has been put on hold.', 'warning')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    elif approval_status == 'approve':
        # Manager approves - move to Finance for final approval
        current_time = datetime.utcnow()
        
        # Start manager approval timing if not already started
        if not req.manager_approval_start_time:
            req.manager_approval_start_time = current_time
        
        # End manager approval timing
        req.manager_approval_end_time = current_time
        
        # Calculate duration in seconds
        if req.manager_approval_start_time:
            duration = current_time - req.manager_approval_start_time
            req.manager_approval_duration_minutes = int(duration.total_seconds())
        
        # Start finance approval timing
        req.finance_approval_start_time = current_time
        
        req.status = 'Pending Finance Approval'
        req.manager_approval_date = current_time.date()
        # Track who actually approved as manager (covers GM, Operation Manager, Department Manager, Finance Admin, and temporary manager)
        req.manager_approver = current_user.name
        req.manager_approver_user_id = current_user.user_id
        req.is_urgent = request.form.get('is_urgent') == 'on'
        req.manager_approval_reason = request.form.get('approval_reason', '').strip()
        req.updated_at = current_time
        
        db.session.commit()
        
        log_action(f"Manager approved payment request #{request_id}")
        
        # Notify the requestor about approval
        create_notification(
            user_id=req.user_id,
            title="Payment Request Approved",
            message=f"Your payment request #{request_id} has been approved by your manager and sent to Finance for final approval.",
            notification_type="request_approved",
            request_id=request_id
        )
        
        # Notify Finance Admin that request is ready for their review
        dept_text = get_department_text_for_notification(req)
        notify_users_by_role(
            request=req,
            notification_type="ready_for_finance_review",
            title="Payment Request Ready for Review",
            message=f"Payment request #{request_id} {dept_text} department has been approved by manager and is ready for Finance review",
            request_id=request_id
        )
        
        # Emit real-time update to Finance Admin and management dashboards
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Pending Finance Approval',
            'manager_approved': True
        }, room='finance_admin')
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Pending Finance Approval',
            'manager_approved': True
        }, room='gm')
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Pending Finance Approval',
            'manager_approved': True
        }, room='operation_manager')
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Pending Finance Approval',
            'manager_approved': True
        })
        
        flash(f'Payment request #{request_id} has been approved by manager. Sent to Finance for final approval.', 'success')
        return redirect_with_return_url('view_request', request_id=request_id)
        
    elif approval_status == 'reject':
        # Manager rejects - request is rejected
        rejection_reason = request.form.get('rejection_reason', '').strip()
        if not rejection_reason:
            flash('Please provide a reason for rejection.', 'error')
            return redirect_with_return_url('view_request', request_id=request_id)
        
        current_time = datetime.utcnow()
        
        # Start manager approval timing if not already started (for rejection tracking)
        if not req.manager_approval_start_time:
            req.manager_approval_start_time = current_time
        
        # End manager approval timing (rejection stops the timer)
        req.manager_approval_end_time = current_time
        
        # Calculate duration in seconds
        if req.manager_approval_start_time:
            duration = current_time - req.manager_approval_start_time
            req.manager_approval_duration_minutes = int(duration.total_seconds())
        
        req.status = 'Rejected by Manager'
        req.rejection_reason = rejection_reason
        req.manager_rejection_date = current_time.date()
        # Track who actually rejected as manager (covers GM, Operation Manager, Department Manager, Finance Admin, and temporary manager)
        req.manager_rejector = current_user.name
        req.manager_rejector_user_id = current_user.user_id
        req.updated_at = current_time
        
        db.session.commit()
        
        log_action(f"Manager rejected payment request #{request_id} - Reason: {rejection_reason}")
        
        # Notify the requestor
        create_notification(
            user_id=req.user_id,
            title="Payment Request Rejected",
            message=f"Your payment request #{request_id} has been rejected by your manager. Please review the feedback.",
            notification_type="request_rejected",
            request_id=request_id
        )
        
        # Emit real-time update to everyone (including GM and Operation Manager dashboards)
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Rejected by Manager',
            'manager_rejected': True
        })
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Rejected by Manager',
            'manager_rejected': True
        }, room='gm')
        socketio.emit('request_updated', {
            'request_id': request_id,
            'status': 'Rejected by Manager',
            'manager_rejected': True
        }, room='operation_manager')
        
        flash(f'Payment request #{request_id} has been rejected by manager.', 'success')
        return redirect_with_return_url('view_request', request_id=request_id)
    
    else:
        flash('Invalid approval status selected.', 'error')
        return redirect_with_return_url('view_request', request_id=request_id)


@app.route('/request/<int:request_id>/manager_reject', methods=['POST'])
@login_required
def manager_reject_request(request_id):
    """Manager rejects a payment request"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Never allow users to reject their own requests at the manager stage
    if req.user_id == current_user.user_id:
        flash('You cannot reject your own request at the manager stage.', 'error')
        return redirect(url_for('view_request', request_id=request_id))

    # Check if current user is authorized to reject this request
    is_authorized = False
    
    # Temporary manager exclusivity: if a temporary manager is assigned, only they can reject
    if req.temporary_manager_id:
        if req.temporary_manager_id == current_user.user_id:
            is_authorized = True
        else:
            is_authorized = False
    else:
        # New global rule: GM and Operation Manager can reject ANY request at manager stage
        if current_user.role in ['GM', 'Operation Manager']:
            is_authorized = True
        # Check if current user is the manager of the request submitter
        elif req.user.manager_id and req.user.manager_id == current_user.user_id:
            is_authorized = True
        # Special case: Operation Manager can reject Operation department requests
        elif (current_user.role == 'Operation Manager' and 
              req.user.department == 'Operation' and 
              req.user.role != 'Operation Manager'):  # Operation Manager can't reject their own requests
            is_authorized = True
        # Special case: Finance Admin can reject Finance department requests
        elif (current_user.role == 'Finance Admin' and 
              req.user.department == 'Finance' and 
              req.user.role != 'Finance Admin'):  # Finance Admin can't reject their own requests
            is_authorized = True
    
    if not is_authorized:
        flash('You are not authorized to reject this request.', 'error')
        return redirect(url_for('dashboard'))
    
    # Check if request is in correct status
    # Allow approval when status is "Pending Manager Approval" or "Returned to Manager"
    if req.status not in ['Pending Manager Approval', 'Returned to Manager']:
        flash('This request is not pending manager approval.', 'error')
        return redirect(url_for('dashboard'))
    
    # Get rejection reason
    reason = request.form.get('rejection_reason', '').strip()
    if not reason:
        flash('Please provide a reason for rejection.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Manager rejects - request is rejected
    req.status = 'Rejected by Manager'
    req.rejection_reason = reason
    req.manager_rejection_date = datetime.utcnow().date()
    # Track who actually rejected as manager
    req.manager_rejector = current_user.name
    req.manager_rejector_user_id = current_user.user_id
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Manager rejected payment request #{request_id} - Reason: {reason}")
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'status': 'Rejected by Manager',
        'manager_rejected': True
    })
    
    flash(f'Payment request #{request_id} has been rejected by manager.', 'success')
    return_url = request.form.get('return_url') or request.args.get('return_url')
    if return_url:
        return redirect(return_url)
    return redirect(url_for('dashboard'))


@app.route('/request/<int:request_id>/gm_return_to_requestor', methods=['POST'])
@login_required
@role_required('GM', 'Department Manager', 'Operation Manager')
def gm_return_to_requestor(request_id):
    """GM, Department Managers, and Operation Managers can return a payment request to the requestor for editing"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Never allow users to return their own requests
    if req.user_id == current_user.user_id:
        flash('You cannot return your own request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Determine which statuses are allowed based on role
    allowed_statuses = []
    if current_user.role == 'GM':
        # GM can return for both manager and finance approval stages
        allowed_statuses = ['Pending Manager Approval', 'Pending Finance Approval']
    elif current_user.role in ['Department Manager', 'Operation Manager']:
        # Department Managers and Operation Managers can only return during manager approval stage
        allowed_statuses = ['Pending Manager Approval']
    else:
        flash('You do not have permission to return this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Check if request is in correct status
    if req.status not in allowed_statuses:
        flash('This request is not in a valid status for returning to requestor.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Check authorization - user must be authorized to approve this request
    is_authorized = False
    
    # Check temporary manager assignment first
    if req.temporary_manager_id:
        if req.temporary_manager_id == current_user.user_id:
            is_authorized = True
        else:
            is_authorized = False
    else:
        # No temporary manager, use standard authorization checks
        # Hard rule: Requests submitted by GM/CEO/Operation Manager can ONLY be returned by Abdalaziz
        if req.user.role in ['GM', 'CEO', 'Operation Manager']:
            if current_user.name == 'Abdalaziz Al-Brashdi':
                is_authorized = True
            else:
                is_authorized = False
        # General Manager and Operation Manager can return all other requests
        elif current_user.role in ['GM', 'Operation Manager']:
            is_authorized = True
        # Department Manager can return requests from their department
        elif current_user.role == 'Department Manager':
            if req.user.department == current_user.department and req.user_id != current_user.user_id:
                is_authorized = True
            else:
                is_authorized = False
        # Check if current user is the manager of the request submitter
        elif req.user.manager_id and req.user.manager_id == current_user.user_id:
            is_authorized = True
        # Special case: Finance Admin can return Finance department requests
        elif current_user.role == 'Finance Admin' and req.user.department == 'Finance':
            is_authorized = True
    
    if not is_authorized:
        flash('You are not authorized to return this request to the requestor.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Get return reason
    return_reason = request.form.get('return_reason', '').strip()
    if not return_reason:
        flash('Please provide a reason for returning this request to the requestor.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Save return reason to history
    return_history = ReturnReasonHistory(
        request_id=request_id,
        return_reason=return_reason,
        returned_by_user_id=current_user.user_id,
        returned_by_name=current_user.name,
        returned_at=datetime.utcnow()
    )
    db.session.add(return_history)
    
    # Update request status to allow requestor to edit
    old_status = req.status
    req.status = 'Returned to Requestor'
    req.rejection_reason = return_reason  # Store the return reason
    req.updated_at = datetime.utcnow()
    
    # Reset manager approval timing if it was started
    if req.manager_approval_start_time:
        req.manager_approval_end_time = None
        req.manager_approval_duration_minutes = None
    
    db.session.commit()
    
    # Determine who returned it for logging and notification
    if current_user.role == 'Department Manager':
        returned_by_text = f"Department Manager ({current_user.name})"
    elif current_user.role == 'Operation Manager':
        returned_by_text = f"Operation Manager ({current_user.name})"
    else:
        returned_by_text = f"GM ({current_user.name})"
    
    log_action(f"{returned_by_text} returned payment request #{request_id} to requestor - Reason: {return_reason}")
    
    # Notify the requestor
    create_notification(
        user_id=req.user_id,
        title="Request Returned for Editing",
        message=f"Your payment request #{request_id} has been returned by {returned_by_text} for editing. Reason: {return_reason}",
        notification_type="request_returned",
        request_id=request_id
    )
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'status': 'Returned to Requestor',
        'returned_to_requestor': True
    })
    
    flash(f'Payment request #{request_id} has been returned to the requestor for editing.', 'success')
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/reassign_manager', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def reassign_manager(request_id):
    """IT Department can reassign a temporary manager for a specific request"""
    # Only allow IT Department Staff to perform this action
    if current_user.department != 'IT':
        flash('You do not have permission to reassign managers. Only IT Department can perform this action.', 'danger')
        return redirect(url_for('dashboard'))
    
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Only allow reassignment for pending manager approval requests
    if req.status != 'Pending Manager Approval':
        flash('You can only reassign managers for requests with "Pending Manager Approval" status.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Get the new manager ID from form
    new_manager_id = request.form.get('temporary_manager_id')
    
    if not new_manager_id:
        flash('Please select a manager.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Validate that the manager exists and is a valid manager
    new_manager = User.query.get(new_manager_id)
    if not new_manager:
        flash('Selected manager does not exist.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Only allow reassignment to managers and department managers
    if new_manager.role not in ['Department Manager', 'GM', 'Operation Manager', 'Finance Admin']:
        flash('Selected user is not a manager. Please select a valid manager.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Don't allow reassigning to the same manager
    if req.temporary_manager_id == int(new_manager_id):
        flash('Selected manager is already assigned as the temporary manager for this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Get the old temporary manager (if any) for notification
    old_temp_manager = req.temporary_manager
    old_original_manager = None
    if req.user.manager_id:
        old_original_manager = User.query.get(req.user.manager_id)
    
    # Set the temporary manager
    req.temporary_manager_id = int(new_manager_id)
    req.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    log_action(f"Reassigned temporary manager for request #{request_id} to {new_manager.name} (IT Staff only action)")
    
    # Notify the new temporary manager
    dept_text = get_department_text_for_notification(req)
    create_notification(
        user_id=new_manager_id,
        title="Temporary Manager Assignment",
        message=f"You have been temporarily assigned to review payment request #{request_id} {dept_text} department. The originally assigned manager is not available.",
        notification_type="temporary_manager_assignment",
        request_id=request_id
    )
    
    # Notify the requestor about the manager change
    create_notification(
        user_id=req.user_id,
        title="Manager Reassigned for Your Request",
        message=f"The manager for your payment request #{request_id} has been temporarily reassigned to {new_manager.name}. This only affects this specific request.",
        notification_type="manager_reassigned",
        request_id=request_id
    )
    
    # Notify the old temporary manager (if any) that they're no longer assigned
    if old_temp_manager and old_temp_manager.user_id != int(new_manager_id):
        create_notification(
            user_id=old_temp_manager.user_id,
            title="Temporary Manager Assignment Removed",
            message=f"You are no longer the temporary manager for payment request #{request_id}.",
            notification_type="temporary_manager_unassigned",
            request_id=request_id
        )
    
    # Emit real-time update
    socketio.emit('request_updated', {
        'request_id': request_id,
        'temporary_manager_id': new_manager_id,
        'temporary_manager_name': new_manager.name
    })
    
    flash(f'Temporary manager has been reassigned to {new_manager.name} for request #{request_id}.', 'success')
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/delete', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_request(request_id):
    """Archive a payment request (IT only) - soft delete"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if already archived
    if req.is_archived:
        flash(f'Payment request #{request_id} is already archived.', 'warning')
        return redirect(url_for('archives'))
    
    # Pause any ongoing approval timing before archiving
    archive_time = datetime.utcnow()
    
    # Pause manager approval timing if in progress
    if req.manager_approval_start_time and not req.manager_approval_end_time:
        # Timing was in progress - pause it by setting end_time
        req.manager_approval_end_time = archive_time
        # Calculate and store duration
        if not req.manager_approval_duration_minutes:
            duration = archive_time - req.manager_approval_start_time
            req.manager_approval_duration_minutes = int(duration.total_seconds())
        print(f"DEBUG: Paused manager approval timing for request #{request_id}")
    
    # Pause finance approval timing if in progress
    if req.finance_approval_start_time and not req.finance_approval_end_time:
        # Timing was in progress - pause it by setting end_time
        req.finance_approval_end_time = archive_time
        # Calculate and store duration
        if not req.finance_approval_duration_minutes:
            duration = archive_time - req.finance_approval_start_time
            req.finance_approval_duration_minutes = int(duration.total_seconds())
        print(f"DEBUG: Paused finance approval timing for request #{request_id}")
    
    # Archive the request (soft delete) - keep all files and related records
    req.is_archived = True
    req.archived_at = archive_time
    req.archived_by = current_user.name
    req.archived_by_user_id = current_user.user_id
    
    db.session.commit()
    
    log_action(f"Archived payment request #{request_id}")
    
    # Notify all IT department users about the archive
    it_users = User.query.filter(
        db.or_(
            User.role == 'IT Staff',
            db.and_(User.role == 'Department Manager', User.department == 'IT')
        )
    ).all()
    
    print(f"DEBUG: Found {len(it_users)} IT department users")
    for u in it_users:
        print(f"DEBUG: IT user: {u.username} (ID: {u.user_id}, Role: {u.role}, Dept: {u.department})")
    
    # Exclude the user who archived (they already know)
    it_users_to_notify = [user for user in it_users if user.user_id != current_user.user_id]
    
    print(f"DEBUG: Will notify {len(it_users_to_notify)} IT users (excluding archiver: {current_user.username})")
    
    notification_title = "Payment Request Archived"
    notification_message = f"Payment request #{request_id} submitted by {req.requestor_name} has been archived by {current_user.name}."
    
    for it_user in it_users_to_notify:
        print(f"DEBUG: Creating notification for IT user: {it_user.username} (ID: {it_user.user_id})")
        create_notification(
            user_id=it_user.user_id,
            title=notification_title,
            message=notification_message,
            notification_type="request_archived",
            request_id=request_id
        )
    
    # Emit real-time notification to all users after creating database notifications
    if it_users_to_notify:
        try:
            socketio.emit('new_notification', {
                'title': notification_title,
                'message': notification_message,
                'type': 'request_archived',
                'request_id': request_id
            }, room='all_users')
            
            # Also emit a general update event to trigger notification count updates
            socketio.emit('notification_update', {
                'action': 'new_notification',
                'type': 'request_archived'
            }, room='all_users')
            
            print(f"DEBUG: WebSocket events emitted for request_archived")
        except Exception as e:
            print(f"Error emitting WebSocket notification: {e}")
    
    flash(f'Payment request #{request_id} has been archived.', 'success')
    return redirect(url_for('it_dashboard'))

@app.route('/bulk-delete-requests', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def bulk_delete_requests():
    """Bulk archive payment requests (IT only) - soft delete"""
    # Restrict Department Managers to IT department only
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    request_ids = request.form.getlist('request_ids')
    
    if not request_ids:
        flash('No requests selected for archiving.', 'warning')
        return redirect(url_for('it_dashboard'))
    
    archived_count = 0
    already_archived_count = 0
    archived_requests = []  # Store archived requests for notifications
    
    for request_id in request_ids:
        try:
            req = PaymentRequest.query.get(int(request_id))
            if req:
                if req.is_archived:
                    already_archived_count += 1
                    continue
                
                # Archive the request (soft delete) - keep all files and related records
                req.is_archived = True
                req.archived_at = datetime.utcnow()
                req.archived_by = current_user.name
                req.archived_by_user_id = current_user.user_id
                
                # Store request info for notifications
                archived_requests.append({
                    'request_id': request_id,
                    'requestor_name': req.requestor_name
                })
                
                # Log the archival
                log_action(f"Bulk archived payment request #{request_id} - {req.request_type} - {req.purpose}")
                archived_count += 1
        except (ValueError, TypeError):
            continue
    
    db.session.commit()
    
    # Notify all IT department users about bulk archive
    if archived_count > 0:
        it_users = User.query.filter(
            db.or_(
                User.role == 'IT Staff',
                db.and_(User.role == 'Department Manager', User.department == 'IT')
            )
        ).all()
        
        # Exclude the user who archived (they already know)
        it_users_to_notify = [user for user in it_users if user.user_id != current_user.user_id]
        
        # Create notifications for each archived request
        for archived_req in archived_requests:
            notification_title = "Payment Request Archived"
            notification_message = f"Payment request #{archived_req['request_id']} submitted by {archived_req['requestor_name']} has been archived by {current_user.name}."
            
            for it_user in it_users_to_notify:
                create_notification(
                    user_id=it_user.user_id,
                    title=notification_title,
                    message=notification_message,
                    notification_type="request_archived",
                    request_id=archived_req['request_id']
                )
            
            # Emit real-time notification for each archived request
            if it_users_to_notify:
                try:
                    socketio.emit('new_notification', {
                        'title': notification_title,
                        'message': notification_message,
                        'type': 'request_archived',
                        'request_id': archived_req['request_id']
                    }, room='all_users')
                    
                    # Also emit a general update event to trigger notification count updates
                    socketio.emit('notification_update', {
                        'action': 'new_notification',
                        'type': 'request_archived'
                    }, room='all_users')
                except Exception as e:
                    print(f"Error emitting WebSocket notification: {e}")
    
    if already_archived_count > 0:
        flash(f'{archived_count} payment request(s) have been archived. {already_archived_count} were already archived.', 'success')
    else:
        flash(f'{archived_count} payment request(s) have been archived.', 'success')
    return redirect(url_for('it_dashboard'))

@app.route('/request/<int:request_id>/mark-installment-paid', methods=['POST'])
@login_required
@role_required('Finance Admin')
def mark_installment_paid_finance(request_id):
    """Mark a specific installment as paid (Finance Admin only)"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is recurring
    if req.status != 'Recurring':
        flash('This endpoint is only for recurring payments.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    schedule_id = request.form.get('schedule_id')
    payment_date = request.form.get('payment_date')
    
    if not schedule_id or not payment_date:
        flash('Missing required parameters.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    try:
        # Get the schedule entry
        schedule_entry = RecurringPaymentSchedule.query.get(int(schedule_id))
        if not schedule_entry or schedule_entry.request_id != request_id:
            flash('Installment not found.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Mark as paid
        schedule_entry.is_paid = True
        schedule_entry.paid_date = datetime.strptime(payment_date, '%Y-%m-%d').date()
        
        # Create a paid notification
        create_notification(
            user_id=req.user_id,
            title="Installment Paid",
            message=f'Installment for {payment_date} has been marked as paid (Amount: {schedule_entry.amount} OMR)',
            notification_type="installment_paid",
            request_id=request_id
        )
        
        # Also notify Finance Admin and Finance Staff
        finance_users = User.query.filter(User.role.in_(['Finance Staff', 'Finance Admin'])).all()
        for user in finance_users:
            create_notification(
                user_id=user.user_id,
                title="Installment Paid",
                message=f'Installment for {payment_date} has been marked as paid (Amount: {schedule_entry.amount} OMR)',
                notification_type="installment_paid",
                request_id=request_id
            )
        
        db.session.commit()
        
        # Check if all installments are now paid and mark as completed if so
        check_recurring_payment_completion(request_id)
        
        log_action(f"Marked installment {schedule_id} as paid for request #{request_id}")
        flash(f'Installment for {payment_date} has been marked as paid.', 'success')
        
    except (ValueError, TypeError) as e:
        flash('Invalid date format.', 'error')
    except Exception as e:
        db.session.rollback()
        flash('Error marking installment as paid.', 'error')
    
    return redirect(url_for('view_request', request_id=request_id))

@app.route('/request/<int:request_id>/upload-installment-receipt', methods=['POST'])
@login_required
@role_required('Finance Admin')
def upload_installment_receipt(request_id):
    """Upload receipt for a specific installment (Finance Admin only)"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is recurring
    if req.status != 'Recurring':
        flash('This endpoint is only for recurring payments.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    schedule_id = request.form.get('schedule_id')
    payment_date = request.form.get('payment_date')
    
    if not schedule_id or not payment_date:
        flash('Missing required parameters.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Handle single receipt upload for installment
    if 'receipt_file' not in request.files:
        flash('No receipt file uploaded.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    receipt_file = request.files['receipt_file']
    if not receipt_file or not receipt_file.filename:
        flash('No receipt file selected.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    
    # Validate file size (50MB max)
    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
    if len(receipt_file.read()) > max_file_size:
        flash(f'File "{receipt_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Reset file pointer
    receipt_file.seek(0)
    
    # Validate file extension
    file_extension = receipt_file.filename.rsplit('.', 1)[1].lower() if '.' in receipt_file.filename else ''
    if file_extension not in allowed_extensions:
        flash(f'Invalid file type for "{receipt_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    try:
        # Get the schedule entry
        schedule_entry = RecurringPaymentSchedule.query.get(int(schedule_id))
        if not schedule_entry or schedule_entry.request_id != request_id:
            flash('Installment not found.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Handle single receipt upload for installment
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = secure_filename(receipt_file.filename)
        filename = f"installment_{schedule_id}_{timestamp}_{filename}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        receipt_file.save(filepath)
        
        # Store the file as receipt for this installment (only if it doesn't already have one)
        if schedule_entry.receipt_path:
            flash(f'This installment already has a receipt. Please delete the existing receipt first if you want to replace it.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        schedule_entry.receipt_path = filename
        db.session.commit()
        
        log_action(f"Uploaded receipt for installment {schedule_id} for request #{request_id}")
        flash(f'Receipt uploaded successfully for installment on {payment_date}.', 'success')
        
    except (ValueError, TypeError) as e:
        flash('Invalid parameters.', 'error')
    except Exception as e:
        flash('Error uploading receipt.', 'error')
    
    return redirect(url_for('view_request', request_id=request_id))


@app.route('/request/<int:request_id>/upload-installment-invoice', methods=['POST'])
@login_required
def upload_installment_invoice(request_id):
    """Upload invoice for a specific installment (Requestor only)"""
    req = PaymentRequest.query.get_or_404(request_id)
    
    # Check if request is recurring
    if req.status != 'Recurring':
        flash('This endpoint is only for recurring payments.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Check if user is the requestor
    if req.user_id != current_user.user_id:
        flash('You are not authorized to upload invoices for this request.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    schedule_id = request.form.get('schedule_id')
    payment_date = request.form.get('payment_date')
    
    if not schedule_id or not payment_date:
        flash('Missing required parameters.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Handle single invoice upload for installment
    if 'invoice_file' not in request.files:
        flash('No invoice file uploaded.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    invoice_file = request.files['invoice_file']
    if not invoice_file or not invoice_file.filename:
        flash('No invoice file selected.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    allowed_extensions = {'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'}
    
    # Validate file size (50MB max)
    max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
    if len(invoice_file.read()) > max_file_size:
        flash(f'File "{invoice_file.filename}" is too large. Maximum size is {max_file_size // (1024 * 1024)}MB.', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    # Reset file pointer
    invoice_file.seek(0)
    
    # Validate file extension
    file_extension = invoice_file.filename.rsplit('.', 1)[1].lower() if '.' in invoice_file.filename else ''
    if file_extension not in allowed_extensions:
        flash(f'Invalid file type for "{invoice_file.filename}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX', 'error')
        return redirect(url_for('view_request', request_id=request_id))
    
    try:
        # Get the schedule entry
        schedule_entry = RecurringPaymentSchedule.query.get(int(schedule_id))
        if not schedule_entry or schedule_entry.request_id != request_id:
            flash('Installment not found.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        # Handle single invoice upload for installment
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = secure_filename(invoice_file.filename)
        filename = f"invoice_{schedule_id}_{timestamp}_{filename}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        invoice_file.save(filepath)
        
        # Store the file as invoice for this installment (only if it doesn't already have one)
        if schedule_entry.invoice_path:
            flash(f'This installment already has an invoice. Please delete the existing invoice first if you want to replace it.', 'error')
            return redirect(url_for('view_request', request_id=request_id))
        
        schedule_entry.invoice_path = filename
        db.session.commit()
        
        log_action(f"Uploaded invoice for installment {schedule_id} for request #{request_id}")
        flash(f'Invoice uploaded successfully for installment on {payment_date}.', 'success')
        
    except (ValueError, TypeError) as e:
        flash('Invalid parameters.', 'error')
    except Exception as e:
        flash('Error uploading invoice.', 'error')
    
    return redirect(url_for('view_request', request_id=request_id))

@app.route('/request/<int:request_id>/edit_installment', methods=['POST'])
@login_required
def edit_installment(request_id):
    """Edit installment details (Requestor only)"""
    try:
        # Get the request
        req = PaymentRequest.query.get_or_404(request_id)
        
        # Check if user is the requestor
        if req.user_id != current_user.user_id:
            return jsonify({'success': False, 'message': 'You can only edit your own request installments.'}), 403
        
        # Check if request is recurring
        if req.status != 'Recurring':
            return jsonify({'success': False, 'message': 'Can only edit installments for recurring payments.'}), 400
        
        # Get form data
        schedule_id = request.form.get('schedule_id')
        new_payment_date = request.form.get('payment_date')
        edit_reason = request.form.get('edit_reason', '').strip()
        
        if not all([schedule_id, new_payment_date, edit_reason]):
            return jsonify({'success': False, 'message': 'Missing required fields. Please provide a reason for the edit.'}), 400
        
        # Get the schedule entry
        schedule_entry = RecurringPaymentSchedule.query.get(int(schedule_id))
        if not schedule_entry or schedule_entry.request_id != request_id:
            return jsonify({'success': False, 'message': 'Installment not found.'}), 404
        
        # Check if installment is already paid
        if schedule_entry.is_paid:
            return jsonify({'success': False, 'message': 'Cannot edit paid installments.'}), 400
        
        # Validate date
        try:
            payment_date = datetime.strptime(new_payment_date, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'success': False, 'message': 'Invalid date format.'}), 400
        
        # Store original values for logging and history
        original_date = schedule_entry.payment_date
        original_amount = schedule_entry.amount
        
        # Update only the payment date (amount cannot be changed)
        schedule_entry.payment_date = payment_date
        schedule_entry.has_been_edited = True
        
        # Create edit history record
        edit_history = InstallmentEditHistory(
            schedule_id=schedule_entry.schedule_id,
            request_id=request_id,
            edited_by_user_id=current_user.user_id,
            old_payment_date=original_date,
            new_payment_date=payment_date,
            old_amount=original_amount,
            new_amount=original_amount,  # Amount doesn't change
            edit_reason=edit_reason
        )
        db.session.add(edit_history)
        
        # Log the changes
        log_action(f"Edited installment {schedule_id} for request #{request_id}: Payment date changed from {original_date} to {payment_date}")
        
        # Clean up any existing notifications for the old date
        # This prevents notifications from being sent on the old date
        old_date_notifications = Notification.query.filter(
            Notification.request_id == request_id,
            Notification.notification_type == 'recurring_due',
            Notification.message.contains(str(original_date))
        ).all()
        
        for notification in old_date_notifications:
            db.session.delete(notification)
        
        # Send notification to Finance Admin about the edit
        finance_admin_users = User.query.filter_by(role='Finance Admin').all()
        for admin in finance_admin_users:
            create_notification(
                user_id=admin.user_id,
                title="Installment Date Edited",
                message=f"Recurring request #{request_id} installment payment date has been edited from {original_date} to {payment_date} by {current_user.name}",
                notification_type='installment_edited',
                request_id=request_id
            )
        
        # If the new date is today, create immediate notifications
        if payment_date == date.today():
            # Get all authorized users for this request and create notifications
            authorized_user_ids = get_authorized_users_for_recurring_due(req)
            for user_id in authorized_user_ids:
                create_notification(
                    user_id=user_id,
                    title="Recurring Payment Due",
                    message=f'Recurring payment due today for {req.request_type} - {req.purpose} (Amount: {schedule_entry.amount} OMR) - Date was recently edited',
                    notification_type='recurring_due',
                    request_id=request_id
                )
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Installment updated successfully.'})
        
    except Exception as e:
        db.session.rollback()
        print(f"Error editing installment: {str(e)}")
        return jsonify({'success': False, 'message': 'Error updating installment.'}), 500


@app.route('/api/installment/<int:schedule_id>/edit-history', methods=['GET'])
@login_required
def get_installment_edit_history(schedule_id):
    """Get edit history for a specific installment"""
    try:
        # Get the schedule entry
        schedule_entry = RecurringPaymentSchedule.query.get(schedule_id)
        if not schedule_entry:
            return jsonify({'success': False, 'message': 'Installment not found.'}), 404
        
        # Check if user has permission to view this installment
        if schedule_entry.request.user_id != current_user.user_id and current_user.role not in ['Finance Admin', 'Finance Staff', 'GM', 'IT Staff', 'Operation Manager']:
            return jsonify({'success': False, 'message': 'You do not have permission to view this installment.'}), 403
        
        # Get edit history for this installment
        edit_history = InstallmentEditHistory.query.filter_by(
            schedule_id=schedule_id
        ).order_by(InstallmentEditHistory.created_at.desc()).all()
        
        # Convert to dictionary format
        history_data = [edit.to_dict() for edit in edit_history]
        
        return jsonify({
            'success': True, 
            'edit_history': history_data,
            'installment_info': {
                'schedule_id': schedule_entry.schedule_id,
                'payment_date': schedule_entry.payment_date.strftime('%Y-%m-%d'),
                'amount': float(schedule_entry.amount),
                'has_been_edited': schedule_entry.has_been_edited
            }
        })
        
    except Exception as e:
        print(f"Error fetching installment edit history: {str(e)}")
        return jsonify({'success': False, 'message': 'Error fetching edit history.'}), 500


# ==================== REPORTS ROUTES ====================

@app.route('/reports')
@login_required
@role_required('Finance Admin', 'Finance Staff', 'GM', 'CEO', 'IT Staff', 'Department Manager', 'Operation Manager', 'Auditing Staff')
def reports():
    """View reports page"""
    # Get filter parameters (support multiple values)
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.getlist('department')  # List of departments
    request_type_filter = request.args.getlist('request_type')  # List of request types
    company_filter = request.args.getlist('company')  # List of companies
    branch_filter = request.args.getlist('branch')  # List of branches
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    status_filter = request.args.getlist('status')  # List of statuses
    payment_type_filter = request.args.getlist('payment_type')  # List of payment types
    payment_method_filter = request.args.getlist('payment_method')  # List of payment methods
    reference_number = request.args.get('reference_number', '').strip()
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query - show ALL statuses by default, but exclude archived requests
    query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    
    # Auditing Staff: restrict to Completed, Recurring, and proof-related statuses in reports
    if current_user.role == 'Auditing Staff':
        query = query.filter(PaymentRequest.status.in_([
            'Completed', 'Recurring', 'Proof Pending', 'Proof Sent', 'Proof Rejected'
        ]))
    
    # Filter for Department Managers based on their department
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            # IT Department Manager can see ALL requests from ALL departments (all statuses)
            # No filtering needed - they see everything
            pass
        elif current_user.department == 'Auditing':
            # Auditing Department Manager can see:
            # 1. ALL requests from Auditing department (all statuses)
            # 2. Completed and Recurring requests from OTHER departments
            query = query.filter(
                db.or_(
                    PaymentRequest.department == 'Auditing',
                    PaymentRequest.status.in_(['Completed', 'Recurring'])
                )
            )
        else:
            # Other Department Managers (non-IT, non-Auditing) can ONLY see their own department's requests
            query = query.filter(PaymentRequest.department == current_user.department)
    
    # Check if "Rejected by Manager" is explicitly in the status filter
    has_rejected_by_manager_filter = status_filter and 'Rejected by Manager' in status_filter
    
    if status_filter:
        # Handle multiple status filters
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                # Show both pending statuses (excluding On Hold)
                status_conditions.append(PaymentRequest.status.in_(['Pending Manager Approval', 'Pending Finance Approval']))
            else:
                status_conditions.append(PaymentRequest.status == status)
        if status_conditions:
            query = query.filter(db.or_(*status_conditions))
    else:
        # If no status filter is selected (showing all statuses), exclude "Rejected by Manager"
        query = query.filter(PaymentRequest.status != 'Rejected by Manager')
    
    if department_filter:
        # Filter by multiple departments
        query = query.filter(PaymentRequest.department.in_(department_filter))
    if request_type_filter:
        # Special handling for "Others" to match both "Others" and "Others:..."
        request_type_conditions = []
        for rt in request_type_filter:
            if rt == 'Others':
                request_type_conditions.append(PaymentRequest.request_type.like('Others%'))
            else:
                request_type_conditions.append(PaymentRequest.request_type == rt)
        if request_type_conditions:
            query = query.filter(db.or_(*request_type_conditions))
    if company_filter:
        # Filter by multiple companies (person_company field only)
        company_conditions = []
        for company in company_filter:
            company_conditions.append(PaymentRequest.person_company.ilike(f'%{company}%'))
        if company_conditions:
            query = query.filter(db.or_(*company_conditions))
    if branch_filter:
        # Alias-aware branch filtering: include canonical name and any aliases
        # Also handle multiple branch names (comma-separated) in branch_name field
        # Handle multiple branch filters
        all_branch_conditions = []
        for branch_name in branch_filter:
            selected_branch = Branch.query.filter_by(name=branch_name).first()
            if selected_branch:
                alias_names = [a.alias_name for a in getattr(selected_branch, 'aliases', [])]
                names = [selected_branch.name] + alias_names
                # Build OR conditions to match if any name appears in the comma-separated branch_name
                conditions = []
                for name in names:
                    # Match exact, at start (with comma after), at end (with comma before), or in middle (with commas around)
                    conditions.append(PaymentRequest.branch_name == name)  # Exact match
                    conditions.append(PaymentRequest.branch_name.like(f'{name},%'))  # At start
                    conditions.append(PaymentRequest.branch_name.like(f'%, {name}'))  # At end (with space after comma)
                    conditions.append(PaymentRequest.branch_name.like(f'%,{name}'))  # At end (no space)
                    conditions.append(PaymentRequest.branch_name.like(f'%, {name},%'))  # In middle (with spaces)
                    conditions.append(PaymentRequest.branch_name.like(f'%,{name},%'))  # In middle (no spaces)
                all_branch_conditions.append(db.or_(*conditions))
            else:
                # For non-alias branches, check if branch name appears in comma-separated list
                conditions = [
                    PaymentRequest.branch_name == branch_name,  # Exact match
                    PaymentRequest.branch_name.like(f'{branch_name},%'),  # At start
                    PaymentRequest.branch_name.like(f'%, {branch_name}'),  # At end (with space)
                    PaymentRequest.branch_name.like(f'%,{branch_name}'),  # At end (no space)
                    PaymentRequest.branch_name.like(f'%, {branch_name},%'),  # In middle (with spaces)
                    PaymentRequest.branch_name.like(f'%,{branch_name},%')  # In middle (no spaces)
                ]
                all_branch_conditions.append(db.or_(*conditions))
        if all_branch_conditions:
            query = query.filter(db.or_(*all_branch_conditions))
    # Payment type filter (handle multiple values)
    if payment_type_filter:
        payment_type_conditions = []
        for pt in payment_type_filter:
            if pt == 'Recurring':
                payment_type_conditions.append(PaymentRequest.recurring == 'Recurring')
            elif pt == 'Scheduled One-Time':
                payment_type_conditions.append(
                    db.and_(
                db.or_(
                    PaymentRequest.recurring == 'Scheduled One-Time',
                    PaymentRequest.payment_date.isnot(None)
                        ),
                        PaymentRequest.recurring != 'Recurring'
                    )
                )
            elif pt == 'One-Time':
                payment_type_conditions.append(
                    db.and_(
                db.or_(
                    PaymentRequest.recurring == None,
                    PaymentRequest.recurring == '',
                    PaymentRequest.recurring == 'One-Time'
                        ),
                        PaymentRequest.payment_date.is_(None)
                )
                )
        if payment_type_conditions:
            query = query.filter(db.or_(*payment_type_conditions))
    
    # Payment method filter (handle multiple values)
    if payment_method_filter:
        query = query.filter(PaymentRequest.payment_method.in_(payment_method_filter))
    
    # Reference number search (Auditing-specific search uses this GET param)
    # Use prefix matching to avoid unrelated substring matches (e.g., '100' matching 'A100B')
    if reference_number:
        query = query.filter(PaymentRequest.reference_number.ilike(f'{reference_number}%'))
    
    # Date filtering - when a date range is provided, filter by completion_date.
    # Additionally, for recurring requests, include requests if any schedule payment
    # (RecurringPaymentSchedule) falls within the date range and is paid.
    # Requests without a completion_date should NOT appear in date-scoped results,
    # except recurring requests that match a paid schedule within the range.
    if date_from or date_to:
        date_from_dt = datetime.strptime(date_from, '%Y-%m-%d').date() if date_from else None
        date_to_dt = datetime.strptime(date_to, '%Y-%m-%d').date() if date_to else None

        # Build completion_date condition(s)
        completion_conditions = [PaymentRequest.completion_date.isnot(None)]
        if date_from_dt:
            completion_conditions.append(PaymentRequest.completion_date >= date_from_dt)
        if date_to_dt:
            completion_conditions.append(PaymentRequest.completion_date <= date_to_dt)
        completion_filter = db.and_(*completion_conditions)

        # Build recurring schedule existence condition
        schedule_q = db.session.query(RecurringPaymentSchedule.schedule_id).filter(
            RecurringPaymentSchedule.request_id == PaymentRequest.request_id,
            RecurringPaymentSchedule.is_paid == True
        )
        if date_from_dt:
            schedule_q = schedule_q.filter(RecurringPaymentSchedule.payment_date >= date_from_dt)
        if date_to_dt:
            schedule_q = schedule_q.filter(RecurringPaymentSchedule.payment_date <= date_to_dt)
        schedule_exists = schedule_q.exists()

        # Final filter: either completion_date matches OR (recurring request AND schedule exists)
        query = query.filter(
            db.or_(
                completion_filter,
                db.and_(PaymentRequest.recurring == 'Recurring', schedule_exists)
            )
        )
    # Sort by status priority then by date (Completed by completion_date, others by created_at)
    # Get all filtered requests for stats calculation (before pagination)
    all_filtered_requests = query.order_by(
        get_status_priority_order(),
        get_all_tab_datetime_order()
    ).all()
    
    # Calculate stats from all filtered requests
    total_requests = len(all_filtered_requests)
    completed_count = len([r for r in all_filtered_requests if r.status == 'Completed'])
    pending_count = len([r for r in all_filtered_requests if r.status in ['Pending Manager Approval', 'Pending Finance Approval']])
    on_hold_count = len([r for r in all_filtered_requests if r.status == 'On Hold'])
    
    # Calculate total amount
    # If a date range is applied, for recurring requests only sum matching paid schedules
    total_amount = 0.0
    if date_from or date_to:
        # Pre-parse date bounds
        date_from_dt = datetime.strptime(date_from, '%Y-%m-%d').date() if date_from else None
        date_to_dt = datetime.strptime(date_to, '%Y-%m-%d').date() if date_to else None

        for r in all_filtered_requests:
            try:
                if getattr(r, 'recurring', None) == 'Recurring':
                    # Sum only schedule amounts that fall within the date range and are paid
                    sched_q = RecurringPaymentSchedule.query.filter(RecurringPaymentSchedule.request_id == r.request_id, RecurringPaymentSchedule.is_paid == True)
                    if date_from_dt:
                        sched_q = sched_q.filter(RecurringPaymentSchedule.payment_date >= date_from_dt)
                    if date_to_dt:
                        sched_q = sched_q.filter(RecurringPaymentSchedule.payment_date <= date_to_dt)
                    schedules = sched_q.all()
                    total_amount += sum(float(s.amount) for s in schedules)
                else:
                    total_amount += float(r.amount)
            except Exception:
                # Fallback - include request amount if anything goes wrong
                try:
                    total_amount += float(r.amount)
                except Exception:
                    pass
    else:
        total_amount = sum(float(r.amount) for r in all_filtered_requests)
    it_amount = None
    
    # Paginate the query for display with the same ordering
    pagination = query.order_by(
        get_status_priority_order(),
        get_all_tab_datetime_order()
    ).paginate(
        page=page, per_page=per_page, error_out=False
    )
    requests = pagination.items
    
    # Get unique departments for filter (exclude archived)
    # For non-IT, non-Auditing Department Managers, only show their own department
    if current_user.role == 'Department Manager' and current_user.department not in ['IT', 'Auditing']:
        departments = [current_user.department] if current_user.department else []
    else:
        # For IT, Auditing Department Managers, and all other users, show all departments (exclude archived)
        departments = db.session.query(PaymentRequest.department).filter(
            PaymentRequest.is_archived == False
        ).distinct().all()
        departments = [d[0] for d in departments]
    
    # Get unique companies for filter (only person_company field since company_name is no longer used)
    # Show companies from all statuses, or filter by status if status_filter is provided (exclude archived)
    companies_query = db.session.query(PaymentRequest.person_company).filter(
        PaymentRequest.is_archived == False,
        PaymentRequest.person_company.isnot(None),
        PaymentRequest.person_company != ''
    )
    if status_filter:
        # Handle multiple status filters
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                status_conditions.append(PaymentRequest.status.in_(['Pending Manager Approval', 'Pending Finance Approval']))
        else:
                status_conditions.append(PaymentRequest.status == status)
        if status_conditions:
            companies_query = companies_query.filter(db.or_(*status_conditions))
    companies_raw = companies_query.distinct().all()
    companies_list = [c[0] for c in companies_raw if c[0]]
    companies_list = sorted(companies_list)  # Sort alphabetically

    # Enrich companies with optional descriptions from PersonCompanyOption table
    companies = []
    for comp_name in companies_list:
        # Try to find a matching PersonCompanyOption (exact match)
        opt = PersonCompanyOption.query.filter_by(name=comp_name).first()
        description = opt.description if opt and getattr(opt, 'description', None) else ''
        companies.append({
            'value': comp_name,
            'text': comp_name,
            'description': description or ''
        })
    
    # Get unique branches for filter
    branches = Branch.query.filter_by(is_active=True).order_by(Branch.name).all()
    
    # Get request types based on selected departments
    if department_filter:
        # If departments are selected, show request types for those departments
        request_types = db.session.query(RequestType.name).filter(
            RequestType.department.in_(department_filter),
            RequestType.is_active == True
        ).distinct().order_by(RequestType.name).all()
        request_types = [rt[0] for rt in request_types]
    else:
        # If no department selected, show all unique request types (remove duplicates)
        request_types = db.session.query(RequestType.name).filter(
            RequestType.is_active == True
        ).distinct().order_by(RequestType.name).all()
        request_types = [rt[0] for rt in request_types]
    
    return render_template('reports.html', 
                         requests=requests, 
                         pagination=pagination,
                         departments=departments,
                         companies=companies,
                         branches=branches,
                         request_types=request_types,
                         company_filter=company_filter,
                         branch_filter=branch_filter,
                         status_filter=status_filter,
                         payment_type_filter=payment_type_filter,
                         department_filter=department_filter,
                         request_type_filter=request_type_filter,
                         date_from=date_from,
                         date_to=date_to,
                         total_requests=total_requests,
                         completed_count=completed_count,
                         pending_count=pending_count,
                         on_hold_count=on_hold_count,
                         total_amount=total_amount,
                         it_amount=it_amount,
                         user=current_user)


@app.route('/procurement/item-requests/reports')
@login_required
@role_required('Procurement Manager', 'Procurement Staff', 'GM', 'CEO', 'IT Staff', 'Department Manager', 'Operation Manager', 'Auditing Staff')
def item_request_reports():
    """View item request reports page"""
    # Get filter parameters (support multiple values)
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    department_filter = request.args.getlist('department')  # List of departments
    category_filter = request.args.getlist('category')  # List of categories
    branch_filter = request.args.getlist('branch')  # List of branches
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    status_filter = request.args.getlist('status')  # List of statuses
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 20, 50, 100]:
        per_page = 10
    
    # Build query
    query = ProcurementItemRequest.query.filter(ProcurementItemRequest.is_draft == False)
    
    # Auditing Staff: only Completed item requests in reports
    if current_user.role == 'Auditing Staff':
        query = query.filter(ProcurementItemRequest.status == 'Completed')
    
    # GM, CEO, IT Staff, and Operation Manager can see ALL requests from all statuses
    # Only filter for Department Managers
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            # IT Department Manager can see ALL requests
            pass
        elif current_user.department == 'Procurement':
            # Procurement Department Manager can only see: Assigned to Procurement, Completed, Pending Procurement Manager Approval
            query = query.filter(ProcurementItemRequest.status.in_([
                'Assigned to Procurement',
                'Completed',
                'Pending Procurement Manager Approval'
            ]))
        elif current_user.department == 'Auditing':
            # Auditing Department Manager can see all completed requests
            query = query.filter(ProcurementItemRequest.status == 'Completed')
        else:
            # Other Department Managers can ONLY see their own department's requests
            query = query.filter(ProcurementItemRequest.department == current_user.department)
    # GM, CEO, IT Staff, Operation Manager, and Procurement Staff can see all requests (no filtering)
    
    # Status filter
    if status_filter:
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                # Show all pending statuses
                status_conditions.append(ProcurementItemRequest.status.in_([
                    'Pending Manager Approval', 
                    'Pending Procurement Manager Approval',
                    'Assigned to Procurement'
                ]))
            else:
                status_conditions.append(ProcurementItemRequest.status == status)
        if status_conditions:
            query = query.filter(db.or_(*status_conditions))
    else:
        # If no status filter, exclude "Rejected by Manager" by default
        query = query.filter(ProcurementItemRequest.status != 'Rejected by Manager')
    
    if department_filter:
        query = query.filter(ProcurementItemRequest.department.in_(department_filter))
    
    if category_filter:
        query = query.filter(ProcurementItemRequest.category.in_(category_filter))
    
    if branch_filter:
        # Handle multiple branch filters (similar to payment requests)
        all_branch_conditions = []
        for branch_name in branch_filter:
            selected_branch = Branch.query.filter_by(name=branch_name).first()
            if selected_branch:
                alias_names = [a.alias_name for a in getattr(selected_branch, 'aliases', [])]
                names = [selected_branch.name] + alias_names
                conditions = []
                for name in names:
                    conditions.append(ProcurementItemRequest.branch_name == name)
                    conditions.append(ProcurementItemRequest.branch_name.like(f'{name},%'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%, {name}'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%,{name}'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%, {name},%'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%,{name},%'))
                all_branch_conditions.append(db.or_(*conditions))
            else:
                conditions = [
                    ProcurementItemRequest.branch_name == branch_name,
                    ProcurementItemRequest.branch_name.like(f'{branch_name},%'),
                    ProcurementItemRequest.branch_name.like(f'%, {branch_name}'),
                    ProcurementItemRequest.branch_name.like(f'%,{branch_name}'),
                    ProcurementItemRequest.branch_name.like(f'%, {branch_name},%'),
                    ProcurementItemRequest.branch_name.like(f'%,{branch_name},%')
                ]
                all_branch_conditions.append(db.or_(*conditions))
        if all_branch_conditions:
            query = query.filter(db.or_(*all_branch_conditions))
    
    # Date filtering - when a date range is provided, filter by completion_date.
    # Requests without a completion_date should NOT appear in date-scoped results.
    if date_from:
        # completion_date is a DateTime; compare against a datetime at midnight
        query = query.filter(ProcurementItemRequest.completion_date.isnot(None)).filter(
            ProcurementItemRequest.completion_date >= datetime.strptime(date_from, '%Y-%m-%d')
        )
    if date_to:
        query = query.filter(ProcurementItemRequest.completion_date.isnot(None)).filter(
            ProcurementItemRequest.completion_date <= datetime.strptime(date_to, '%Y-%m-%d')
        )
    
    # Reference number search for item requests - use receipt_reference_number with prefix matching
    reference_number = request.args.get('reference_number', '').strip()
    if reference_number:
        query = query.filter(ProcurementItemRequest.receipt_reference_number.ilike(f'{reference_number}%'))
    
    # Get all filtered requests for stats calculation (before pagination)
    all_filtered_requests = query.order_by(ProcurementItemRequest.created_at.desc()).all()
    
    # Calculate stats from all filtered requests
    total_requests = len(all_filtered_requests)
    completed_count = len([r for r in all_filtered_requests if r.status == 'Completed'])
    pending_count = len([r for r in all_filtered_requests if r.status in [
        'Pending Manager Approval', 
        'Pending Procurement Manager Approval',
        'Assigned to Procurement'
    ]])
    
    # Calculate total amount (from receipt_amount field)
    total_amount = sum(float(r.receipt_amount) if r.receipt_amount else 0 for r in all_filtered_requests)
    
    # Paginate the query for display
    pagination = query.order_by(ProcurementItemRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    requests = pagination.items
    
    # Get unique departments for filter (only those visible to current user)
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            # IT Manager can see all departments
            departments = db.session.query(ProcurementItemRequest.department).filter(
                ProcurementItemRequest.is_draft == False,
                ProcurementItemRequest.department.isnot(None),
                ProcurementItemRequest.department != ''
            ).distinct().all()
        elif current_user.department == 'Procurement':
            # Procurement Manager can only see departments with requests in visible statuses
            departments = db.session.query(ProcurementItemRequest.department).filter(
                ProcurementItemRequest.is_draft == False,
                ProcurementItemRequest.department.isnot(None),
                ProcurementItemRequest.department != '',
                ProcurementItemRequest.status.in_([
                    'Assigned to Procurement',
                    'Completed',
                    'Pending Procurement Manager Approval'
                ])
            ).distinct().all()
        elif current_user.department == 'Auditing':
            # Auditing Manager can only see departments with completed requests
            departments = db.session.query(ProcurementItemRequest.department).filter(
                ProcurementItemRequest.is_draft == False,
                ProcurementItemRequest.department.isnot(None),
                ProcurementItemRequest.department != '',
                ProcurementItemRequest.status == 'Completed'
            ).distinct().all()
        else:
            # Other Department Managers can only see their own department
            departments = [current_user.department] if current_user.department else []
        
        # Extract department names from tuples for IT, Procurement, and Auditing managers
        if current_user.department in ['IT', 'Procurement', 'Auditing']:
            departments = [d[0] for d in departments if d[0]]
            departments.sort()
    else:
        # GM, CEO, IT Staff, Operation Manager, and Procurement Staff can see all departments
        departments = db.session.query(ProcurementItemRequest.department).filter(
            ProcurementItemRequest.is_draft == False,
            ProcurementItemRequest.department.isnot(None),
            ProcurementItemRequest.department != ''
        ).distinct().all()
        departments = [d[0] for d in departments if d[0]]
        departments.sort()
    
    # Get unique categories for filter (only those visible to current user)
    categories_query = db.session.query(ProcurementItemRequest.category).filter(
        ProcurementItemRequest.is_draft == False,
        ProcurementItemRequest.category.isnot(None),
        ProcurementItemRequest.category != ''
    )
    
    # Apply role-based visibility filters
    if current_user.role == 'Department Manager':
        if current_user.department == 'Procurement':
            # Procurement Manager can only see categories with requests in visible statuses
            categories_query = categories_query.filter(
                ProcurementItemRequest.status.in_([
                    'Assigned to Procurement',
                    'Completed',
                    'Pending Procurement Manager Approval'
                ])
            )
        elif current_user.department == 'Auditing':
            # Auditing Manager can only see categories with completed requests
            categories_query = categories_query.filter(
                ProcurementItemRequest.status == 'Completed'
            )
        elif current_user.department != 'IT':
            # Other Department Managers can only see their own department's categories
            categories_query = categories_query.filter(
                ProcurementItemRequest.department == current_user.department
            )
    
    if status_filter:
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                status_conditions.append(ProcurementItemRequest.status.in_([
                    'Pending Manager Approval', 
                    'Pending Procurement Manager Approval',
                    'Assigned to Procurement'
                ]))
            else:
                status_conditions.append(ProcurementItemRequest.status == status)
        if status_conditions:
            categories_query = categories_query.filter(db.or_(*status_conditions))
    categories = categories_query.distinct().all()
    categories = [c[0] for c in categories if c[0]]
    categories.sort()
    
    # Get unique branches for filter
    branches = Branch.query.filter_by(is_active=True).order_by(Branch.name).all()
    
    return render_template('item_request_reports.html', 
                         requests=requests, 
                         pagination=pagination,
                         departments=departments,
                         categories=categories,
                         branches=branches,
                         category_filter=category_filter,
                         branch_filter=branch_filter,
                         status_filter=status_filter,
                         department_filter=department_filter,
                         date_from=date_from,
                         date_to=date_to,
                         total_requests=total_requests,
                         completed_count=completed_count,
                         pending_count=pending_count,
                         total_amount=total_amount,
                         user=current_user)


@app.route('/export/item-request-reports/excel')
@login_required
def export_item_request_reports_excel():
    """Export item request reports to Excel with professional formatting"""
    import io
    try:
        import openpyxl
        from openpyxl.styles import Font, PatternFill, Alignment
        from openpyxl.utils import get_column_letter
    except ImportError:
        flash('Excel export requires openpyxl. Install with: pip install openpyxl', 'warning')
        return redirect(url_for('item_request_reports', **request.args))
    except Exception as e:
        flash(f'Error importing Excel library: {str(e)}', 'error')
        return redirect(url_for('item_request_reports', **request.args))

    # Get same filters as item_request_reports view
    department_filter = request.args.getlist('department')
    category_filter = request.args.getlist('category')
    branch_filter = request.args.getlist('branch')
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    status_filter = request.args.getlist('status')
    
    # Build query (same logic as item_request_reports)
    query = ProcurementItemRequest.query.filter(ProcurementItemRequest.is_draft == False)
    
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            pass
        elif current_user.department == 'Procurement':
            query = query.filter(ProcurementItemRequest.status.in_([
                'Assigned to Procurement',
                'Completed',
                'Pending Procurement Manager Approval'
            ]))
        elif current_user.department == 'Auditing':
            query = query.filter(ProcurementItemRequest.status == 'Completed')
        else:
            query = query.filter(ProcurementItemRequest.department == current_user.department)
    
    if status_filter:
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                status_conditions.append(ProcurementItemRequest.status.in_([
                    'Pending Manager Approval', 
                    'Pending Procurement Manager Approval',
                    'Assigned to Procurement'
                ]))
            else:
                status_conditions.append(ProcurementItemRequest.status == status)
        if status_conditions:
            query = query.filter(db.or_(*status_conditions))
    else:
        query = query.filter(ProcurementItemRequest.status != 'Rejected by Manager')
    
    if department_filter:
        query = query.filter(ProcurementItemRequest.department.in_(department_filter))
    
    if category_filter:
        query = query.filter(ProcurementItemRequest.category.in_(category_filter))
    
    if branch_filter:
        all_branch_conditions = []
        for branch_name in branch_filter:
            selected_branch = Branch.query.filter_by(name=branch_name).first()
            if selected_branch:
                alias_names = [a.alias_name for a in getattr(selected_branch, 'aliases', [])]
                names = [selected_branch.name] + alias_names
                conditions = []
                for name in names:
                    conditions.append(ProcurementItemRequest.branch_name == name)
                    conditions.append(ProcurementItemRequest.branch_name.like(f'{name},%'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%, {name}'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%,{name}'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%, {name},%'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%,{name},%'))
                all_branch_conditions.append(db.or_(*conditions))
            else:
                conditions = [
                    ProcurementItemRequest.branch_name == branch_name,
                    ProcurementItemRequest.branch_name.like(f'{branch_name},%'),
                    ProcurementItemRequest.branch_name.like(f'%, {branch_name}'),
                    ProcurementItemRequest.branch_name.like(f'%,{branch_name}'),
                    ProcurementItemRequest.branch_name.like(f'%, {branch_name},%'),
                    ProcurementItemRequest.branch_name.like(f'%,{branch_name},%')
                ]
                all_branch_conditions.append(db.or_(*conditions))
        if all_branch_conditions:
            query = query.filter(db.or_(*all_branch_conditions))
    
    # Date filtering - when a date range is provided, filter by completion_date.
    # Requests without a completion_date should NOT appear in date-scoped results.
    if date_from:
        query = query.filter(ProcurementItemRequest.completion_date.isnot(None)).filter(
            ProcurementItemRequest.completion_date >= datetime.strptime(date_from, '%Y-%m-%d')
        )
    if date_to:
        query = query.filter(ProcurementItemRequest.completion_date.isnot(None)).filter(
            ProcurementItemRequest.completion_date <= datetime.strptime(date_to, '%Y-%m-%d')
        )
    
    # Get all filtered requests
    all_requests = query.order_by(ProcurementItemRequest.created_at.desc()).all()
    
    # Helper function to convert to float
    def to_float(value):
        try:
            return float(value)
        except Exception:
            return 0.0
    
    # Sum all amounts
    total_amount = sum(to_float(r.receipt_amount) for r in all_requests)
    
    try:
        # Create Excel workbook
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Item Request Reports"
        
        # Add report header information
        ws['A1'] = 'Item Request Reports'
        ws['A1'].font = Font(size=16, bold=True)
        
        generation_date = datetime.now().strftime('%Y-%m-%d %H:%M')
        ws['A2'] = f"Report Generated: {generation_date}"
        
        # Build comprehensive filters line
        filter_parts = []
        filter_parts.append(f"Dept: {', '.join(department_filter) if department_filter else 'All'}")
        filter_parts.append(f"Category: {', '.join(category_filter) if category_filter else 'All'}")
        filter_parts.append(f"Branch: {', '.join(branch_filter) if branch_filter else 'All'}")
        filter_parts.append(f"Status: {', '.join(status_filter) if status_filter else 'All'}")
        filters_line = " | ".join(filter_parts)
        ws['A3'] = filters_line
        
        # Date scope
        if date_from and date_to:
            ws['A4'] = f"Date Range: {date_from} to {date_to}"
        elif date_from:
            ws['A4'] = f"Date From: {date_from} (no end date)"
        elif date_to:
            ws['A4'] = f"Date To: {date_to} (no start date)"
        else:
            ws['A4'] = "Date Range: All dates (no filter applied)"
        
        ws['A5'] = f"Total Amount: OMR {total_amount:.3f}"
        ws['A5'].font = Font(size=12, bold=True)
        
        # Add headers starting from row 7 (include Completion Date)
        headers = ['ID', 'Category', 'Item Name', 'Quantity', 'Requestor', 'Department', 'Branch', 'Request Date', 'Completion Date', 'Status', 'Amount (OMR)', 'Assigned To']
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=7, column=col, value=str(header))
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
            ws.row_dimensions[7].height = 20
        
        # Add data rows
        for row_idx, req in enumerate(all_requests, 8):
            request_date_str = req.request_date.strftime('%Y-%m-%d') if req.request_date else '-'
            completion_date_str = req.completion_date.strftime('%Y-%m-%d') if getattr(req, 'completion_date', None) else '-'
            amount_value = to_float(req.receipt_amount)
            # Get quantity from assigned procurement staff (preferred), then manager, then original
            quantity_source = req.assigned_procurement_quantities or req.procurement_manager_quantities or req.procurement_quantities or req.quantity or ''
            
            # Format Item Name with line breaks instead of commas, filtering out items with quantity 0
            item_names = req.item_name.split(',') if req.item_name else []
            quantities = quantity_source.split(';') if quantity_source else []
            
            # Filter items where quantity is not 0
            filtered_items = []
            filtered_quantities = []
            for idx, item in enumerate(item_names):
                item_trimmed = item.strip()
                if item_trimmed:
                    qty_val = ''
                    if idx < len(quantities):
                        qty_raw = quantities[idx].strip()
                        qty_val = qty_raw if qty_raw else '0'
                    else:
                        qty_val = '0'
                    
                    # Only include if quantity is not '0'
                    try:
                        qty_num = float(qty_val) if qty_val else 0
                        if qty_num != 0:
                            filtered_items.append(item_trimmed)
                            filtered_quantities.append(qty_val)
                    except:
                        # If we can't parse as float, include it (might be non-numeric)
                        if qty_val != '0':
                            filtered_items.append(item_trimmed)
                            filtered_quantities.append(qty_val)
            
            item_display = '\n'.join(filtered_items) if filtered_items else ''
            quantity_display = '\n'.join(filtered_quantities) if filtered_quantities else ''
            
            # Format Branch with line breaks instead of commas
            branches = req.branch_name.split(',') if req.branch_name else []
            branch_display = '\n'.join([branch.strip() for branch in branches if branch.strip()]) if branches else ''
            
            row_data = [
                f"#{req.id}",
                str(req.category or ''),
                item_display or '',
                quantity_display or '',
                str(req.requestor_name or ''),
                str(req.department or ''),
                branch_display or '',
                request_date_str,
                completion_date_str,
                str(req.status or ''),
                amount_value,
                str(req.assigned_to_user.name if req.assigned_to_user else '')
            ]
            
            for col, data in enumerate(row_data, 1):
                # For Amount column (now column 11), explicitly set as float
                if col == 11:
                    numeric_value = float(amount_value) if amount_value is not None else 0.0
                    cell = ws.cell(row=row_idx, column=col, value=numeric_value)
                    cell.number_format = '#,##0.000'
                    cell.alignment = Alignment(horizontal='right', vertical='top')
                else:
                    cell = ws.cell(row=row_idx, column=col, value=str(data) if data is not None else '')
                    if col in [3, 4, 7]:  # Item Name, Quantity, Branch columns - enable wrapping
                        cell.alignment = Alignment(wrap_text=True, vertical='top')
                    else:
                        cell.alignment = Alignment(vertical='top', horizontal='left')
        
        # Auto-adjust column widths
        for col_idx in range(1, len(headers) + 1):
            max_length = 0
            column_letter = get_column_letter(col_idx)
            
            for row in range(7, ws.max_row + 1):
                cell = ws.cell(row=row, column=col_idx)
                try:
                    cell_value = str(cell.value) if cell.value is not None else ''
                    if col_idx in [3, 6]:  # Item Name, Branch
                        lines = cell_value.split('\n')
                        max_line_length = max(len(line) for line in lines) if lines else 0
                        max_length = max(max_length, max_line_length)
                    else:
                        max_length = max(max_length, len(cell_value))
                except:
                    pass
            
            # Special handling for specific columns
            if column_letter == 'A':  # ID column
                adjusted_width = min(max_length + 2, 12)
            elif column_letter == 'D':  # Requestor column
                adjusted_width = min(max_length + 2, 20)
            elif column_letter == 'I':  # Amount column
                adjusted_width = max(max_length + 2, 18)
            else:
                adjusted_width = min(max_length + 2, 50)
            
            adjusted_width = max(adjusted_width, 10)
            ws.column_dimensions[column_letter].width = adjusted_width
        
        # Auto-adjust row heights for rows with wrapped text
        for row_idx in range(7, ws.max_row + 1):
            max_height = 15
            for col_idx in [3, 6]:  # Columns with wrapped text
                cell = ws.cell(row=row_idx, column=col_idx)
                if cell.value:
                    cell_value = str(cell.value)
                    column_letter = get_column_letter(col_idx)
                    column_width = ws.column_dimensions[column_letter].width
                    chars_per_line = max(1, int(column_width * 7))
                    lines = len(cell_value.split('\n'))
                    estimated_lines = max(lines, (len(cell_value) // chars_per_line) + 1)
                    row_height = max(max_height, estimated_lines * 15)
                    max_height = row_height
            
            ws.row_dimensions[row_idx].height = max_height
        
        # Create response
        output = io.BytesIO()
        wb.save(output)
        output.seek(0)
        
        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name=f'item_request_reports_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
        )
    except Exception as e:
        flash(f'Error generating Excel export: {str(e)}', 'error')
        return redirect(url_for('item_request_reports', **request.args))


@app.route('/export/item-request-reports/pdf')
@login_required
def export_item_request_reports_pdf():
    """Export item request reports to PDF using canvas approach (matching payment reports)"""
    import io
    import os
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.pdfgen import canvas
        from reportlab.lib.units import mm
    except ImportError:
        flash('PDF export requires reportlab. Install with: pip install reportlab', 'warning')
        return redirect(url_for('item_request_reports', **request.args))
    
    # Get same filters as item_request_reports view
    department_filter = request.args.getlist('department')
    category_filter = request.args.getlist('category')
    branch_filter = request.args.getlist('branch')
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    status_filter = request.args.getlist('status')
    
    # Build query (same logic as item_request_reports)
    query = ProcurementItemRequest.query.filter(ProcurementItemRequest.is_draft == False)
    
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            pass
        elif current_user.department == 'Procurement':
            query = query.filter(ProcurementItemRequest.status.in_([
                'Assigned to Procurement',
                'Completed',
                'Pending Procurement Manager Approval'
            ]))
        elif current_user.department == 'Auditing':
            query = query.filter(ProcurementItemRequest.status == 'Completed')
        else:
            query = query.filter(ProcurementItemRequest.department == current_user.department)
    
    if status_filter:
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                status_conditions.append(ProcurementItemRequest.status.in_([
                    'Pending Manager Approval', 
                    'Pending Procurement Manager Approval',
                    'Assigned to Procurement'
                ]))
            else:
                status_conditions.append(ProcurementItemRequest.status == status)
        if status_conditions:
            query = query.filter(db.or_(*status_conditions))
    else:
        query = query.filter(ProcurementItemRequest.status != 'Rejected by Manager')
    
    if department_filter:
        query = query.filter(ProcurementItemRequest.department.in_(department_filter))
    
    if category_filter:
        query = query.filter(ProcurementItemRequest.category.in_(category_filter))
    
    if branch_filter:
        all_branch_conditions = []
        for branch_name in branch_filter:
            selected_branch = Branch.query.filter_by(name=branch_name).first()
            if selected_branch:
                alias_names = [a.alias_name for a in getattr(selected_branch, 'aliases', [])]
                names = [selected_branch.name] + alias_names
                conditions = []
                for name in names:
                    conditions.append(ProcurementItemRequest.branch_name == name)
                    conditions.append(ProcurementItemRequest.branch_name.like(f'{name},%'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%, {name}'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%,{name}'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%, {name},%'))
                    conditions.append(ProcurementItemRequest.branch_name.like(f'%,{name},%'))
                all_branch_conditions.append(db.or_(*conditions))
            else:
                conditions = [
                    ProcurementItemRequest.branch_name == branch_name,
                    ProcurementItemRequest.branch_name.like(f'{branch_name},%'),
                    ProcurementItemRequest.branch_name.like(f'%, {branch_name}'),
                    ProcurementItemRequest.branch_name.like(f'%,{branch_name}'),
                    ProcurementItemRequest.branch_name.like(f'%, {branch_name},%'),
                    ProcurementItemRequest.branch_name.like(f'%,{branch_name},%')
                ]
                all_branch_conditions.append(db.or_(*conditions))
        if all_branch_conditions:
            query = query.filter(db.or_(*all_branch_conditions))
    
    # Date filtering - use completion_date for item request reports (exclude those without completion_date)
    if date_from:
        query = query.filter(ProcurementItemRequest.completion_date.isnot(None)).filter(
            ProcurementItemRequest.completion_date >= datetime.strptime(date_from, '%Y-%m-%d')
        )
    if date_to:
        query = query.filter(ProcurementItemRequest.completion_date.isnot(None)).filter(
            ProcurementItemRequest.completion_date <= datetime.strptime(date_to, '%Y-%m-%d')
        )
    
    # Get all filtered requests
    result_requests = query.order_by(ProcurementItemRequest.created_at.desc()).all()
    
    # Helper function to convert to float
    def to_float(value):
        try:
            return float(value)
        except Exception:
            return 0.0
    
    # Sum all amounts
    total_amount = sum(to_float(r.receipt_amount) for r in result_requests)
    
    try:
        # Build PDF in landscape orientation (matching payment reports)
        buffer = io.BytesIO()
        from reportlab.lib.pagesizes import landscape
        c = canvas.Canvas(buffer, pagesize=landscape(A4))
        width, height = landscape(A4)
        
        body_font = 'Helvetica'
        
        # Margins
        left = 8 * mm
        right = width - 8 * mm
        top = height - 8 * mm
        y = top
        
        # Header
        c.setFont('Helvetica-Bold', 14)
        c.drawString(left, y, 'Item Request Reports')
        c.setFont(body_font, 10)
        y -= 14
        
        # Report generation date
        generation_date = datetime.now().strftime('%Y-%m-%d %H:%M')
        c.drawString(left, y, f"Report Generated: {generation_date}")
        y -= 12
        
        # Filters
        filters_line = f"Dept: {', '.join(department_filter) if department_filter else 'All'} | Category: {', '.join(category_filter) if category_filter else 'All'} | Branch: {', '.join(branch_filter) if branch_filter else 'All'} | Status: {', '.join(status_filter) if status_filter else 'All'}"
        c.drawString(left, y, filters_line)
        y -= 12
        
        # Date scope
        if date_from and date_to:
            c.drawString(left, y, f"Date Range: {date_from} to {date_to}")
        elif date_from:
            c.drawString(left, y, f"Date From: {date_from} (no end date)")
        elif date_to:
            c.drawString(left, y, f"Date To: {date_to} (no start date)")
        else:
            c.drawString(left, y, "Date Range: All dates (no filter applied)")
        y -= 12
        
        # Total amount
        c.setFont('Helvetica-Bold', 11)
        c.drawString(left, y, f"Total Amount: OMR {total_amount:.3f}")
        y -= 18
        
        # Table header (include Completion Date)
        c.setFont('Helvetica-Bold', 9)
        headers = ['ID']
        col_widths = [12*mm]
        # Include Ref. No. only for Auditing users
        if current_user.department == 'Auditing' or current_user.role == 'Auditing Staff':
            headers.append('Ref. No.')
            col_widths.append(14*mm)
        headers += ['Category', 'Item Name', 'Quantity', 'Requestor', 'Department', 'Branch', 'Request Date', 'Completion Date', 'Status', 'Amount', 'Assigned To']
        col_widths += [16*mm, 26*mm, 14*mm, 18*mm, 16*mm, 20*mm, 18*mm, 18*mm, 17*mm, 14*mm, 18*mm]
        column_gap = 4 * mm
        col_x = [left]
        for i in range(1, len(col_widths)):
            col_x.append(col_x[i-1] + col_widths[i-1] + column_gap)
        
        for i, (hx, text) in enumerate(zip(col_x, headers)):
            c.drawString(hx, y, text)
        y -= 10
        c.line(left, y, right, y)
        y -= 8
        
        # Helper function to wrap text
        def wrap_text(text, max_width, font_name='Helvetica', font_size=9):
            """Wrap text to fit within specified width"""
            s = '' if text is None else str(text)
            if not s:
                return ['']
            
            try:
                from reportlab.pdfbase import pdfmetrics
                def string_width(t):
                    return pdfmetrics.stringWidth(t, font_name, font_size)
            except:
                def string_width(t):
                    return len(t) * font_size * 0.5
            
            effective_width = max_width - 2*mm
            words = s.split()
            wrapped_lines = []
            current = ''
            
            for word in words:
                candidate = (current + ' ' + word).strip()
                if current and string_width(candidate) > effective_width:
                    wrapped_lines.append(current)
                    current = word
                else:
                    current = candidate
            
            if current:
                wrapped_lines.append(current)
            
            return wrapped_lines or ['']
        
        # Rows
        c.setFont(body_font, 9)
        row_height = 10
        bottom_margin = 15 * mm
        for r in result_requests:
            # Calculate maximum height needed for this row
            max_height = 0
            wrapped_lines_per_col = []
            
            # Get quantity from assigned procurement staff (preferred), then manager, then original
            quantity_source = r.assigned_procurement_quantities or r.procurement_manager_quantities or r.procurement_quantities or r.quantity or ''
            
            # Format Item Name with line breaks instead of commas, filtering out items with quantity 0
            item_names = (r.item_name or '').split(',')
            quantities = quantity_source.split(';') if quantity_source else []
            
            # Filter items where quantity is not 0
            filtered_items = []
            filtered_quantities = []
            for idx, item in enumerate(item_names):
                item_trimmed = item.strip()
                if item_trimmed:
                    qty_val = ''
                    if idx < len(quantities):
                        qty_raw = quantities[idx].strip()
                        qty_val = qty_raw if qty_raw else '0'
                    else:
                        qty_val = '0'
                    
                    # Only include if quantity is not '0'
                    try:
                        qty_num = float(qty_val) if qty_val else 0
                        if qty_num != 0:
                            filtered_items.append(item_trimmed)
                            filtered_quantities.append(qty_val)
                    except:
                        # If we can't parse as float, include it (might be non-numeric)
                        if qty_val != '0':
                            filtered_items.append(item_trimmed)
                            filtered_quantities.append(qty_val)
            
            item_display = '\n'.join(filtered_items) if filtered_items else ''
            quantity_display = '\n'.join(filtered_quantities) if filtered_quantities else ''
            
            # Format Branch with line breaks instead of commas
            branches = (r.branch_name or '').split(',')
            branch_display = '\n'.join([branch.strip() for branch in branches if branch.strip()]) if branches else ''
            
            row_data = [f"#{r.id}"]
            if current_user.department == 'Auditing' or current_user.role == 'Auditing Staff':
                row_data.append(str(r.receipt_reference_number or ''))
            row_data += [
                str(r.category or ''),
                item_display or '',
                quantity_display or '',
                str(r.requestor_name or ''),
                str(r.department or ''),
                branch_display or '',
                r.request_date.strftime('%Y-%m-%d') if r.request_date else '-',
                r.completion_date.strftime('%Y-%m-%d') if getattr(r, 'completion_date', None) else '-',
                str(r.status or ''),
                f"OMR {to_float(r.receipt_amount):.3f}",
                str(r.assigned_to_user.name if r.assigned_to_user else '')
            ]
            
            # Pre-wrap and measure
            for i, (data, width) in enumerate(zip(row_data, col_widths)):
                if data:
                    lines = wrap_text(str(data), width, body_font, 9)
                else:
                    lines = ['']
                wrapped_lines_per_col.append(lines)
                max_height = max(max_height, len(lines) * 10)
            
            # If row overflows page, create new page
            if y - max_height < bottom_margin:
                c.showPage()
                y = top
                c.setFont('Helvetica-Bold', 9)
                for i, (hx, text) in enumerate(zip(col_x, headers)):
                    c.drawString(hx, y, text)
                y -= 10
                c.line(left, y, right, y)
                y -= 8
                c.setFont(body_font, 9)
            
            # Draw columns
            for i, lines in enumerate(wrapped_lines_per_col):
                for j, line in enumerate(lines):
                    c.drawString(col_x[i], y - (j * 10), line)
            
            y -= max_height + 3
        
        c.showPage()
        c.save()
        pdf_value = buffer.getvalue()
        buffer.close()
        
        from flask import make_response
        response = make_response(pdf_value)
        response.headers['Content-Type'] = 'application/pdf'
        ts = datetime.now().strftime('%Y-%m-%d_%H-%M')
        response.headers['Content-Disposition'] = f'attachment; filename=item_request_reports_{ts}.pdf'
        response.headers['Content-Length'] = str(len(pdf_value))
        return response
        
    except Exception as e:
        flash(f'Error generating PDF: {str(e)}', 'error')
        return redirect(url_for('item_request_reports', **request.args))


@app.route('/cheque-register')
@login_required
def cheque_register():
    """View cheque register page"""
    # Get filters from query parameters
    book_filter = request.args.get('book', '')
    status_filter = request.args.get('status', '')
    
    # Get all unique book numbers for the filter dropdown
    book_numbers = db.session.query(ChequeBook.book_no).distinct().order_by(ChequeBook.book_no).all()
    book_numbers = [book[0] for book in book_numbers]
    
    # Build query
    query = db.session.query(ChequeSerial).join(ChequeBook)
    
    # Apply book filter if provided
    if book_filter:
        try:
            book_no = int(book_filter)
            query = query.filter(ChequeBook.book_no == book_no)
        except ValueError:
            pass  # Invalid book number, ignore filter
    
    # Apply status filter if provided
    if status_filter:
        valid_statuses = ['Available', 'Reserved', 'Used', 'Cancelled']
        if status_filter in valid_statuses:
            query = query.filter(ChequeSerial.status == status_filter)
    
    # Fetch all cheque serials with their book information, ordered by book_no and serial_no
    cheque_serials = query.order_by(
        ChequeBook.book_no, ChequeSerial.serial_no
    ).all()
    
    return render_template('cheque_register.html', 
                          cheque_serials=cheque_serials, 
                          book_numbers=book_numbers,
                          book_filter=book_filter,
                          status_filter=status_filter)


@app.route('/cheque-register/reserve', methods=['GET', 'POST'])
@login_required
def reserve_cheque():
    """Reserve cheque serial numbers"""
    if request.method == 'GET':
        # Get book filter from query parameters
        book_filter = request.args.get('book', '')
        
        # Get all unique book numbers for the filter dropdown
        book_numbers = db.session.query(ChequeBook.book_no).distinct().order_by(ChequeBook.book_no).all()
        book_numbers = [book[0] for book in book_numbers]
        
        # Build query for available serials
        query = db.session.query(ChequeSerial).join(ChequeBook).filter(
            ChequeSerial.status == 'Available'
        )
        
        # Apply book filter if provided
        if book_filter:
            try:
                book_no = int(book_filter)
                query = query.filter(ChequeBook.book_no == book_no)
            except ValueError:
                pass  # Invalid book number, ignore filter
        
        # Fetch all available serial numbers
        available_serials = query.order_by(
            ChequeBook.book_no, ChequeSerial.serial_no
        ).all()
        
        return render_template('reserve_cheque.html', 
                             available_serials=available_serials,
                             book_numbers=book_numbers,
                             book_filter=book_filter)
    
    elif request.method == 'POST':
        # Handle reservation
        try:
            data = request.get_json()
            serial_ids = data.get('serial_ids', [])
            
            if not serial_ids:
                return jsonify({'success': False, 'error': 'No serial numbers selected'}), 400
            
            # Validate that all serials exist and are available
            serials = ChequeSerial.query.filter(
                ChequeSerial.id.in_(serial_ids),
                ChequeSerial.status == 'Available'
            ).all()
            
            if len(serials) != len(serial_ids):
                return jsonify({'success': False, 'error': 'Some selected serial numbers are not available'}), 400
            
            # Update status to Reserved
            reserved_count = 0
            for serial in serials:
                serial.status = 'Reserved'
                reserved_count += 1
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'reserved_count': reserved_count,
                'message': f'Successfully reserved {reserved_count} serial number(s)'
            })
            
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/cheque-register/new-book', methods=['GET', 'POST'])
@login_required
def new_book():
    """Add new cheque book"""
    if request.method == 'POST':
        book_no = request.form.get('book_no')
        start_serial_no = request.form.get('start_serial_no')
        last_serial_no = request.form.get('last_serial_no')
        
        # Validation
        try:
            book_no = int(book_no)
            start_serial_no = int(start_serial_no)
            last_serial_no = int(last_serial_no)
            
            if start_serial_no > last_serial_no:
                flash('Starting serial number must be less than or equal to last serial number', 'error')
                return render_template('new_book.html')
            
            # Check if book number already exists
            existing_book = ChequeBook.query.filter_by(book_no=book_no).first()
            if existing_book:
                flash(f'Book number {book_no} already exists. Please use a different book number.', 'error')
                return render_template('new_book.html')
            
            # Create the cheque book
            cheque_book = ChequeBook(
                book_no=book_no,
                start_serial_no=start_serial_no,
                last_serial_no=last_serial_no,
                created_by_user_id=current_user.user_id
            )
            db.session.add(cheque_book)
            db.session.flush()  # Get the book ID
            
            # Generate all serial numbers from start to last (inclusive)
            serial_numbers = []
            for serial_no in range(start_serial_no, last_serial_no + 1):
                cheque_serial = ChequeSerial(
                    book_id=cheque_book.id,
                    serial_no=serial_no,
                    status='Available'
                )
                serial_numbers.append(cheque_serial)
            
            db.session.add_all(serial_numbers)
            db.session.commit()
            
            flash(f'Book {book_no} created successfully with {len(serial_numbers)} serial numbers ({start_serial_no} to {last_serial_no})', 'success')
            return redirect(url_for('cheque_register'))
        except ValueError:
            flash('Please enter valid numbers for all fields', 'error')
            return render_template('new_book.html')
        except Exception as e:
            db.session.rollback()
            flash(f'Error creating book: {str(e)}', 'error')
            return render_template('new_book.html')
    
    return render_template('new_book.html')


@app.route('/api/request-types')
@login_required
def api_request_types():
    """API endpoint to get request types by department"""
    department = request.args.get('department', '')
    
    if department:
        # Get request types for specific department
        request_types = db.session.query(RequestType.name).filter(
            RequestType.department == department,
            RequestType.is_active == True
        ).order_by(RequestType.name).all()
        request_types = [rt[0] for rt in request_types]
    else:
        # Get all unique request types (remove duplicates)
        request_types = db.session.query(RequestType.name).filter(
            RequestType.is_active == True
        ).distinct().order_by(RequestType.name).all()
        request_types = [rt[0] for rt in request_types]
    
    return jsonify({
        'request_types': request_types
    })

@app.route('/api/person-company-options')
@login_required
def api_person_company_options():
    """API endpoint to get person/company name options by department and request type"""
    department = request.args.get('department', '')
    request_type = request.args.get('request_type', '')
    
    if department and request_type:
        # Get options for specific department and request type
        options_query = PersonCompanyOption.query.filter(
            PersonCompanyOption.department == department,
            PersonCompanyOption.request_type == request_type,
            PersonCompanyOption.is_active == True
        ).order_by(PersonCompanyOption.name).all()
        
        # Return options with account details
        options = []
        for opt in options_query:
            options.append({
                'name': opt.name,
                'account_name': opt.account_name,
                'account_number': opt.account_number,
                'bank_name': opt.bank_name,
                'description': opt.description or ''
            })
    else:
        options = []
    
    return jsonify({
        'options': options
    })


@app.route('/reports/export/excel')
@login_required
@role_required('Finance Admin', 'Finance Staff', 'GM', 'CEO', 'IT Staff', 'Department Manager', 'Operation Manager')
def export_reports_excel():
    """Export filtered reports to an Excel file with frozen columns"""
    # Lazy imports to avoid hard dependency during app startup
    import io
    try:
        import openpyxl
        from openpyxl.styles import Font, PatternFill, Alignment
        from openpyxl.utils import get_column_letter
    except ImportError:
        flash('Excel export requires openpyxl. Install with: pip install openpyxl', 'warning')
        return redirect(url_for('reports', **request.args))
    except Exception as e:
        flash(f'Error importing Excel library: {str(e)}', 'error')
        return redirect(url_for('reports', **request.args))

    # Reuse the same filters as the reports() view (support multiple values)
    department_filter = request.args.getlist('department')
    request_type_filter = request.args.getlist('request_type')
    company_filter = request.args.getlist('company')
    branch_filter = request.args.getlist('branch')
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    status_filter = request.args.getlist('status')
    payment_type_filter = request.args.getlist('payment_type')
    payment_method_filter = request.args.getlist('payment_method')

    # Show ALL statuses by default (consistent with reports() view), but exclude archived requests
    query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    
    # Filter for Department Managers based on their department (same logic as reports() view)
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            # IT Department Manager can see ALL requests from ALL departments (all statuses)
            # No filtering needed - they see everything
            pass
        elif current_user.department == 'Auditing':
            # Auditing Department Manager can see:
            # 1. ALL requests from Auditing department (all statuses)
            # 2. Completed and Recurring requests from OTHER departments
            query = query.filter(
                db.or_(
                    PaymentRequest.department == 'Auditing',
                    PaymentRequest.status.in_(['Completed', 'Recurring'])
                )
            )
        else:
            # Other Department Managers (non-IT, non-Auditing) can ONLY see their own department's requests
            query = query.filter(PaymentRequest.department == current_user.department)
    
    if status_filter:
        # Handle multiple status filters
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                status_conditions.append(PaymentRequest.status.in_(['Pending Manager Approval', 'Pending Finance Approval']))
            else:
                status_conditions.append(PaymentRequest.status == status)
        if status_conditions:
            query = query.filter(db.or_(*status_conditions))
    else:
        # If no status filter is selected (showing all statuses), exclude "Rejected by Manager"
        query = query.filter(PaymentRequest.status != 'Rejected by Manager')
    
    if department_filter:
        # Filter by multiple departments
        query = query.filter(PaymentRequest.department.in_(department_filter))
    if request_type_filter:
        # Special handling for "Others" to match both "Others" and "Others:..."
        request_type_conditions = []
        for rt in request_type_filter:
            if rt == 'Others':
                request_type_conditions.append(PaymentRequest.request_type.like('Others%'))
            else:
                request_type_conditions.append(PaymentRequest.request_type == rt)
        if request_type_conditions:
            query = query.filter(db.or_(*request_type_conditions))
    if company_filter:
        # Filter by multiple companies (person_company field only)
        company_conditions = []
        for company in company_filter:
            company_conditions.append(PaymentRequest.person_company.ilike(f'%{company}%'))
        if company_conditions:
            query = query.filter(db.or_(*company_conditions))
    if branch_filter:
        # Alias-aware branch filtering for Excel export
        # Handle multiple branch filters
        all_branch_conditions = []
        for branch_name in branch_filter:
            selected_branch = Branch.query.filter_by(name=branch_name).first()
            if selected_branch:
                alias_names = [a.alias_name for a in getattr(selected_branch, 'aliases', [])]
                names = [selected_branch.name] + alias_names
                # Build OR conditions to match if any name appears in the comma-separated branch_name
                conditions = []
                for name in names:
                    # Match exact, at start (with comma after), at end (with comma before), or in middle (with commas around)
                    conditions.append(PaymentRequest.branch_name == name)  # Exact match
                    conditions.append(PaymentRequest.branch_name.like(f'{name},%'))  # At start
                    conditions.append(PaymentRequest.branch_name.like(f'%, {name}'))  # At end (with space after comma)
                    conditions.append(PaymentRequest.branch_name.like(f'%,{name}'))  # At end (no space)
                    conditions.append(PaymentRequest.branch_name.like(f'%, {name},%'))  # In middle (with spaces)
                    conditions.append(PaymentRequest.branch_name.like(f'%,{name},%'))  # In middle (no spaces)
                all_branch_conditions.append(db.or_(*conditions))
            else:
                # For non-alias branches, check if branch name appears in comma-separated list
                conditions = [
                    PaymentRequest.branch_name == branch_name,  # Exact match
                    PaymentRequest.branch_name.like(f'{branch_name},%'),  # At start
                    PaymentRequest.branch_name.like(f'%, {branch_name}'),  # At end (with space)
                    PaymentRequest.branch_name.like(f'%,{branch_name}'),  # At end (no space)
                    PaymentRequest.branch_name.like(f'%, {branch_name},%'),  # In middle (with spaces)
                    PaymentRequest.branch_name.like(f'%,{branch_name},%')  # In middle (no spaces)
                ]
                all_branch_conditions.append(db.or_(*conditions))
        if all_branch_conditions:
            query = query.filter(db.or_(*all_branch_conditions))
    if payment_type_filter:
        # Handle multiple payment type filters
        payment_type_conditions = []
        for pt in payment_type_filter:
            if pt == 'Recurring':
                payment_type_conditions.append(PaymentRequest.recurring == 'Recurring')
            elif pt == 'Scheduled One-Time':
                payment_type_conditions.append(
                    db.and_(
                        db.or_(
                            PaymentRequest.recurring == 'Scheduled One-Time',
                            PaymentRequest.payment_date.isnot(None)
                        ),
                        PaymentRequest.recurring != 'Recurring'
                    )
                )
            elif pt == 'One-Time':
                payment_type_conditions.append(
                    db.and_(
                db.or_(
                    PaymentRequest.recurring == None,
                    PaymentRequest.recurring == '',
                    PaymentRequest.recurring == 'One-Time'
                        ),
                        PaymentRequest.payment_date.is_(None)
                )
            )
        if payment_type_conditions:
            query = query.filter(db.or_(*payment_type_conditions))
    if payment_method_filter:
        # Handle multiple payment method filters
        query = query.filter(PaymentRequest.payment_method.in_(payment_method_filter))
    # Date filtering - when a date range is provided, filter by completion_date.
    # Requests without a completion_date should NOT appear in date-scoped results.
    if date_from:
        query = query.filter(PaymentRequest.completion_date.isnot(None)).filter(
            PaymentRequest.completion_date >= datetime.strptime(date_from, '%Y-%m-%d').date()
        )
    if date_to:
        query = query.filter(PaymentRequest.completion_date.isnot(None)).filter(
            PaymentRequest.completion_date <= datetime.strptime(date_to, '%Y-%m-%d').date()
        )

    result_requests = query.order_by(PaymentRequest.date.desc()).all()

    # Helper function to convert to float
    def to_float(value):
        try:
            return float(value)
        except Exception:
            return 0.0

    # Sum all amounts (requests may be in any status)
    total_amount = sum(to_float(r.amount) for r in result_requests)

    try:
        # Create Excel workbook
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Payment Reports"

        # Add report header information
        ws['A1'] = 'Payment Reports'
        ws['A1'].font = Font(size=16, bold=True)
        
        generation_date = datetime.now().strftime('%Y-%m-%d %H:%M')
        ws['A2'] = f"Report Generated: {generation_date}"
        
        # Build comprehensive filters line (handle multiple values)
        filter_parts = []
        filter_parts.append(f"Dept: {', '.join(department_filter) if department_filter else 'All'}")
        filter_parts.append(f"Type: {', '.join(request_type_filter) if request_type_filter else 'All'}")
        filter_parts.append(f"Branch: {', '.join(branch_filter) if branch_filter else 'All'}")
        filter_parts.append(f"Company: {', '.join(company_filter) if company_filter else 'All'}")
        filter_parts.append(f"Payment Type: {', '.join(payment_type_filter) if payment_type_filter else 'All'}")
        filter_parts.append(f"Payment Method: {', '.join(payment_method_filter) if payment_method_filter else 'All'}")
        filter_parts.append(f"Status: {', '.join(status_filter) if status_filter else 'All'}")
        filters_line = " | ".join(filter_parts)
        ws['A3'] = filters_line
        
        # Date scope
        if date_from and date_to:
            ws['A4'] = f"Date Range: {date_from} to {date_to}"
        elif date_from:
            ws['A4'] = f"Date From: {date_from} (no end date)"
        elif date_to:
            ws['A4'] = f"Date To: {date_to} (no start date)"
        else:
            ws['A4'] = "Date Range: All dates (no filter applied)"
        
        ws['A5'] = f"Total Amount: OMR {total_amount:.3f}"
        ws['A5'].font = Font(size=12, bold=True)

        # Add headers starting from row 7 (removed 'Scheduled' column)
        headers = ['ID']
        # Include Ref. No. only for Auditing users
        if current_user.department == 'Auditing' or current_user.role == 'Auditing Staff':
            headers.append('Ref. No.')
        headers += ['Type', 'Requestor', 'Department', 'Payment Type', 'Payment Method', 'Amount', 'Branch', 'Company', 'Submitted', 'Approved', 'Approver', 'Manager Duration', 'Finance Duration']
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=7, column=col, value=str(header))
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")
            # Ensure header row has proper height
            ws.row_dimensions[7].height = 20

        # Helper function to format duration
        def format_duration(seconds):
            """Format duration in seconds to readable format (H:MM:SS)"""
            if not seconds:
                return ''
            
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            secs = seconds % 60
            
            return f"{hours}:{minutes:02d}:{secs:02d}"

        # Add data rows
        for row_idx, r in enumerate(result_requests, 8):
            # For Approved column: format as string (like before) to ensure immediate rendering
            approved_date_str = ''
            if getattr(r, 'approval_date', None):
                approval_val = r.approval_date
                try:
                    if isinstance(approval_val, datetime):
                        approved_date_str = approval_val.date().strftime('%Y-%m-%d')
                    elif isinstance(approval_val, date):
                        approved_date_str = approval_val.strftime('%Y-%m-%d')
                    elif isinstance(approval_val, str):
                        approved_date_str = approval_val
                    else:
                        approved_date_str = str(approval_val)
                except:
                    approved_date_str = ''
            
            # For Submitted column: format as string (like before) to ensure immediate rendering
            submitted_date_str = ''
            if getattr(r, 'date', None):
                date_val = r.date
                try:
                    if isinstance(date_val, datetime):
                        submitted_date_str = date_val.date().strftime('%Y-%m-%d')
                    elif isinstance(date_val, date):
                        submitted_date_str = date_val.strftime('%Y-%m-%d')
                    elif isinstance(date_val, str):
                        submitted_date_str = date_val
                    else:
                        submitted_date_str = str(date_val)
                except:
                    submitted_date_str = ''
            
            # For Person/Company column, show person_company field only
            company_display = r.person_company
            
            # Format duration columns
            manager_duration = format_duration(r.manager_approval_duration_minutes)
            finance_duration = format_duration(r.finance_approval_duration_minutes)
            
            scheduled_date = ''
            if r.recurring == 'Recurring':
                # Get scheduled dates for recurring payments
                scheduled_date = get_recurring_scheduled_dates(r)
            elif (not getattr(r, 'recurring', None) or getattr(r, 'recurring', None) != 'Recurring') and getattr(r, 'payment_date', None):
                try:
                    scheduled_date = r.payment_date.strftime('%Y-%m-%d')
                except Exception:
                    scheduled_date = str(r.payment_date)

            # Determine payment type display
            if r.recurring == 'Recurring':
                payment_type_display = 'Recurring'
            elif r.payment_date or r.recurring == 'Scheduled One-Time':
                payment_type_display = 'Scheduled One-Time'
            else:
                payment_type_display = r.recurring or 'One-Time'
            
            # Calculate amount value explicitly as float to ensure it's numeric
            amount_value = to_float(r.amount)
            if amount_value is None:
                amount_value = 0.0
            
            # Scheduled removed from export; build row data and include Ref. No. for Auditing users
            row_data = [f"#{r.request_id}"]
            if current_user.department == 'Auditing' or current_user.role == 'Auditing Staff':
                row_data.append(str(r.reference_number or ''))
            row_data += [
                str(r.request_type or ''),
                str(r.requestor_name or ''),
                str(r.department or ''),
                payment_type_display,
                str(r.payment_method or 'Card'),
                amount_value,  # Amount column (depends on presence of Ref. No.)
                str(r.branch_name or '').replace(',', ', '),
                str(company_display or ''),
                submitted_date_str,  # Submitted column
                approved_date_str,   # Approved column
                str(r.approver or ''),
                manager_duration,
                finance_duration
            ]
            
            for col, data in enumerate(row_data, 1):
                # For Amount column, explicitly set as float to ensure Excel treats it as number
                amount_col_index = 8 if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 7
                submitted_col_index = 11 if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 10
                approved_col_index = 12 if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 11

                if col == amount_col_index:
                    # Ensure the value is a proper float, not string or None
                    numeric_value = float(amount_value) if amount_value is not None else 0.0
                    cell = ws.cell(row=row_idx, column=col, value=numeric_value)
                    cell.number_format = '#,##0.000'
                    cell.alignment = Alignment(horizontal='right', vertical='top')
                # For Submitted date column - store as string for immediate rendering
                elif col == submitted_col_index:
                    cell = ws.cell(row=row_idx, column=col, value=str(data) if data else '')
                    cell.alignment = Alignment(horizontal='left', vertical='top')
                # For Approved date column - store as string
                elif col == approved_col_index:
                    cell = ws.cell(row=row_idx, column=col, value=str(data) if data else '')
                    cell.alignment = Alignment(horizontal='left', vertical='top')
                else:
                    cell = ws.cell(row=row_idx, column=col, value=str(data) if data is not None else '')
                    # Enable text wrapping for columns that may have long text (Branch, Company)
                    # Branch and Company indices changed when Ref. No. is present
                    branch_col = 9 if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 8
                    company_col = 10 if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 9
                    if col in [branch_col, company_col]:
                        cell.alignment = Alignment(wrap_text=True, vertical='top')
                    else:
                        cell.alignment = Alignment(vertical='top', horizontal='left')

        # Auto-adjust column widths - fix iteration to properly get column index
        for col_idx in range(1, len(headers) + 1):
            max_length = 0
            column_letter = get_column_letter(col_idx)
            
            # Check all cells in this column (including header row 7 and all data rows)
            for row in range(7, ws.max_row + 1):
                cell = ws.cell(row=row, column=col_idx)
                try:
                    cell_value = str(cell.value) if cell.value is not None else ''
                    # For wrapped text columns, estimate width needed (divide by 2 for multi-line)
                    if col_idx in [9, 10]:  # Branch Name, Company
                        # Count newlines and estimate width
                        lines = cell_value.split('\n')
                        max_line_length = max(len(line) for line in lines) if lines else 0
                        max_length = max(max_length, max_line_length)
                    else:
                        max_length = max(max_length, len(cell_value))
                except:
                    pass
            
            # Special handling for specific columns (adjusted after removing Scheduled)
            if column_letter == 'A':  # ID column - make it narrower
                adjusted_width = min(max_length + 2, 12)  # Cap ID column at 12 characters
            elif column_letter == 'D':  # Department column - make it wider
                adjusted_width = min(max_length + 2, 25)  # Cap Department column at 25 characters
            elif column_letter == 'H':  # Amount column - make it wider to accommodate "OMR #,##0.000" format
                adjusted_width = max(max_length + 2, 20)  # Minimum 20 characters, can grow if needed
            elif column_letter == 'I':  # Branch column
                adjusted_width = min(max_length + 2, 30)
            elif column_letter == 'J':  # Company column
                adjusted_width = min(max_length + 2, 30)
            elif column_letter == 'M':  # Approver column - make it wider
                adjusted_width = min(max_length + 2, 35)  # Cap Approver column at 35 characters
            elif column_letter in ['N', 'O']:  # Duration columns - make them narrower
                adjusted_width = min(max_length + 2, 15)  # Cap duration columns at 15 characters
            else:
                adjusted_width = min(max_length + 2, 50)  # Cap other columns at 50 characters
            
            # Ensure minimum width
            adjusted_width = max(adjusted_width, 10)
            ws.column_dimensions[column_letter].width = adjusted_width

        # Auto-adjust row heights for rows with wrapped text
        for row_idx in range(7, ws.max_row + 1):
            max_height = 15  # Default row height
            for col_idx in [9, 10]:  # Columns with wrapped text
                cell = ws.cell(row=row_idx, column=col_idx)
                if cell.value:
                    cell_value = str(cell.value)
                    # Count lines (including wrapped lines based on column width)
                    column_letter = get_column_letter(col_idx)
                    column_width = ws.column_dimensions[column_letter].width
                    # Estimate lines needed (rough calculation: ~7 characters per unit width)
                    chars_per_line = max(1, int(column_width * 7))
                    lines = len(cell_value.split('\n'))
                    estimated_lines = max(lines, (len(cell_value) // chars_per_line) + 1)
                    # Row height: ~15 points per line
                    row_height = max(max_height, estimated_lines * 15)
                    max_height = row_height
            
            ws.row_dimensions[row_idx].height = max_height

        # No frozen panes - all columns can be scrolled freely

        # Set workbook properties to help with date rendering
        # Remove the post-processing loop - it might be causing the delay
        # Instead, ensure dates are written correctly from the start
        
        # Ensure date columns have proper width to display dates fully
        # Adjust Submitted/Approved columns after header changes
        submitted_col_letter = 'K' if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 'J'
        approved_col_letter = 'L' if (current_user.department == 'Auditing' or current_user.role == 'Auditing Staff') else 'K'
        j_width = ws.column_dimensions.get(submitted_col_letter).width if submitted_col_letter in ws.column_dimensions else None
        k_width = ws.column_dimensions.get(approved_col_letter).width if approved_col_letter in ws.column_dimensions else None
        ws.column_dimensions[submitted_col_letter].width = max(j_width or 10, 12)
        ws.column_dimensions[approved_col_letter].width = max(k_width or 10, 12)
        
        # Set workbook to use automatic calculation (helps with rendering)
        try:
            wb.calculation.calculateOnLoad = True
        except:
            pass

        # Save to BytesIO with optimization settings
        buffer = io.BytesIO()
        # Save with write_only=False to ensure all cells are properly written
        # This helps Excel recognize dates immediately
        wb.save(buffer)
        buffer.seek(0)
        
        # Note: The lazy rendering issue is often Excel client-side behavior
        # Excel only renders visible cells initially for performance
        # When you scroll, Excel renders the newly visible cells
        # This is normal Excel behavior, not a bug in the file

        from flask import make_response
        response = make_response(buffer.getvalue())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        ts = datetime.now().strftime('%Y-%m-%d_%H-%M')
        response.headers['Content-Disposition'] = f'attachment; filename=reports_{ts}.xlsx'
        response.headers['Content-Length'] = str(len(buffer.getvalue()))
        return response
        
    except Exception as e:
        flash(f'Error generating Excel: {str(e)}', 'error')
        return redirect(url_for('reports', **request.args))


@app.route('/reports/export/pdf')
@login_required
@role_required('Finance Admin', 'Finance Staff', 'GM', 'CEO', 'IT Staff', 'Department Manager', 'Operation Manager')
def export_reports_pdf():
    """Export filtered reports to a PDF including total amount and full list"""
    # Lazy imports to avoid hard dependency during app startup
    import io
    try:
        from reportlab.lib.pagesizes import A4
        from reportlab.pdfgen import canvas
        from reportlab.lib.units import mm
        from reportlab.lib.utils import simpleSplit
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
    except ImportError:
        flash('PDF export requires reportlab. Install with: pip install reportlab', 'warning')
        return redirect(url_for('reports', **request.args))
    except Exception as e:
        flash(f'Error importing PDF library: {str(e)}', 'error')
        return redirect(url_for('reports', **request.args))

    # Optional Arabic shaping dependencies (used if available)
    try:
        import os
        import unicodedata
        import re
        import arabic_reshaper  # pip install arabic-reshaper
        from bidi.algorithm import get_display  # pip install python-bidi
    except Exception:
        arabic_reshaper = None
        get_display = None

    # Reuse the same filters as the reports() view (support multiple values)
    department_filter = request.args.getlist('department')
    request_type_filter = request.args.getlist('request_type')
    company_filter = request.args.getlist('company')
    branch_filter = request.args.getlist('branch')
    date_from = request.args.get('date_from', '')
    date_to = request.args.get('date_to', '')
    status_filter = request.args.getlist('status')
    payment_type_filter = request.args.getlist('payment_type')
    payment_method_filter = request.args.getlist('payment_method')

    # Show ALL statuses by default (consistent with reports() view), but exclude archived requests
    query = PaymentRequest.query.filter(PaymentRequest.is_archived == False)
    
    # Filter for Department Managers based on their department (same logic as reports() view)
    if current_user.role == 'Department Manager':
        if current_user.department == 'IT':
            # IT Department Manager can see ALL requests from ALL departments (all statuses)
            # No filtering needed - they see everything
            pass
        elif current_user.department == 'Auditing':
            # Auditing Department Manager can see:
            # 1. ALL requests from Auditing department (all statuses)
            # 2. Completed and Recurring requests from OTHER departments
            query = query.filter(
                db.or_(
                    PaymentRequest.department == 'Auditing',
                    PaymentRequest.status.in_(['Completed', 'Recurring'])
                )
            )
        else:
            # Other Department Managers (non-IT, non-Auditing) can ONLY see their own department's requests
            query = query.filter(PaymentRequest.department == current_user.department)
    
    if status_filter:
        # Handle multiple status filters
        status_conditions = []
        for status in status_filter:
            if status == 'All Pending':
                status_conditions.append(PaymentRequest.status.in_(['Pending Manager Approval', 'Pending Finance Approval']))
            else:
                status_conditions.append(PaymentRequest.status == status)
        if status_conditions:
            query = query.filter(db.or_(*status_conditions))
    else:
        # If no status filter is selected (showing all statuses), exclude "Rejected by Manager"
        query = query.filter(PaymentRequest.status != 'Rejected by Manager')
    
    if department_filter:
        # Filter by multiple departments
        query = query.filter(PaymentRequest.department.in_(department_filter))
    if request_type_filter:
        # Special handling for "Others" to match both "Others" and "Others:..."
        request_type_conditions = []
        for rt in request_type_filter:
            if rt == 'Others':
                request_type_conditions.append(PaymentRequest.request_type.like('Others%'))
            else:
                request_type_conditions.append(PaymentRequest.request_type == rt)
        if request_type_conditions:
            query = query.filter(db.or_(*request_type_conditions))
    if company_filter:
        # Filter by multiple companies (person_company field only)
        company_conditions = []
        for company in company_filter:
            company_conditions.append(PaymentRequest.person_company.ilike(f'%{company}%'))
        if company_conditions:
            query = query.filter(db.or_(*company_conditions))
    if branch_filter:
        # Alias-aware branch filtering for PDF export
        # Handle multiple branch filters
        all_branch_conditions = []
        for branch_name in branch_filter:
            selected_branch = Branch.query.filter_by(name=branch_name).first()
            if selected_branch:
                alias_names = [a.alias_name for a in getattr(selected_branch, 'aliases', [])]
                names = [selected_branch.name] + alias_names
                # Build OR conditions to match if any name appears in the comma-separated branch_name
                conditions = []
                for name in names:
                    # Match exact, at start (with comma after), at end (with comma before), or in middle (with commas around)
                    conditions.append(PaymentRequest.branch_name == name)  # Exact match
                    conditions.append(PaymentRequest.branch_name.like(f'{name},%'))  # At start
                    conditions.append(PaymentRequest.branch_name.like(f'%, {name}'))  # At end (with space after comma)
                    conditions.append(PaymentRequest.branch_name.like(f'%,{name}'))  # At end (no space)
                    conditions.append(PaymentRequest.branch_name.like(f'%, {name},%'))  # In middle (with spaces)
                    conditions.append(PaymentRequest.branch_name.like(f'%,{name},%'))  # In middle (no spaces)
                all_branch_conditions.append(db.or_(*conditions))
            else:
                # For non-alias branches, check if branch name appears in comma-separated list
                conditions = [
                    PaymentRequest.branch_name == branch_name,  # Exact match
                    PaymentRequest.branch_name.like(f'{branch_name},%'),  # At start
                    PaymentRequest.branch_name.like(f'%, {branch_name}'),  # At end (with space)
                    PaymentRequest.branch_name.like(f'%,{branch_name}'),  # At end (no space)
                    PaymentRequest.branch_name.like(f'%, {branch_name},%'),  # In middle (with spaces)
                    PaymentRequest.branch_name.like(f'%,{branch_name},%')  # In middle (no spaces)
                ]
                all_branch_conditions.append(db.or_(*conditions))
        if all_branch_conditions:
            query = query.filter(db.or_(*all_branch_conditions))
    
    # Payment type filter (handle multiple values)
    if payment_type_filter:
        payment_type_conditions = []
        for pt in payment_type_filter:
            if pt == 'Recurring':
                payment_type_conditions.append(PaymentRequest.recurring == 'Recurring')
            elif pt == 'Scheduled One-Time':
                payment_type_conditions.append(
                    db.and_(
                db.or_(
                    PaymentRequest.recurring == 'Scheduled One-Time',
                    PaymentRequest.payment_date.isnot(None)
                        ),
                        PaymentRequest.recurring != 'Recurring'
                    )
                )
            elif pt == 'One-Time':
                payment_type_conditions.append(
                    db.and_(
                db.or_(
                    PaymentRequest.recurring == None,
                    PaymentRequest.recurring == '',
                    PaymentRequest.recurring == 'One-Time'
                        ),
                        PaymentRequest.payment_date.is_(None)
                )
                )
        if payment_type_conditions:
            query = query.filter(db.or_(*payment_type_conditions))
    
    # Payment method filter (handle multiple values)
    if payment_method_filter:
        query = query.filter(PaymentRequest.payment_method.in_(payment_method_filter))

    # Date filtering - when a date range is provided, filter by completion_date.
    # Requests without a completion_date should NOT appear in date-scoped results.
    if date_from:
        query = query.filter(PaymentRequest.completion_date.isnot(None)).filter(
            PaymentRequest.completion_date >= datetime.strptime(date_from, '%Y-%m-%d').date()
        )
    if date_to:
        query = query.filter(PaymentRequest.completion_date.isnot(None)).filter(
            PaymentRequest.completion_date <= datetime.strptime(date_to, '%Y-%m-%d').date()
        )
    result_requests = query.order_by(PaymentRequest.date.desc()).all()

    # Helper function to convert to float
    def to_float(value):
        try:
            return float(value)
        except Exception:
            return 0.0

    # Sum all amounts (requests may be in any status)
    total_amount = sum(to_float(r.amount) for r in result_requests)

    try:
        # Build PDF in landscape orientation
        buffer = io.BytesIO()
        from reportlab.lib.pagesizes import landscape
        c = canvas.Canvas(buffer, pagesize=landscape(A4))
        width, height = landscape(A4)

        # Register and select a font that supports Arabic if available
        arabic_font_name = None
        try:
            # Candidate fonts: prefer bundled fonts, then system fonts (Windows/Linux/macOS)
            font_candidates = [
                # Project-bundled fonts
                os.path.join(app.root_path, 'static', 'fonts', 'Amiri-Regular.ttf'),
                os.path.join(app.root_path, 'static', 'fonts', 'NotoNaskhArabic-Regular.ttf'),
                os.path.join(app.root_path, 'static', 'fonts', 'NotoSansArabic-Regular.ttf'),
                os.path.join(app.root_path, 'static', 'fonts', 'Cairo-Regular.ttf'),
                os.path.join(app.root_path, 'static', 'fonts', 'Tahoma.ttf'),
                os.path.join(app.root_path, 'static', 'fonts', 'Arial.ttf'),
                # Windows common fonts
                r'C:\\Windows\\Fonts\\trado.ttf',            # Traditional Arabic
                r'C:\\Windows\\Fonts\\Tahoma.ttf',
                r'C:\\Windows\\Fonts\\arial.ttf',
                r'C:\\Windows\\Fonts\\arialuni.ttf',        # Arial Unicode MS (if present)
                r'C:\\Windows\\Fonts\\times.ttf',
                r'C:\\Windows\\Fonts\\segoeui.ttf',
                r'C:\\Windows\\Fonts\\segoeuib.ttf',
                # Linux
                '/usr/share/fonts/truetype/noto/NotoNaskhArabic-Regular.ttf',
                '/usr/share/fonts/truetype/noto/NotoSansArabic-Regular.ttf',
                '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',
                # macOS
                '/Library/Fonts/Arial Unicode.ttf',
                '/Library/Fonts/Tahoma.ttf',
                '/System/Library/Fonts/Supplemental/Times New Roman.ttf',
            ]
            for font_path in font_candidates:
                if os.path.exists(font_path):
                    try:
                        pdfmetrics.registerFont(TTFont('ArabicFont', font_path))
                        arabic_font_name = 'ArabicFont'
                        break
                    except Exception:
                        continue
        except Exception:
            # If anything goes wrong, we will fall back to built-in fonts
            arabic_font_name = None

        # Use Arabic-capable font for all body text if available
        body_font = arabic_font_name or 'Helvetica'

        # Helpers for Arabic detection and shaping
        def contains_arabic(text):
            if not text:
                return False
            for ch in str(text):
                code = ord(ch)
                if (
                    0x0600 <= code <= 0x06FF  # Arabic
                    or 0x0750 <= code <= 0x077F  # Arabic Supplement
                    or 0x08A0 <= code <= 0x08FF  # Arabic Extended-A
                    or 0xFB50 <= code <= 0xFDFF  # Arabic Presentation Forms-A
                    or 0xFE70 <= code <= 0xFEFF  # Arabic Presentation Forms-B
                ):
                    return True
            return False

        def prepare_text(value: object) -> str:
            s = '' if value is None else str(value)
            if arabic_reshaper and get_display and contains_arabic(s):
                try:
                    s = get_display(arabic_reshaper.reshape(s))
                except Exception:
                    # If shaping fails, return original text
                    pass
            return s
        
        def draw_text_rtl_aware(canvas, x, y, text, font_name, font_size, column_width):
            """Draw text with RTL alignment for Arabic text, LTR for others"""
            prepared = prepare_text(text)
            if contains_arabic(prepared):
                # Calculate text width
                try:
                    text_width = pdfmetrics.stringWidth(prepared, font_name, font_size)
                except Exception:
                    # Fallback estimate if metrics unavailable
                    text_width = len(prepared) * font_size * 0.5
                # Align from right: start position = column_start + column_width - text_width
                rtl_x = x + column_width - text_width
                canvas.drawString(rtl_x, y, prepared)
            else:
                # Regular left-to-right alignment
                canvas.drawString(x, y, prepared)

        # Margins (reduced for more space)
        left = 8 * mm
        right = width - 8 * mm
        top = height - 8 * mm
        y = top

        # Header
        c.setFont('Helvetica-Bold', 14)
        c.drawString(left, y, 'Payment Reports')
        c.setFont(body_font, 10)
        y -= 14
        
        # Report generation date
        generation_date = datetime.now().strftime('%Y-%m-%d %H:%M')
        c.drawString(left, y, prepare_text(f"Report Generated: {generation_date}"))
        y -= 12
        
        # Filters (handle multiple values)
        filters_line = f"Dept: {', '.join(department_filter) if department_filter else 'All'} | Type: {', '.join(request_type_filter) if request_type_filter else 'All'} | Branch: {', '.join(branch_filter) if branch_filter else 'All'} | Payment: {', '.join(payment_type_filter) if payment_type_filter else 'All'}"
        c.drawString(left, y, prepare_text(filters_line))
        y -= 12
        
        # Date scope
        if date_from and date_to:
            c.drawString(left, y, prepare_text(f"Date Range: {date_from} to {date_to}"))
        elif date_from:
            c.drawString(left, y, prepare_text(f"Date From: {date_from} (no end date)"))
        elif date_to:
            c.drawString(left, y, prepare_text(f"Date To: {date_to} (no start date)"))
        else:
            c.drawString(left, y, prepare_text("Date Range: All dates (no filter applied)"))
        y -= 12

        # Total amount
        c.setFont('Helvetica-Bold', 11)
        c.drawString(left, y, f"Total Amount: OMR {total_amount:.3f}")
        y -= 18

        # Helper function to wrap text manually
        def wrap_text(text, max_width, font_name=body_font, font_size=9):
            """Wrap text to fit within specified width using actual font metrics.
            First splits by newlines, then wraps each line if needed."""
            s = '' if text is None else str(text)
            s = prepare_text(s)
            if not s:
                return ['']

            def string_width(t: str) -> float:
                try:
                    return pdfmetrics.stringWidth(t, font_name, font_size)
                except Exception:
                    # Fallback estimate if metrics are unavailable
                    return len(t) * font_size * 0.5

            # Use a slightly smaller width to keep text away from column border
            effective_width = max(0, max_width - (1.5 * mm))
            
            # First, split by newlines to preserve intentional line breaks
            newline_split = s.split('\n')
            all_lines = []
            
            for line in newline_split:
                if not line.strip():
                    all_lines.append('')
                    continue
                
                # Wrap this line if it's too long
                words = line.split()
                wrapped_lines = []
                current = ''

                for word in words:
                    candidate = (current + ' ' + word).strip()
                    if current and string_width(candidate) > effective_width:
                        wrapped_lines.append(current)
                        current = word
                    else:
                        current = candidate

                if current:
                    wrapped_lines.append(current)

                # Hard-break extremely long tokens that exceed width
                for wrapped_line in wrapped_lines:
                    if string_width(wrapped_line) <= effective_width:
                        all_lines.append(wrapped_line)
                    else:
                        # Break by characters
                        buf = ''
                        for ch in wrapped_line:
                            if string_width(buf + ch) > effective_width and buf:
                                all_lines.append(buf)
                                buf = ch
                            else:
                                buf += ch
                        if buf:
                            all_lines.append(buf)
            
            return all_lines or ['']
        
        # Table header
        c.setFont(body_font if arabic_font_name else 'Helvetica-Bold', 9)
        # Removed 'Scheduled' column from PDF export (frontend-only removal mirrored in generated report)
        headers = ['ID']
        col_widths = [14*mm]
        # Include Ref. No. only for Auditing users
        if current_user.department == 'Auditing' or current_user.role == 'Auditing Staff':
            headers.append('Ref. No.')
            col_widths.append(14*mm)
        headers += ['Type', 'Requestor', 'Department', 'Payment', 'Amount', 'Branch', 'Company', 'Approver']
        # Column widths optimized for landscape A4 with proper spacing (matching new headers)
        col_widths += [30*mm, 22*mm, 18*mm, 16*mm, 18*mm, 30*mm, 30*mm, 28*mm]
        # Calculate column positions based on widths to prevent overlapping
        column_gap = 4 * mm  # slightly larger inter-column gap
        col_x = [left]
        for i in range(1, len(col_widths)):
            col_x.append(col_x[i-1] + col_widths[i-1] + column_gap)
        for i, (hx, text) in enumerate(zip(col_x, headers)):
            draw_text_rtl_aware(c, hx, y, text, body_font if arabic_font_name else 'Helvetica-Bold', 9, col_widths[i])
        y -= 10
        c.line(left, y, right, y)
        y -= 8

        # Rows
        c.setFont(body_font, 9)
        row_height = 10
        bottom_margin = 15 * mm
        for r in result_requests:
            # Calculate the maximum height needed for this row across all columns first
            max_height = 0
            wrapped_lines_per_col = []
            
            # For Person/Company column, show person_company field only
            company_display = r.person_company

            # Scheduled date removed from exported PDF (useful only in frontend view)
            row_data = [f"#{r.request_id}"]
            if current_user.department == 'Auditing' or current_user.role == 'Auditing Staff':
                row_data.append(str(r.reference_number or ''))
            row_data += [
                str(r.request_type or ''),
                str(r.requestor_name or ''),
                str(r.department or ''),
                str(r.recurring or 'One-Time'),
                f"OMR {to_float(r.amount):.3f}",
                str(r.branch_name or '').replace(',', ', '),
                str(company_display or ''),
                str(r.approver or '')
            ]
            
            # Pre-wrap and measure to know if the row fits in the remaining space
            for i, (data, width) in enumerate(zip(row_data, col_widths)):
                if data:
                    lines = wrap_text(str(data), width, body_font, 9)
                else:
                    lines = ['']
                wrapped_lines_per_col.append(lines)
                max_height = max(max_height, len(lines) * 10)

            # If the row will overflow the page, create a new page and redraw the header
            if y - max_height < bottom_margin:
                c.showPage()
                y = top
                c.setFont(body_font if arabic_font_name else 'Helvetica-Bold', 9)
                for i, (hx, text) in enumerate(zip(col_x, headers)):
                    draw_text_rtl_aware(c, hx, y, text, body_font if arabic_font_name else 'Helvetica-Bold', 9, col_widths[i])
                y -= 10
                c.line(left, y, right, y)
                y -= 8
                c.setFont(body_font, 9)

            # Draw each column with the precomputed wrapping
            for i, lines in enumerate(wrapped_lines_per_col):
                for j, line in enumerate(lines):
                    draw_text_rtl_aware(c, col_x[i], y - (j * 10), line, body_font, 9, col_widths[i])
            
            y -= max_height + 3  # Reduced spacing between rows for more content

        c.showPage()
        c.save()
        pdf_value = buffer.getvalue()
        buffer.close()

        from flask import make_response
        response = make_response(pdf_value)
        response.headers['Content-Type'] = 'application/pdf'
        ts = datetime.now().strftime('%Y-%m-%d_%H-%M')
        response.headers['Content-Disposition'] = f'attachment; filename=reports_{ts}.pdf'
        response.headers['Content-Length'] = str(len(pdf_value))
        return response
        
    except Exception as e:
        flash(f'Error generating PDF: {str(e)}', 'error')
        return redirect(url_for('reports', **request.args))


# ==================== USER MANAGEMENT ROUTES (IT ONLY) ====================

@app.route('/users')
@login_required
@role_required('IT Staff', 'Department Manager')
def manage_users():
    """Manage users (IT only)"""
    # Only IT or IT Department Manager
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    users = User.query.all()
    return render_template('manage_users.html', users=users, user=current_user)


# ----------------- User permissions API -----------------
@app.route('/api/users/<int:user_id>/permissions', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def api_user_permissions(user_id):
    """Get or set per-user permissions, overrides and status scopes"""
    import json
    user = User.query.get_or_404(user_id)
    if request.method == 'GET':
        up = UserPermission.query.filter_by(user_id=user_id).first()
        if not up:
            return jsonify({'permissions': {}, 'overrides': {}, 'status_scopes': {}})
        return jsonify(up.to_dict())

    data = request.get_json(force=True, silent=True) or {}
    permissions = data.get('permissions') or {}
    overrides = data.get('overrides') or {}
    status_scopes = data.get('status_scopes') or {}

    up = UserPermission.query.filter_by(user_id=user_id).first()
    if not up:
        up = UserPermission(user_id=user_id)
        db.session.add(up)

    try:
        up.permissions = json.dumps(permissions)
        up.overrides = json.dumps(overrides)
        up.status_scopes = json.dumps(status_scopes)
        db.session.commit()
        log_action(f"Updated permissions for user {user.username} (id={user.user_id})")
        return jsonify({'success': True})
    except Exception as e:
        app.logger.exception("Failed to save user permissions")
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/users/apply_permissions', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def api_apply_permissions():
    """Copy permissions from a source user to a list of target users"""
    import json
    data = request.get_json(force=True, silent=True) or {}
    source_id = data.get('source_user_id') or data.get('sourceId') or data.get('source')
    targets = data.get('target_user_ids') or data.get('targetUserIds') or data.get('targets') or []
    if not source_id or not isinstance(targets, list) or len(targets) == 0:
        return jsonify({'success': False, 'error': 'Invalid payload'}), 400

    src = UserPermission.query.filter_by(user_id=source_id).first()
    if not src:
        return jsonify({'success': False, 'error': 'Source has no custom permissions'}), 404

    try:
        for tid in targets:
            if int(tid) == int(source_id):
                continue
            up = UserPermission.query.filter_by(user_id=tid).first()
            if not up:
                up = UserPermission(user_id=tid)
                db.session.add(up)
            up.permissions = src.permissions
            up.overrides = src.overrides
            up.status_scopes = src.status_scopes
        db.session.commit()
        log_action(f"Applied permissions from user {source_id} to {len(targets)} users by {current_user.username}")
        return jsonify({'success': True, 'applied_to': len(targets)})
    except Exception as e:
        app.logger.exception("Failed to apply permissions")
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/users/new', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def new_user():
    """Create a new user - IT ONLY"""
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    if request.method == 'POST':
        name = request.form.get('name')
        username = request.form.get('username')  # This is now the email
        password = request.form.get('password')
        department = request.form.get('department')
        role = request.form.get('role')
        manager_id = request.form.get('manager_id')
        
        # Check if username (email) already exists
        existing_user = User.query.filter_by(username=username).first()
        if existing_user:
            flash('Email address already exists.', 'danger')
            return redirect(url_for('new_user'))
        
        # Department restriction removed - multiple accounts per department allowed
        
        # Determine manager assignment
        # If the new user IS a Department Manager, they are managed by the General Manager
        if role == 'Department Manager':
            gm_user = User.query.filter_by(role='GM').first()
            final_manager_id = gm_user.user_id if gm_user else None
        # If the new user IS a General Manager or CEO, they are managed by Abdalaziz (Finance Admin)
        elif role in ['GM', 'CEO']:
            abdalaziz_user = User.query.filter_by(name='Abdalaziz Al-Brashdi', department='Finance').first()
            final_manager_id = abdalaziz_user.user_id if abdalaziz_user else None
        else:
            # First preference: explicit manager selection from form
            if manager_id:
                final_manager_id = manager_id
            else:
                # Fallback: find the department's manager user
                dept_manager = User.query.filter_by(department=department, role='Department Manager').first()
                if dept_manager:
                    final_manager_id = dept_manager.user_id
                else:
                    # Special rules: Office ‚Üí GM, Operation ‚Üí Operation Manager, Project ‚Üí Operation Manager, Finance ‚Üí specific named manager
                    if department == 'Office':
                        gm_user = User.query.filter_by(role='GM').first()
                        final_manager_id = gm_user.user_id if gm_user else None
                    elif department == 'Operation':
                        op_manager = User.query.filter_by(role='Operation Manager').first()
                        final_manager_id = op_manager.user_id if op_manager else None
                    elif department == 'Project':
                        op_manager = User.query.filter_by(role='Operation Manager').first()
                        final_manager_id = op_manager.user_id if op_manager else None
                    elif department == 'Finance':
                        named_manager = User.query.filter_by(name='Abdalaziz Al-Brashdi', department='Finance').first()
                        final_manager_id = named_manager.user_id if named_manager else None
                    else:
                        # No fallback: manager assignment depends solely on users with 'Department Manager' role
                        final_manager_id = None
        
        new_user = User(
            name=name,
            username=username,  # Store email as username
            department=department,
            role=role,
            manager_id=final_manager_id,
            email=username  # Store email in both username and email fields
        )
        new_user.set_password(password)
        
        db.session.add(new_user)
        db.session.commit()
        
        log_action(f"Created new user: {username} ({role}) for department: {department}")
        
        # Notify IT Staff about user creation
        notify_users_by_role(
            request=None,  # No request for user management notifications
            notification_type="user_created",
            title="New User Created",
            message=f"New user {username} ({role}) has been created for {department} department by {current_user.name}",
            request_id=None
        )
        
        flash(f'User {username} created successfully for {department} department!', 'success')
        return redirect(url_for('manage_users'))
    
    # Get all users for manager selection
    all_users = User.query.all()
    return render_template('new_user.html', user=current_user, all_users=all_users)


@app.route('/users/<int:user_id>/edit', methods=['GET', 'POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def edit_user(user_id):
    """Edit user information - IT ONLY"""
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    user_to_edit = User.query.get_or_404(user_id)
    
    if request.method == 'POST':
        new_name = request.form.get('name')
        new_username = request.form.get('username')  # This is the email
        new_password = request.form.get('password')
        new_department = request.form.get('department')
        new_role = request.form.get('role')
        new_manager_id = request.form.get('manager_id')
        
        # Check if email (username) is being changed and if it already exists
        if new_username != user_to_edit.username:
            existing_user = User.query.filter_by(username=new_username).first()
            if existing_user:
                flash('Email address already exists. Please choose a different email.', 'danger')
                return redirect(url_for('edit_user', user_id=user_id))
        
        # Department restriction removed - multiple accounts per department allowed
        
        # Determine manager assignment on edit
        if new_role == 'Department Manager':
            gm_user = User.query.filter_by(role='GM').first()
            final_manager_id = gm_user.user_id if gm_user else None
        elif new_role in ['GM', 'CEO']:
            abdalaziz_user = User.query.filter_by(name='Abdalaziz Al-Brashdi', department='Finance').first()
            final_manager_id = abdalaziz_user.user_id if abdalaziz_user else None
        else:
            if new_manager_id:
                final_manager_id = new_manager_id
            else:
                dept_manager = User.query.filter_by(department=new_department, role='Department Manager').first()
                if dept_manager:
                    final_manager_id = dept_manager.user_id
                else:
                    # Special rules: Office ‚Üí GM, Operation ‚Üí Operation Manager, Project ‚Üí Operation Manager, Finance ‚Üí specific named manager
                    if new_department == 'Office':
                        gm_user = User.query.filter_by(role='GM').first()
                        final_manager_id = gm_user.user_id if gm_user else None
                    elif new_department == 'Operation':
                        op_manager = User.query.filter_by(role='Operation Manager').first()
                        final_manager_id = op_manager.user_id if op_manager else None
                    elif new_department == 'Project':
                        op_manager = User.query.filter_by(role='Operation Manager').first()
                        final_manager_id = op_manager.user_id if op_manager else None
                    elif new_department == 'Finance':
                        named_manager = User.query.filter_by(name='Abdalaziz Al-Brashdi', department='Finance').first()
                        final_manager_id = named_manager.user_id if named_manager else None
                    else:
                        # No fallback: manager assignment depends solely on users with 'Department Manager' role
                        final_manager_id = None
        
        # Update user information
        user_to_edit.name = new_name
        user_to_edit.username = new_username  # Update email/username
        user_to_edit.email = new_username     # Update email field as well
        user_to_edit.department = new_department
        user_to_edit.role = new_role
        user_to_edit.manager_id = final_manager_id
        
        # Only update password if provided
        if new_password:
            user_to_edit.set_password(new_password)
        
        db.session.commit()
        
        log_action(f"Updated user: {user_to_edit.username} ({new_role}) - Department: {new_department}")
        
        # Notify IT Staff about user update
        notify_users_by_role(
            request=None,  # No request for user management notifications
            notification_type="user_updated",
            title="User Updated",
            message=f"User {user_to_edit.username} has been updated to {new_role} in {new_department} department by {current_user.name}",
            request_id=None
        )
        
        flash(f'User {user_to_edit.username} has been updated successfully!', 'success')
        return redirect(url_for('manage_users'))
    
    # Get all users for manager selection (excluding the user being edited)
    all_users = User.query.filter(User.user_id != user_id).all()
    return render_template('edit_user.html', user=current_user, user_to_edit=user_to_edit, all_users=all_users)


@app.route('/users/<int:user_id>/unlock', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def unlock_user(user_id):
    """Unlock a locked user account - IT ONLY"""
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    user_to_unlock = User.query.get_or_404(user_id)
    
    if not user_to_unlock.is_account_locked():
        flash(f'Account {user_to_unlock.username} is not locked.', 'info')
        return redirect(url_for('manage_users'))
    
    user_to_unlock.unlock_account()
    log_action(f"IT Staff {current_user.username} unlocked account: {user_to_unlock.username}")
    
    # Create notification for the user
    create_notification(
        user_id=user_to_unlock.user_id,
        title="Account Unlocked",
        message=f"Your account has been unlocked by IT Staff. You can now log in again.",
        notification_type='account_unlocked',
        request_id=None
    )
    
    flash(f'Account {user_to_unlock.username} has been unlocked successfully!', 'success')
    return redirect(url_for('manage_users'))


@app.route('/users/<int:user_id>/reset_password', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def reset_user_password(user_id):
    """Reset user password and unlock account - IT ONLY"""
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    
    user_to_reset = User.query.get_or_404(user_id)
    new_password = request.form.get('new_password')
    
    if not new_password or len(new_password) < 6:
        flash('Password must be at least 6 characters long.', 'danger')
        return redirect(url_for('manage_users'))
    
    # Reset password
    user_to_reset.set_password(new_password)
    
    # Unlock account if locked
    if user_to_reset.is_account_locked():
        user_to_reset.unlock_account()
    
    db.session.commit()
    log_action(f"IT Staff {current_user.username} reset password for: {user_to_reset.username}")
    
    # Create notification for the user
    create_notification(
        user_id=user_to_reset.user_id,
        title="Password Reset",
        message=f"Your password has been reset by IT Staff. Please log in with your new password and change it immediately.",
        notification_type='password_reset',
        request_id=None
    )
    
    flash(f'Password for {user_to_reset.username} has been reset successfully! The account has been unlocked.', 'success')
    return redirect(url_for('manage_users'))


@app.route('/users/<int:user_id>/delete', methods=['POST'])
@login_required
@role_required('IT Staff', 'Department Manager')
def delete_user(user_id):
    """Delete a user and handle related data"""
    if current_user.role == 'Department Manager' and current_user.department != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    user_to_delete = User.query.get_or_404(user_id)
    
    # Don't allow deleting yourself
    if user_to_delete.user_id == current_user.user_id:
        flash('You cannot delete your own account.', 'danger')
        return redirect(url_for('manage_users'))
    
    username = user_to_delete.username
    
    # Handle payment requests created by this user
    payment_requests = PaymentRequest.query.filter_by(user_id=user_id).all()
    if payment_requests:
        # Delete all payment requests by this user
        for req in payment_requests:
            # Delete associated receipt files if they exist (both requestor and finance admin receipts)
            import json
            if req.requestor_receipt_path:
                try:
                    requestor_receipts = json.loads(req.requestor_receipt_path)
                    for receipt_file in requestor_receipts:
                        filepath = os.path.join(app.config['UPLOAD_FOLDER'], receipt_file)
                        if os.path.exists(filepath):
                            os.remove(filepath)
                except (json.JSONDecodeError, TypeError):
                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], req.requestor_receipt_path)
                    if os.path.exists(filepath):
                        os.remove(filepath)
            
            if req.finance_admin_receipt_path:
                try:
                    finance_receipts = json.loads(req.finance_admin_receipt_path)
                    for receipt_file in finance_receipts:
                        filepath = os.path.join(app.config['UPLOAD_FOLDER'], receipt_file)
                        if os.path.exists(filepath):
                            os.remove(filepath)
                except (json.JSONDecodeError, TypeError):
                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], req.finance_admin_receipt_path)
                    if os.path.exists(filepath):
                        os.remove(filepath)
            
            # Also check legacy receipt_path for backwards compatibility
            if req.receipt_path:
                try:
                    legacy_receipts = json.loads(req.receipt_path)
                    for receipt_file in legacy_receipts:
                        filepath = os.path.join(app.config['UPLOAD_FOLDER'], receipt_file)
                        if os.path.exists(filepath):
                            os.remove(filepath)
                except (json.JSONDecodeError, TypeError):
                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], req.receipt_path)
                    if os.path.exists(filepath):
                        os.remove(filepath)
            if req.proof_of_payment:
                proof_file = os.path.join(app.config['UPLOAD_FOLDER'], req.proof_of_payment)
                if os.path.exists(proof_file):
                    os.remove(proof_file)
            
            # Delete related records first
            InstallmentEditHistory.query.filter_by(request_id=req.request_id).delete()
            RecurringPaymentSchedule.query.filter_by(request_id=req.request_id).delete()
            LateInstallment.query.filter_by(request_id=req.request_id).delete()
            PaidNotification.query.filter_by(request_id=req.request_id).delete()
            Notification.query.filter_by(request_id=req.request_id).delete()
            FinanceAdminNote.query.filter_by(request_id=req.request_id).delete()
            
            db.session.delete(req)
    
    # Update audit logs to preserve history (user_id will be NULL, but username_snapshot kept)
    # No need to explicitly update - the nullable foreign key will handle this
    
    # Delete the user
    db.session.delete(user_to_delete)
    db.session.commit()
    
    log_action(f"Deleted user: {username} (and {len(payment_requests)} associated requests)")
    flash(f'User {username} has been deleted successfully.', 'success')
    return redirect(url_for('manage_users'))


# ==================== DEBUG ROUTES ====================

@app.route('/debug/requests')
@login_required
@role_required('Finance Admin', 'IT Staff', 'Department Manager')
def debug_requests():
    """Debug route to see all requests in the database"""
    all_requests = PaymentRequest.query.order_by(PaymentRequest.created_at.desc()).limit(20).all()
    debug_data = []
    for req in all_requests:
        debug_data.append({
            'request_id': req.request_id,
            'requestor_name': req.requestor_name,
            'department': req.department,
            'status': req.status,
            'user_id': req.user_id,
            'created_at': req.created_at.strftime('%Y-%m-%d %H:%M:%S'),
            'amount': float(req.amount)
        })
    return jsonify(debug_data)

# ==================== NOTIFICATION ROUTES ====================

@app.route('/notifications')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def notifications():
    """View all notifications based on RBAC permissions with pagination"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 25, type=int)
    
    # Validate per_page to prevent abuse
    if per_page not in [10, 25, 50, 100]:
        per_page = 25
    
    pagination = get_notifications_for_user(current_user, page=page, per_page=per_page)
    return render_template('notifications.html', pagination=pagination, notifications=pagination.items, user=current_user)


@app.route('/notifications/mark_read/<int:notification_id>')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def mark_notification_read(notification_id):
    """Mark a notification as read"""
    notification = Notification.query.filter_by(notification_id=notification_id, user_id=current_user.user_id).first()
    if notification:
        notification.is_read = True
        db.session.commit()
        return jsonify({'success': True})
    return jsonify({'success': False}), 404


@app.route('/notifications/mark_all_read')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def mark_all_notifications_read():
    """Mark all notifications as read for current user"""
    Notification.query.filter_by(user_id=current_user.user_id, is_read=False).update({'is_read': True})
    db.session.commit()
    return jsonify({'success': True})

@app.route('/notifications/mark_paid/<int:notification_id>')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def mark_notification_paid(notification_id):
    """Mark a recurring payment notification as paid and delete it"""
    notification = Notification.query.filter_by(
        notification_id=notification_id, 
        user_id=current_user.user_id
    ).first()
    
    if not notification:
        return jsonify({'success': False, 'message': 'Notification not found'}), 404
    
    # Only allow marking recurring due notifications as paid
    if notification.notification_type != 'recurring_due':
        return jsonify({'success': False, 'message': 'This notification cannot be marked as paid'}), 400
    
    # Record that this payment was marked as paid today
    paid_notification = PaidNotification(
        request_id=notification.request_id,
        user_id=current_user.user_id,
        paid_date=date.today()
    )
    db.session.add(paid_notification)
    
    # Delete the notification
    db.session.delete(notification)
    db.session.commit()
    
    return jsonify({'success': True, 'message': 'Payment marked as paid. Notification will reappear on the next due date.'})


@app.route('/notifications/delete/<int:notification_id>')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def delete_notification(notification_id):
    """Delete a specific notification"""
    notification = Notification.query.filter_by(notification_id=notification_id, user_id=current_user.user_id).first()
    if notification:
        db.session.delete(notification)
        db.session.commit()
        return jsonify({'success': True})
    return jsonify({'success': False, 'error': 'Notification not found'}), 404

@app.route('/notifications/delete_all')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def delete_all_notifications():
    """Delete all notifications for current user"""
    try:
        deleted_count = Notification.query.filter_by(user_id=current_user.user_id).delete()
        db.session.commit()
        return jsonify({'success': True, 'deleted_count': deleted_count})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/notifications/unread_count')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def unread_notifications_count():
    """Get count of unread notifications based on RBAC"""
    count = get_unread_count_for_user(current_user)
    return jsonify({'count': count})


@app.route('/api/calendar/pending_count')
@login_required
@role_required('Admin', 'Project Staff', 'Finance Admin', 'Finance Staff', 'GM', 'CEO', 'Operation Manager', 'IT Staff', 'IT Department Manager')
def calendar_pending_count():
    """Get count of pending (unpaid) payment requests scheduled for TODAY only"""
    try:
        from datetime import date, timedelta
        today = date.today()
        pending_count = 0
        
        # Count recurring payment requests with unpaid installments scheduled for TODAY
        recurring_query = PaymentRequest.query.filter(
            PaymentRequest.recurring == 'Recurring',
            PaymentRequest.recurring_interval.isnot(None),
            PaymentRequest.recurring_interval != '',
            PaymentRequest.status.in_([
                'Pending Finance Approval',
                'Proof Pending',
                'Proof Sent',
                'Proof Rejected',
                'Completed',
                'Recurring'
            ]),
            PaymentRequest.is_archived == False
        )
        
        # Project users can only see their department's requests
        if current_user.role == 'Project Staff':
            recurring_query = recurring_query.filter(PaymentRequest.department == current_user.department)
        
        recurring_requests = recurring_query.all()
        
        for req in recurring_requests:
            schedules = RecurringPaymentSchedule.query.filter_by(request_id=req.request_id).all()
            
            if schedules:
                # For variable payments, check each installment
                for installment in schedules:
                    # Only count unpaid installments scheduled for TODAY
                    if not installment.is_paid and installment.payment_date == today:
                        pending_count += 1
            else:
                # For regular recurring payments, generate due dates and check if today is included
                end_date = today + timedelta(days=1)  # Only check up to today
                due_dates = generate_future_due_dates(req, today, end_date)
                
                for due_date, amount in due_dates:
                    # Only count if the due date is TODAY
                    if due_date == today:
                        # Check if this payment is already marked as paid
                        paid_notification = PaidNotification.query.filter_by(
                            request_id=req.request_id,
                            paid_date=due_date
                        ).first()
                        
                        # Only count unpaid payments
                        if not paid_notification:
                            pending_count += 1
        
        # Count one-time scheduled payments that are unpaid and scheduled for TODAY
        one_time_query = PaymentRequest.query.filter(
            ((PaymentRequest.recurring.is_(None)) | (PaymentRequest.recurring != 'Recurring')),
            PaymentRequest.payment_date.isnot(None),
            PaymentRequest.payment_date == today,  # Only TODAY
            PaymentRequest.status.in_([
                'Pending Finance Approval',
                'Proof Pending',
                'Proof Sent',
                'Proof Rejected',
                'Completed',
                'Recurring'
            ]),
            PaymentRequest.is_archived == False
        )
        
        # Project Staff can only see their department's one-time requests
        if current_user.role == 'Project Staff':
            one_time_query = one_time_query.filter(PaymentRequest.department == current_user.department)
        
        one_time_requests = one_time_query.all()
        
        # Check authorization for one-time requests (same logic as calendar events)
        def is_authorized_for_one_time(req, user):
            if req.user_id == user.user_id:
                return True
            if getattr(req, 'temporary_manager_id', None) == user.user_id:
                return True
            if user.role in ['GM', 'Operation Manager']:
                return True
            if user.department == 'IT' and user.role in ['IT Staff', 'Department Manager']:
                return True
            if getattr(req.user, 'manager_id', None) == user.user_id:
                return True
            if user.role == 'Department Manager' and user.department == req.department:
                return True
            # Finance Admin and Finance Staff can see all one-time scheduled payments when status is "Pending Finance Approval"
            if user.role in ['Finance Admin', 'Finance Staff']:
                if req.status == 'Pending Finance Approval':
                    return True  # Finance users can see all pending finance approval requests
            return False
        
        for req in one_time_requests:
            if not is_authorized_for_one_time(req, current_user):
                continue
            
            # Check if request is completed or has paid notification
            is_completed = req.status == 'Completed'
            paid_notification = PaidNotification.query.filter_by(
                request_id=req.request_id,
                paid_date=req.payment_date
            ).first()
            
            # Only count unpaid requests
            if not is_completed and not paid_notification:
                pending_count += 1
        
        return jsonify({'count': pending_count})
        
    except Exception as e:
        print(f"Error getting calendar pending count: {e}")
        return jsonify({'count': 0})


@app.route('/api/overdue-requests/count')
@login_required
@role_required('Finance Admin', 'Finance Staff')
def overdue_requests_count():
    """API endpoint to get overdue requests count"""
    count = get_overdue_requests_count()
    return jsonify({'count': count})


@app.route('/api/notifications/recent')
@login_required
@role_required('Finance Admin', 'Admin', 'Finance Staff', 'Project Staff', 'Operation Manager', 'IT Staff', 'Department Manager', 'GM', 'CEO', 'Operation Staff', 'Branch Inventory Officer', 'HR Staff', 'PR Staff', 'Auditing Staff', 'Customer Service Staff', 'Marketing Staff', 'Quality Control Staff', 'Research and Development Staff', 'Office Staff', 'Maintenance Staff', 'Procurement Staff', 'Logistic Staff')
def recent_notifications():
    """Get recent notifications for the user based on RBAC"""
    notifications = get_notifications_for_user(current_user)
    return jsonify([n.to_dict() for n in notifications])

@app.route('/debug/notifications')
@login_required
@role_required('Admin')
def debug_notifications():
    """Debug route to check all notifications in database"""
    all_notifications = Notification.query.order_by(Notification.created_at.desc()).limit(10).all()
    debug_data = []
    for notif in all_notifications:
        user = User.query.get(notif.user_id)
        debug_data.append({
            'notification_id': notif.notification_id,
            'user_id': notif.user_id,
            'username': user.username if user else 'Unknown',
            'user_role': user.role if user else 'Unknown',
            'title': notif.title,
            'message': notif.message,
            'notification_type': notif.notification_type,
            'is_read': notif.is_read,
            'created_at': notif.created_at.strftime('%Y-%m-%d %H:%M:%S')
        })
    return jsonify(debug_data)

@app.route('/debug/my-notifications')
@login_required
def debug_my_notifications():
    """Debug route to check current user's notifications"""
    all_user_notifications = Notification.query.filter_by(user_id=current_user.user_id).order_by(Notification.created_at.desc()).all()
    debug_data = []
    for notif in all_user_notifications:
        debug_data.append({
            'notification_id': notif.notification_id,
            'title': notif.title,
            'message': notif.message,
            'notification_type': notif.notification_type,
            'is_read': notif.is_read,
            'created_at': notif.created_at.strftime('%Y-%m-%d %H:%M:%S')
        })
    return jsonify({
        'user_id': current_user.user_id,
        'username': current_user.username,
        'role': current_user.role,
        'department': current_user.department,
        'total_notifications': len(all_user_notifications),
        'notifications': debug_data
    })

@app.route('/debug/test-notification')
@login_required
@role_required('Admin')
def debug_test_notification():
    """Test route to create a notification for current user"""
    try:
        test_notification = create_notification(
            user_id=current_user.user_id,
            title="Test Notification",
            message="This is a test notification to verify the system is working",
            notification_type="test",
            request_id=None
        )
        return jsonify({
            'success': True,
            'message': 'Test notification created successfully',
            'notification_id': test_notification.notification_id
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


# Real-time dashboard API endpoints
@app.route('/api/dashboard/finance')
@login_required
@role_required('Finance Admin', 'Finance Staff')
def api_finance_dashboard():
    """API endpoint for finance dashboard data"""
    try:
        # Get the same data as the finance dashboard
        requests = PaymentRequest.query.order_by(PaymentRequest.created_at.desc()).all()
        
        # Render the dashboard template and return HTML
        from flask import render_template
        html = render_template('finance_dashboard.html', 
                              user=current_user, 
                              requests=requests,
                              status_filter=None,
                              department_filter=None,
                              search_query=None,
                              urgent_filter=None,
                              pagination=None)
        return html
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/dashboard/admin')
@login_required
@role_required('Admin')
def api_admin_dashboard():
    """API endpoint for admin dashboard data"""
    try:
        requests = PaymentRequest.query.order_by(PaymentRequest.created_at.desc()).all()
        
        from flask import render_template
        html = render_template('admin_dashboard.html', 
                              user=current_user, 
                              requests=requests,
                              status_filter=None,
                              department_filter=None,
                              search_query=None,
                              urgent_filter=None,
                              pagination=None)
        return html
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/dashboard/it')
@login_required
@role_required('IT Staff')
def api_it_dashboard():
    """API endpoint for IT dashboard data"""
    try:
        requests = PaymentRequest.query.order_by(PaymentRequest.created_at.desc()).all()
        
        from flask import render_template
        html = render_template('it_dashboard.html', 
                              user=current_user, 
                              requests=requests,
                              status_filter=None,
                              department_filter=None,
                              search_query=None,
                              urgent_filter=None,
                              pagination=None)
        return html
    except Exception as e:
        return jsonify({'error': str(e)}), 500






# ==================== FILE UPLOAD ROUTES ====================

@app.route('/uploads/receipts/<filename>')
@login_required
def uploaded_file(filename):
    """Serve uploaded receipt files"""
    # First try the configured UPLOAD_FOLDER (receipts)
    try:
        receipts_dir = app.config.get('UPLOAD_FOLDER') or os.path.join(app.root_path, 'uploads', 'receipts')
        candidate_path = os.path.join(receipts_dir, filename)
        if os.path.exists(candidate_path):
            return send_from_directory(receipts_dir, filename)
    except Exception:
        # ignore and try fallback
        pass

    # Fallback: check item_request_files directory where some uploads may be stored
    try:
        item_files_dir = os.path.join(app.root_path, 'uploads', 'item_request_files')
        candidate_path = os.path.join(item_files_dir, filename)
        if os.path.exists(candidate_path):
            return send_from_directory(item_files_dir, filename)
    except Exception:
        pass

    # Not found
    abort(404)


@app.route('/debug/whoami')
@login_required
def debug_whoami():
    """Temporary debug endpoint to inspect the currently authenticated user and session."""
    try:
        info = {
            'user_id': getattr(current_user, 'user_id', None),
            'username': getattr(current_user, 'username', None),
            'name': getattr(current_user, 'name', None),
            'role': getattr(current_user, 'role', None),
            'department': getattr(current_user, 'department', None),
            'session_keys': {k: (str(v)[:200] + '...' if isinstance(v, str) and len(v) > 200 else v) for k, v in dict(session).items()}
        }
        return jsonify({'success': True, 'whoami': info})
    except Exception as e:
        app.logger.error(f"Error in debug/whoami: {e}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/uploads/cheque/<filename>')
@login_required
def uploaded_cheque_file(filename):
    """Serve uploaded cheque files"""
    return send_from_directory(app.config['CHEQUE_UPLOAD_FOLDER'], filename)


@app.route('/cheque-register/upload', methods=['POST'])
@login_required
def upload_cheque_file():
    """Upload a file for a cheque serial"""
    try:
        if 'file' not in request.files:
            return jsonify({'success': False, 'error': 'No file provided'}), 400
        
        file = request.files['file']
        serial_id = request.form.get('serial_id')
        
        if not serial_id:
            return jsonify({'success': False, 'error': 'Serial ID not provided'}), 400
        
        if file.filename == '':
            return jsonify({'success': False, 'error': 'No file selected'}), 400
        
        # Get the cheque serial
        cheque_serial = ChequeSerial.query.get(serial_id)
        if not cheque_serial:
            return jsonify({'success': False, 'error': 'Cheque serial not found'}), 404
        
        # Validate file extension
        allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'pdf'}
        file_extension = file.filename.rsplit('.', 1)[1].lower() if '.' in file.filename else ''
        if file_extension not in allowed_extensions:
            return jsonify({'success': False, 'error': 'Invalid file type. Allowed: JPG, PNG, GIF, PDF'}), 400
        
        # Validate file size (50MB max)
        max_file_size = app.config.get('MAX_FILE_SIZE', 50 * 1024 * 1024)
        file.seek(0, 2)  # Seek to end
        file_size = file.tell()
        file.seek(0)  # Reset to beginning
        
        if file_size > max_file_size:
            return jsonify({'success': False, 'error': f'File too large. Maximum size is {max_file_size // (1024 * 1024)}MB'}), 400
        
        # Generate unique filename
        import uuid
        
        unique_id = str(uuid.uuid4())[:8]
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = secure_filename(f"cheque_{serial_id}_{timestamp}_{unique_id}_{file.filename}")
        filepath = os.path.join(app.config['CHEQUE_UPLOAD_FOLDER'], filename)
        
        # Save file
        file.save(filepath)
        
        # Update database
        cheque_serial.upload_path = filename
        db.session.commit()
        
        return jsonify({
            'success': True,
            'filename': filename,
            'message': 'File uploaded successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== ERROR HANDLERS ====================

@app.errorhandler(404)
def not_found(error):
    return render_template('404.html'), 404


@app.errorhandler(403)
def forbidden(error):
    return render_template('403.html'), 403


@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return render_template('500.html'), 500


@app.errorhandler(413)
def request_entity_too_large(error):
    """Handle request entity too large errors (file upload size exceeded)"""
    error_message = 'The uploaded file(s) exceed the maximum allowed size of 100MB total. Please reduce file sizes and try again.'
    
    # Check if it's a fetch request from /request/new (new payment request form)
    # Fetch requests don't set Accept: application/json for FormData, so we check the path
    if request.path == '/request/new' and request.method == 'POST':
        try:
            return jsonify({
                'error': 'Request too large',
                'message': error_message
            }), 413
        except:
            pass
    
    # Check if client accepts JSON (AJAX/fetch requests)
    accepts_json = 'application/json' in request.headers.get('Accept', '')
    if accepts_json or request.is_json:
        try:
            return jsonify({
                'error': 'Request too large',
                'message': error_message
            }), 413
        except:
            pass
    
    # For regular form submissions, redirect with flash message
    flash(f'File upload failed: {error_message}', 'error')
    if request.path == '/request/new':
        try:
            return redirect(url_for('new_request')), 413
        except:
            pass
    try:
        return redirect(request.referrer or url_for('dashboard')), 413
    except:
        # Fallback if redirect fails
        return f'File upload failed: {error_message}', 413



# ==================== MAIN ====================



@app.route('/admin/calendar')
@role_required('Admin', 'Project Staff', 'Finance Admin', 'Finance Staff', 'GM', 'CEO', 'Operation Manager', 'IT Staff', 'IT Department Manager', 'Department Manager')
def admin_calendar():
    """Calendar view for recurring payments (Admin and Project roles)

    Department Managers are allowed only if their department is IT.
    """
    if current_user.role == 'Department Manager' and getattr(current_user, 'department', None) != 'IT':
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    return render_template('admin_calendar.html')

@app.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    """Settings page. Accessible to General Manager, Operation Manager, and all users in the IT department.
    Allows assigning a department-level temporary manager who will be the sole
    manager approver for all requests in that department while assigned.
    """
    # Authorization: allow GM, Operation Manager, or any user in the IT department
    if not (current_user.role in ['GM', 'Operation Manager'] or getattr(current_user, 'department', None) == 'IT'):
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    # Temporary manager for whole department can be any registered user.
    if request.method == 'POST':
        request_type = (request.form.get('request_type') or '').strip()
        department = (request.form.get('department') or '').strip()
        new_manager_id = request.form.get('temporary_manager_id')
        include_procurement_approvals = request.form.get('include_procurement_approvals') == '1'

        if not request_type:
            flash('Please select a type of request.', 'error')
            return redirect(url_for('settings'))

        if not department:
            flash('Please select a department.', 'error')
            return redirect(url_for('settings'))

        # Validate include_procurement_approvals: only allowed for Procurement department with item request types
        if include_procurement_approvals:
            if department.lower() != 'procurement':
                flash('Procurement approvals can only be included for Procurement department.', 'error')
                return redirect(url_for('settings'))
            if request_type not in ['Procurement Item Request', 'Both Payment and Item Request']:
                flash('Procurement approvals can only be included for Procurement Item Request or Both Payment and Item Request.', 'error')
                return redirect(url_for('settings'))

        # Unset assignment if no manager selected
        if not new_manager_id or new_manager_id == 'none':
            existing = DepartmentTemporaryManager.query.filter_by(department=department, request_type=request_type).first()
            if existing:
                old_manager = existing.temporary_manager
                db.session.delete(existing)
                db.session.commit()
                log_action(f"Removed department-level temporary manager for {department} ({request_type}) by {current_user.name}")
                if old_manager:
                    create_notification(
                        user_id=old_manager.user_id,
                        title="Temporary Manager Assignment Removed",
                        message=f"You are no longer the temporary manager for the {department} department ({request_type}).",
                        notification_type="temporary_manager_unassigned"
                    )
                flash(f'Department-level temporary manager for {department} ({request_type}) has been removed.', 'success')
            else:
                flash(f'No temporary manager was set for {department} ({request_type}).', 'info')
            return redirect(url_for('settings'))

        # Validate new manager (allow any registered user)
        try:
            new_manager = User.query.get(int(new_manager_id))
        except Exception:
            new_manager = None

        if not new_manager:
            flash('Selected user does not exist.', 'error')
            return redirect(url_for('settings'))

        existing = DepartmentTemporaryManager.query.filter_by(department=department, request_type=request_type).first()
        if existing and existing.temporary_manager_id == int(new_manager_id):
            # Update include_procurement_approvals even if manager is the same
            if existing.include_procurement_approvals != include_procurement_approvals:
                existing.include_procurement_approvals = include_procurement_approvals
                existing.set_by_user_id = current_user.user_id
                existing.set_at = datetime.utcnow()
                db.session.commit()
                flash('Procurement approvals setting updated for this assignment.', 'success')
            else:
                flash('Selected manager is already assigned as the temporary manager for this department and request type.', 'info')
            return redirect(url_for('settings'))

        old_manager = existing.temporary_manager if existing else None
        if existing:
            existing.temporary_manager_id = int(new_manager_id)
            existing.set_by_user_id = current_user.user_id
            existing.set_at = datetime.utcnow()
            existing.include_procurement_approvals = include_procurement_approvals
        else:
            new_entry = DepartmentTemporaryManager(
                request_type=request_type,
                department=department,
                temporary_manager_id=int(new_manager_id),
                set_by_user_id=current_user.user_id,
                include_procurement_approvals=include_procurement_approvals
            )
            db.session.add(new_entry)

        db.session.commit()

        # Notifications
        if request_type == 'Both Payment and Item Request':
            approval_text = "both payment and item requests"
        else:
            approval_text = request_type.lower()
        
        notification_message = f"You have been temporarily assigned as manager for the {department} department ({request_type}). You will be responsible for manager approvals for {approval_text} in that department."
        if include_procurement_approvals:
            notification_message += " Additionally, you will be responsible for Procurement Manager Approval and Final Approval steps for item requests from ALL departments."
        
        create_notification(
            user_id=new_manager.user_id,
            title="Temporary Manager Assignment",
            message=notification_message,
            notification_type="temporary_manager_assignment"
        )
        if old_manager and old_manager.user_id != new_manager.user_id:
            create_notification(
                user_id=old_manager.user_id,
                title="Temporary Manager Assignment Removed",
                message=f"You are no longer the temporary manager for the {department} department ({request_type}).",
                notification_type="temporary_manager_unassigned"
            )

        log_action(f"Assigned department-level temporary manager for {department} ({request_type}) to {new_manager.name} by {current_user.name}")
        flash(f'{new_manager.name} has been assigned as temporary manager for {department} ({request_type}).', 'success')
        # Additional notifications per policy:
        # - IT Department (IT Staff and Department Manager)
        # - GM
        # - Operation Manager
        # - Original Assigned Manager (Department Manager of this department)
        # - Temporary Manager (already notified above)
        # - All users under the department where temp manager was set
        notified_ids = set()
        # already notified
        if new_manager and new_manager.user_id:
            notified_ids.add(new_manager.user_id)
        if old_manager and getattr(old_manager, 'user_id', None):
            notified_ids.add(old_manager.user_id)

        recipients = []

        # IT Dept: notify ALL users in the IT department
        try:
            it_users = User.query.filter_by(department='IT').all()
            recipients.extend(it_users)
        except Exception:
            pass

        # GM
        try:
            gm_users = User.query.filter_by(role='GM').all()
            recipients.extend(gm_users)
        except Exception:
            pass

        # Operation Manager
        try:
            op_users = User.query.filter_by(role='Operation Manager').all()
            recipients.extend(op_users)
        except Exception:
            pass

        # Original Assigned Manager(s) for this department (Department Manager role)
        try:
            dept_managers = User.query.filter_by(role='Department Manager', department=department).all()
            recipients.extend(dept_managers)
        except Exception:
            pass

        # Also include any users who are listed as manager_id for users in this department
        try:
            manager_ids = {u.manager_id for u in User.query.filter_by(department=department).all() if getattr(u, 'manager_id', None)}
            if manager_ids:
                manager_users = User.query.filter(User.user_id.in_(list(manager_ids))).all()
                recipients.extend(manager_users)
        except Exception:
            pass

        # All users under the department
        try:
            dept_users = User.query.filter_by(department=department).all()
            recipients.extend(dept_users)
        except Exception:
            pass

        # Send notifications, avoid duplicates
        for user in recipients:
            if not user or not getattr(user, 'user_id', None):
                continue
            if user.user_id in notified_ids:
                continue
            if request_type == 'Both Payment and Item Request':
                type_text = "both payment and item requests"
            else:
                type_text = request_type.lower()
            create_notification(
                user_id=user.user_id,
                title="Temporary Manager Assigned",
                message=f"The {department} department has a temporary manager for {type_text}: {new_manager.name}. Please take note of the temporary approval flow.",
                notification_type="temporary_manager_assignment"
            )
            notified_ids.add(user.user_id)

        return redirect(url_for('settings'))

    # GET: prepare data for settings page
    # Departments - gather distinct departments from Users and PaymentRequest entries
    user_departments = [d[0] for d in db.session.query(User.department).distinct().all() if d[0]]
    request_departments = [d[0] for d in db.session.query(PaymentRequest.department).distinct().all() if d[0]]
    departments = sorted(set(user_departments + request_departments))

    # Load all users and group them by department in the template
    managers = User.query.order_by(User.department, User.name).all()
    # Create a dictionary with composite key (department, request_type) -> entry
    assignments = {}
    for a in DepartmentTemporaryManager.query.all():
        key = f"{a.department}|{a.request_type}" if a.request_type else a.department
        assignments[key] = a
    return render_template('settings.html', departments=departments, managers=managers, assignments=assignments)


@app.route('/settings/unassign', methods=['POST'])
@login_required
def unassign_temp_manager():
    """Unassign department-level temporary manager (from settings table)"""
    # Authorization: allow GM, Operation Manager, or any user in the IT department
    if not (current_user.role in ['GM', 'Operation Manager'] or getattr(current_user, 'department', None) == 'IT'):
        flash('You do not have permission to access this page.', 'danger')
        return redirect(url_for('dashboard'))
    department = (request.form.get('department') or '').strip()
    request_type = (request.form.get('request_type') or '').strip()
    if not department:
        flash('No department specified.', 'error')
        return redirect(url_for('settings'))

    if request_type:
        existing = DepartmentTemporaryManager.query.filter_by(department=department, request_type=request_type).first()
    else:
        # Fallback for old entries without request_type
        existing = DepartmentTemporaryManager.query.filter_by(department=department).first()
    
    if not existing:
        flash(f'No temporary manager set for {department}' + (f' ({request_type})' if request_type else '') + '.', 'info')
        return redirect(url_for('settings'))

    old_manager = existing.temporary_manager
    try:
        db.session.delete(existing)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Failed to unassign temporary manager for {department}: {e}")
        flash('Failed to unassign temporary manager. Please try again.', 'danger')
        return redirect(url_for('settings'))

    log_action(f"Removed department-level temporary manager for {department}" + (f" ({request_type})" if request_type else "") + f" by {current_user.name}")

    notified_ids = set()
    # Notify the former temporary manager directly
    if old_manager and getattr(old_manager, 'user_id', None):
        create_notification(
            user_id=old_manager.user_id,
            title="Temporary Manager Assignment Removed",
            message=f"You are no longer the temporary manager for the {department} department.",
            notification_type="temporary_manager_unassigned"
        )
        notified_ids.add(old_manager.user_id)

    # Also notify all other authorized parties (same recipients as assignment)
    recipients = []

    # IT Dept: notify ALL users in the IT department
    try:
        it_users = User.query.filter_by(department='IT').all()
        recipients.extend(it_users)
    except Exception:
        pass

    # GM
    try:
        gm_users = User.query.filter_by(role='GM').all()
        recipients.extend(gm_users)
    except Exception:
        pass

    # Operation Manager
    try:
        op_users = User.query.filter_by(role='Operation Manager').all()
        recipients.extend(op_users)
    except Exception:
        pass

    # Original Assigned Manager(s) for this department (Department Manager role)
    try:
        dept_managers = User.query.filter_by(role='Department Manager', department=department).all()
        recipients.extend(dept_managers)
    except Exception:
        pass

    # Also include any users who are listed as manager_id for users in this department
    try:
        manager_ids = {u.manager_id for u in User.query.filter_by(department=department).all() if getattr(u, 'manager_id', None)}
        if manager_ids:
            manager_users = User.query.filter(User.user_id.in_(list(manager_ids))).all()
            recipients.extend(manager_users)
    except Exception:
        pass

    # All users under the department
    try:
        dept_users = User.query.filter_by(department=department).all()
        recipients.extend(dept_users)
    except Exception:
        pass

    # Send notifications, avoid duplicates
    for user in recipients:
        if not user or not getattr(user, 'user_id', None):
            continue
        if user.user_id in notified_ids:
            continue
        create_notification(
            user_id=user.user_id,
            title="Temporary Manager Removed",
            message=f"The temporary manager for the {department} department has been removed. Please take note of the updated approval flow.",
            notification_type="temporary_manager_unassigned"
        )
        notified_ids.add(user.user_id)

    flash(f'Temporary manager removed for {department}.', 'success')
    return redirect(url_for('settings'))

@app.route('/api/admin/recurring-events')
@role_required('Admin', 'Project Staff', 'Finance Admin', 'Finance Staff', 'GM', 'CEO', 'Operation Manager', 'IT Staff', 'IT Department Manager', 'Department Manager')
def api_admin_recurring_events():
    """API endpoint for calendar events (recurring + one-time scheduled)."""
    # Restrict Department Manager to IT department only
    if current_user.role == 'Department Manager' and getattr(current_user, 'department', None) != 'IT':
        flash('You do not have permission to access this resource.', 'danger')
        return redirect(url_for('dashboard'))
    try:
        # Build query for recurring payment requests (exclude archived)
        # Include requests with Payment Type "Recurring" and status in allowed list
        query = PaymentRequest.query.filter(
            PaymentRequest.recurring == 'Recurring',  # Payment Type must be "Recurring"
            PaymentRequest.recurring_interval.isnot(None),
            PaymentRequest.recurring_interval != '',
            PaymentRequest.status.in_([
                'Pending Finance Approval',
                'Proof Pending',
                'Proof Sent',
                'Proof Rejected',
                'Completed',
                'Recurring'
            ]),
            PaymentRequest.is_archived == False
        )
        
        # Project users can only see their department's requests
        if current_user.role == 'Project Staff':
            query = query.filter(PaymentRequest.department == current_user.department)
        
        recurring_requests = query.all()
        
        # Group events by date
        events_by_date = {}
        today = date.today()
        
        for req in recurring_requests:
            # Check if this is a variable payment with installments
            schedule = RecurringPaymentSchedule.query.filter_by(request_id=req.request_id).all()
            
            if schedule:
                # For variable payments, calculate remaining amount
                total_paid_amount = 0
                paid_notifications = PaidNotification.query.filter_by(request_id=req.request_id).all()
                
                for installment in schedule:
                    # Check if this specific installment is paid
                    is_paid = any(
                        paid_notif.paid_date == installment.payment_date 
                        for paid_notif in paid_notifications
                    )
                    
                    # If this installment is paid, add its amount to total paid
                    if is_paid:
                        total_paid_amount += float(installment.amount)
                
                # Calculate remaining amount
                remaining_amount = float(req.amount) - total_paid_amount
                
                # If remaining amount is 0 or less, skip this request
                if remaining_amount <= 0:
                    continue
            else:
                # For regular recurring payments, check if there are any paid notifications
                paid_notifications_count = PaidNotification.query.filter_by(request_id=req.request_id).count()
                
                # If there are paid notifications, skip this request entirely
                if paid_notifications_count > 0:
                    continue
            
            if schedule:
                # For variable payments, show only the specific installment dates
                for installment in schedule:
                    # Check if this specific installment is paid using the RecurringPaymentSchedule.is_paid field
                    is_paid = installment.is_paid
                    
                    # Determine event color (red if marked late)
                    is_late = LateInstallment.query.filter_by(
                        request_id=req.request_id,
                        payment_date=installment.payment_date
                    ).first() is not None
                    
                    # Debug: Log payment status determination
                    print(f"Request {req.request_id}, Date {installment.payment_date}: Paid={is_paid}, Late={is_late}")
                    
                    event_color = '#2e7d32' if is_paid else ('#d32f2f' if is_late else '#8e24aa')
                    
                    # Calculate remaining amount
                    total_paid = sum(
                        pn.amount if hasattr(pn, 'amount') else 0 
                        for pn in PaidNotification.query.filter_by(request_id=req.request_id).all()
                    )
                    remaining_amount = req.amount - total_paid
                    
                    # Add to events_by_date
                    date_key = installment.payment_date.isoformat()
                    if date_key not in events_by_date:
                        events_by_date[date_key] = []
                    
                    events_by_date[date_key].append({
                        'title': f'OMR {installment.amount:.3f}',
                        'start': installment.payment_date.isoformat(),
                        'color': event_color,
                        'url': f'/request/{req.request_id}',
                        'extendedProps': {
                            'requestId': req.request_id,
                            'requestType': req.request_type,
                            'companyName': req.person_company or 'N/A',
                            'department': req.department,
                            'purpose': req.purpose,
                            'baseAmount': f'OMR {req.amount:.3f}',
                            'remainingAmount': f'OMR {remaining_amount:.3f}'
                        }
                    })
            else:
                # For regular recurring payments, generate future due dates
                start_date = today
                end_date = today + timedelta(days=365)
                
                due_dates = generate_future_due_dates(req, start_date, end_date)
                
                for due_date, amount in due_dates:
                    # Check if this payment is already marked as paid
                    paid_notification = PaidNotification.query.filter_by(
                        request_id=req.request_id,
                        paid_date=due_date
                    ).first()
                    
                    # Determine event color (red if marked late)
                    is_late = LateInstallment.query.filter_by(
                        request_id=req.request_id,
                        payment_date=due_date
                    ).first() is not None
                    
                    # Debug: Log payment status determination
                    print(f"Request {req.request_id}, Date {due_date}: Paid={paid_notification is not None}, Late={is_late}")
                    
                    event_color = '#2e7d32' if paid_notification else ('#d32f2f' if is_late else '#8e24aa')
                    
                    # Add to events_by_date
                    date_key = due_date.isoformat()
                    if date_key not in events_by_date:
                        events_by_date[date_key] = []
                    
                    events_by_date[date_key].append({
                        'title': f'OMR {amount:.3f}',
                        'start': due_date.isoformat(),
                        'color': event_color,
                        'url': f'/request/{req.request_id}',
                        'extendedProps': {
                            'requestId': req.request_id,
                            'requestType': req.request_type,
                            'companyName': req.person_company or 'N/A',
                            'department': req.department,
                            'purpose': req.purpose,
                            'baseAmount': None,
                            'remainingAmount': None
                        }
                    })
        
        # Also include ONE-TIME scheduled payments that the current user is authorized to see
        def is_authorized_for_one_time(req, user):
            # Requestor
            if req.user_id == user.user_id:
                return True
            # Temporary manager
            if getattr(req, 'temporary_manager_id', None) == user.user_id:
                return True
            # GM and Operation Manager (global)
            if user.role in ['GM', 'Operation Manager']:
                return True
            # IT Staff and IT Department Manager (global IT access)
            if user.department == 'IT' and user.role in ['IT Staff', 'Department Manager']:
                return True
            # Assigned manager
            if getattr(req.user, 'manager_id', None) == user.user_id:
                return True
            # Department Manager of same department
            if user.role == 'Department Manager' and user.department == req.department:
                return True
            # Finance Admin and Finance Staff can see all one-time scheduled payments when status is "Pending Finance Approval"
            if user.role in ['Finance Admin', 'Finance Staff']:
                if req.status == 'Pending Finance Approval':
                    return True  # Finance users can see all pending finance approval requests
            return False

        one_time_query = PaymentRequest.query.filter(
            (PaymentRequest.recurring.is_(None)) | (PaymentRequest.recurring != 'Recurring'),
            PaymentRequest.payment_date.isnot(None),
            PaymentRequest.status.in_([
                'Pending Finance Approval',
                'Proof Pending',
                'Proof Sent',
                'Proof Rejected',
                'Completed',
                'Recurring'
            ]),
            PaymentRequest.is_archived == False
        )
        # Project Staff can only see their department's one-time requests as well
        if current_user.role == 'Project Staff':
            one_time_query = one_time_query.filter(PaymentRequest.department == current_user.department)
        one_time_requests = one_time_query.all()

        for req in one_time_requests:
            if not is_authorized_for_one_time(req, current_user):
                continue
            date_key = req.payment_date.isoformat()
            if date_key not in events_by_date:
                events_by_date[date_key] = []
            
            # Determine color based on payment status
            # Check if request is completed
            is_completed = req.status == 'Completed'
            
            # Check if there's a paid notification for this payment date
            paid_notification = PaidNotification.query.filter_by(
                request_id=req.request_id,
                paid_date=req.payment_date
            ).first()
            
            # Determine event color: green if completed/paid, purple if due
            if is_completed or paid_notification:
                event_color = '#2e7d32'  # green for paid/completed
            else:
                event_color = '#8e24aa'  # purple for due (matches recurring payment color scheme)
            
            events_by_date[date_key].append({
                'title': f'OMR {float(req.amount):.3f}',
                'start': req.payment_date.isoformat(),
                'color': event_color,
                'url': f'/request/{req.request_id}',
                'extendedProps': {
                    'requestId': req.request_id,
                    'requestType': req.request_type,
                    'companyName': req.person_company or 'N/A',
                    'department': req.department,
                    'purpose': req.purpose,
                    'baseAmount': f'OMR {float(req.amount):.3f}',
                    'remainingAmount': None,
                    'oneTime': True
                }
            })

        # Convert grouped events to calendar format
        calendar_events = []
        for date_key, day_events in events_by_date.items():
            # Create a summary event for the day
            total_amount = sum(float(str(event['title']).replace('OMR ', '')) for event in day_events)
            count = len(day_events)
            
            # Determine the overall color for this date
            # Check if all payments are paid (green), all are late (red), or mixed/due (purple)
            paid_count = sum(1 for event in day_events if event.get('color') == '#2e7d32')
            late_count = sum(1 for event in day_events if event.get('color') == '#d32f2f')
            
            # Calculate pending count: unpaid events (purple or red, not green)
            pending_count = count - paid_count
            
            if paid_count == count:
                # All payments are paid - green
                date_color = '#2e7d32'
                status_text = 'paid'
            elif late_count > 0:
                # Some or all payments are late - red
                date_color = '#d32f2f'
                status_text = 'late'
            else:
                # All payments are due - purple
                date_color = '#8e24aa'
                status_text = 'due'
            
            calendar_events.append({
                'title': f'{count} payment{"s" if count != 1 else ""} {status_text}',
                'start': date_key,
                'color': date_color,
                'extendedProps': {
                    'count': count,
                    'totalAmount': total_amount,
                    'date': date_key,
                    'status': status_text,
                    'paidCount': paid_count,
                    'lateCount': late_count,
                    'pendingCount': pending_count,  # Count of unpaid (pending) payment requests
                    'events': day_events  # Store all events for this date
                }
            })
        
        return jsonify(calendar_events)
        
    except Exception as e:
        print(f"Error generating calendar events: {e}")
        return jsonify([])

def add_months(source_date, months):
    """Add months to a date, handling month overflow correctly"""
    month = source_date.month - 1 + months
    year = source_date.year + month // 12
    month = month % 12 + 1
    day = min(source_date.day, [31, 29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1])
    return date(year, month, day)

def generate_future_due_dates(req, start_date, end_date):
    """Generate future due dates for a recurring request"""
    if not req.recurring_interval:
        return []
    
    try:
        # Parse the recurring interval
        parts = req.recurring_interval.split(':')
        if len(parts) < 2:
            return []
        
        frequency = parts[0]
        interval = int(parts[1])
        
        if frequency == 'monthly':
            due_dates = []
            
            # Check for new :date: format (e.g., monthly:1:date:2025-10-18:end:2026-01-30)
            if len(parts) > 2 and parts[2] == 'date':
                # Parse the start date
                try:
                    base_date_str = parts[3]
                    base_date = datetime.strptime(base_date_str, '%Y-%m-%d').date()
                    
                    # Parse end date if present
                    config_end_date = None
                    if 'end' in parts:
                        end_index = parts.index('end')
                        if end_index + 1 < len(parts):
                            config_end_date = datetime.strptime(parts[end_index + 1], '%Y-%m-%d').date()
                    
                    # Use the earlier of the two end dates
                    effective_end_date = end_date
                    if config_end_date:
                        effective_end_date = min(end_date, config_end_date)
                    
                    # Generate recurring dates starting from base_date
                    current_date = base_date
                    if current_date < start_date:
                        # If base_date is before start_date, advance to the first occurrence after start_date
                        months_diff = (start_date.year - base_date.year) * 12 + (start_date.month - base_date.month)
                        cycles = (months_diff // interval) + 1
                        current_date = add_months(base_date, cycles * interval)
                    
                    # Generate dates
                    while current_date <= effective_end_date:
                        if current_date >= start_date:
                            due_dates.append((current_date, req.amount))
                        # Move to next occurrence
                        current_date = add_months(current_date, interval)
                    
                except (ValueError, IndexError) as e:
                    print(f"Error parsing date format: {e}")
                    return []
            
            # Check if old specific days format is configured
            elif len(parts) > 2 and parts[2] == 'days':
                # Parse specific days from the interval
                days = [int(day) for day in parts[3].split(',')]
                year = int(parts[4]) if len(parts) > 4 else start_date.year
                month = int(parts[5]) if len(parts) > 5 else start_date.month
                
                # Generate dates for the specific days
                current_date = start_date
                month_count = 0
                
                while current_date <= end_date:
                    if month_count % interval == 0:
                        # Generate dates for each specific day in this month
                        for day in days:
                            try:
                                # Create date for this specific day
                                due_date = date(current_date.year, current_date.month, day)
                                if due_date >= start_date and due_date <= end_date:
                                    due_dates.append((due_date, req.amount))
                            except ValueError:
                                # Skip invalid dates (like Feb 30)
                                continue
                    
                    # Move to next month
                    if current_date.month == 12:
                        current_date = date(current_date.year + 1, 1, 1)
                    else:
                        current_date = date(current_date.year, current_date.month + 1, 1)
                    month_count += 1
            else:
                # Fallback to original logic for simple monthly intervals
                current_date = start_date
                month_count = 0
                while current_date <= end_date:
                    if month_count % interval == 0:
                        due_dates.append((current_date, req.amount))
                    current_date = current_date + timedelta(days=1)
                    if current_date.day == 1:  # New month
                        month_count += 1
            
            return due_dates[:12]  # Limit to 12 months
        
        return []
        
    except Exception as e:
        print(f"Error generating due dates: {e}")
        return []


@app.route('/api/requests/mark_paid', methods=['POST'])
@role_required('Admin')
def mark_request_paid():
    """Mark an entire request as paid"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'No data provided'}), 400
        
        request_id = data.get('request_id')
        amount = data.get('amount')
        
        if not request_id or not amount:
            return jsonify({'success': False, 'message': 'Missing required fields'}), 400
        
        # Get the payment request
        payment_request = PaymentRequest.query.get(request_id)
        if not payment_request:
            return jsonify({'success': False, 'message': 'Request not found'}), 404
        
        # Check if request is approved
        if payment_request.status != 'Approved':
            return jsonify({'success': False, 'message': 'Request must be approved before marking as paid'}), 400
        
        # Check if request is recurring
        if not payment_request.recurring_interval:
            return jsonify({'success': False, 'message': 'This endpoint is only for recurring payments'}), 400
        
        # Check if this request is already paid
        existing_paid = PaidNotification.query.filter_by(request_id=request_id).first()
        
        if existing_paid:
            return jsonify({'success': False, 'message': 'This request is already marked as paid'}), 400
        
        # Create paid notification for the entire request
        paid_notification = PaidNotification(
            request_id=request_id,
            user_id=current_user.user_id,
            paid_date=date.today()
        )
        
        db.session.add(paid_notification)
        db.session.commit()
        
        # Log the action
        audit_log = AuditLog(
            user_id=current_user.user_id,
            action='Mark Request Paid',
            details=f'Marked entire request #{request_id} (OMR {amount}) as paid',
            ip_address=request.remote_addr
        )
        db.session.add(audit_log)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Request marked as paid successfully'})
        
    except Exception as e:
        print(f"Error marking request as paid: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'message': 'An error occurred while marking request as paid'}), 500


@app.route('/api/installments/mark_paid', methods=['POST'])
@role_required('Admin', 'Finance Staff')
def mark_installment_paid():
    """Mark a specific installment as paid"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'No data provided'}), 400
        
        request_id = data.get('request_id')
        payment_date = data.get('payment_date')
        amount = data.get('amount')
        
        if not request_id or not payment_date or not amount:
            return jsonify({'success': False, 'message': 'Missing required fields'}), 400
        
        # Convert payment_date string to date object
        from datetime import datetime
        try:
            payment_date_obj = datetime.strptime(payment_date, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'success': False, 'message': 'Invalid date format'}), 400
        
        # Get the payment request
        payment_request = PaymentRequest.query.get(request_id)
        if not payment_request:
            return jsonify({'success': False, 'message': 'Request not found'}), 404
        
        # Check if request is approved
        if payment_request.status != 'Approved':
            return jsonify({'success': False, 'message': 'Request must be approved before marking as paid'}), 400
        
        # Check if this installment is already paid
        existing_paid = PaidNotification.query.filter_by(
            request_id=request_id,
            paid_date=payment_date_obj
        ).first()
        
        if existing_paid:
            return jsonify({'success': False, 'message': 'This installment is already marked as paid'}), 400
        
        # Create paid notification
        paid_notification = PaidNotification(
            request_id=request_id,
            user_id=current_user.user_id,
            paid_date=payment_date_obj
        )
        
        db.session.add(paid_notification)
        db.session.commit()
        
        # Log the action
        audit_log = AuditLog(
            user_id=current_user.user_id,
            action='Mark Installment Paid',
            details=f'Marked installment of OMR {amount} due on {payment_date} as paid for request #{request_id}',
            ip_address=request.remote_addr
        )
        db.session.add(audit_log)
        db.session.commit()
        
        # Check if all installments are now paid and mark as completed if so
        check_recurring_payment_completion(request_id)
        
        return jsonify({'success': True, 'message': 'Installment marked as paid successfully'})
        
    except Exception as e:
        print(f"Error marking installment as paid: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'message': 'An error occurred while marking installment as paid'}), 500


@app.route('/api/installments/mark_late', methods=['POST'])
@role_required('Admin')
def mark_installment_late():
    """Mark a specific installment as late (Admin only)"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'No data provided'}), 400
        
        request_id = data.get('request_id')
        payment_date = data.get('payment_date')
        
        if not request_id or not payment_date:
            return jsonify({'success': False, 'message': 'Missing required fields'}), 400
        
        # Convert payment_date string to date object
        from datetime import datetime
        try:
            payment_date_obj = datetime.strptime(payment_date, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'success': False, 'message': 'Invalid date format'}), 400
        
        # Get the payment request
        payment_request = PaymentRequest.query.get(request_id)
        if not payment_request:
            return jsonify({'success': False, 'message': 'Request not found'}), 404
        
        # Check if request is approved
        if payment_request.status != 'Approved':
            return jsonify({'success': False, 'message': 'Request must be approved before marking installments as late'}), 400
        
        # If already paid, cannot be marked late
        existing_paid = PaidNotification.query.filter_by(
            request_id=request_id,
            paid_date=payment_date_obj
        ).first()
        if existing_paid:
            return jsonify({'success': False, 'message': 'This installment is already marked as paid'}), 400
        
        # Check if already marked late
        from models import LateInstallment
        existing_late = LateInstallment.query.filter_by(
            request_id=request_id,
            payment_date=payment_date_obj
        ).first()
        if existing_late:
            return jsonify({'success': True, 'message': 'Installment already marked as late'})
        
        # Create late installment record
        late = LateInstallment(
            request_id=request_id,
            payment_date=payment_date_obj,
            marked_by_user_id=current_user.user_id
        )
        db.session.add(late)
        db.session.commit()
        
        # Log the action
        log_action(f"Marked installment due on {payment_date} as LATE for request #{request_id}")
        
        return jsonify({'success': True, 'message': 'Installment marked as late'})
    except Exception as e:
        print(f"Error marking installment as late: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'message': 'An error occurred while marking installment as late'}), 500


if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        
        # Migrate: Add amount and receipt_path columns to procurement_item_requests if they don't exist
        try:
            import sqlite3
            db_path = app.config['SQLALCHEMY_DATABASE_URI'].replace('sqlite:///', '')
            if os.name == 'nt':  # Windows
                db_path = db_path.replace('/', '\\')
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if columns exist
            cursor.execute("PRAGMA table_info(procurement_item_requests)")
            existing_columns = [row[1] for row in cursor.fetchall()]
            
            if 'amount' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN amount NUMERIC(10, 3)")
                conn.commit()
                print("‚úì Added 'amount' column to procurement_item_requests table")
            else:
                print("‚úì 'amount' column already exists in procurement_item_requests table")
            
            if 'receipt_path' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN receipt_path VARCHAR(255)")
                conn.commit()
                print("‚úì Added 'receipt_path' column to procurement_item_requests table")
            else:
                print("‚úì 'receipt_path' column already exists in procurement_item_requests table")
            
            if 'invoice_path' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN invoice_path VARCHAR(255)")
                conn.commit()
                print("‚úì Added 'invoice_path' column to procurement_item_requests table")
            else:
                print("‚úì 'invoice_path' column already exists in procurement_item_requests table")
            
            if 'receipt_amount' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN receipt_amount NUMERIC(10, 3)")
                conn.commit()
                print("‚úì Added 'receipt_amount' column to procurement_item_requests table")
            else:
                print("‚úì 'receipt_amount' column already exists in procurement_item_requests table")
            
            if 'invoice_amount' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN invoice_amount NUMERIC(10, 3)")
                conn.commit()
                print("‚úì Added 'invoice_amount' column to procurement_item_requests table")
            else:
                print("‚úì 'invoice_amount' column already exists in procurement_item_requests table")
            
            if 'receipt_reference_number' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN receipt_reference_number VARCHAR(100)")
                conn.commit()
                print("‚úì Added 'receipt_reference_number' column to procurement_item_requests table")
            else:
                print("‚úì 'receipt_reference_number' column already exists in procurement_item_requests table")
            
            if 'procurement_quantities' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_quantities TEXT")
                conn.commit()
                print("‚úì Added 'procurement_quantities' column to procurement_item_requests table")
            else:
                print("‚úì 'procurement_quantities' column already exists in procurement_item_requests table")
            
            if 'payment_date' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN payment_date DATE")
                conn.commit()
                print("‚úì Added 'payment_date' column to procurement_item_requests table")
            else:
                print("‚úì 'payment_date' column already exists in procurement_item_requests table")
            
            if 'manager_quantity_rejection_reason' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN manager_quantity_rejection_reason TEXT")
                conn.commit()
                print("‚úì Added 'manager_quantity_rejection_reason' column to procurement_item_requests table")
            else:
                print("‚úì 'manager_quantity_rejection_reason' column already exists in procurement_item_requests table")
            
            if 'procurement_manager_quantity_rejection_reason' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_manager_quantity_rejection_reason TEXT")
                conn.commit()
                print("‚úì Added 'procurement_manager_quantity_rejection_reason' column to procurement_item_requests table")
            else:
                print("‚úì 'procurement_manager_quantity_rejection_reason' column already exists in procurement_item_requests table")

            if 'procurement_quantity_rejection_reason' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_quantity_rejection_reason TEXT")
                conn.commit()
                print("‚úì Added 'procurement_quantity_rejection_reason' column to procurement_item_requests table")
            else:
                print("‚úì 'procurement_quantity_rejection_reason' column already exists in procurement_item_requests table")
            
            if 'category' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN category VARCHAR(100)")
                conn.commit()
                print("‚úì Added 'category' column to procurement_item_requests table")
            else:
                print("‚úì 'category' column already exists in procurement_item_requests table")
            
            if 'procurement_manager_quantities' not in existing_columns:
                cursor.execute("ALTER TABLE procurement_item_requests ADD COLUMN procurement_manager_quantities TEXT")
                conn.commit()
                print("‚úì Added 'procurement_manager_quantities' column to procurement_item_requests table")
            else:
                print("‚úì 'procurement_manager_quantities' column already exists in procurement_item_requests table")
            
            # Migrate: Add item_request_id column to notifications table if it doesn't exist
            cursor.execute("PRAGMA table_info(notifications)")
            notification_columns = [row[1] for row in cursor.fetchall()]
            
            if 'item_request_id' not in notification_columns:
                cursor.execute("ALTER TABLE notifications ADD COLUMN item_request_id INTEGER")
                conn.commit()
                print("‚úì Added 'item_request_id' column to notifications table")
            else:
                print("‚úì 'item_request_id' column already exists in notifications table")
            
            # Migrate: Add on_hold columns to procurement_item_requests table if they don't exist
            cursor.execute("PRAGMA table_info(procurement_item_requests)")
            item_request_columns = [row[1] for row in cursor.fetchall()]
            
            on_hold_columns = [
                ('manager_on_hold_date', 'DATE'),
                ('manager_on_hold_by', 'VARCHAR(100)'),
                ('manager_on_hold_by_user_id', 'INTEGER'),
                ('manager_on_hold_reason', 'TEXT'),
                ('procurement_manager_on_hold_date', 'DATE'),
                ('procurement_manager_on_hold_by', 'VARCHAR(100)'),
                ('procurement_manager_on_hold_by_user_id', 'INTEGER'),
                ('procurement_manager_on_hold_reason', 'TEXT')
            ]
            
            for col_name, col_type in on_hold_columns:
                if col_name not in item_request_columns:
                    cursor.execute(f"ALTER TABLE procurement_item_requests ADD COLUMN {col_name} {col_type}")
                    conn.commit()
                    print(f"‚úì Added '{col_name}' column to procurement_item_requests table")
                else:
                    print(f"‚úì '{col_name}' column already exists in procurement_item_requests table")
            
            # Migrate: Add account_name and account_number columns to person_company_options table if they don't exist
            cursor.execute("PRAGMA table_info(person_company_options)")
            person_company_columns = [row[1] for row in cursor.fetchall()]
            
            if 'account_name' not in person_company_columns:
                cursor.execute("ALTER TABLE person_company_options ADD COLUMN account_name VARCHAR(200)")
                conn.commit()
                print("‚úì Added 'account_name' column to person_company_options table")
            else:
                print("‚úì 'account_name' column already exists in person_company_options table")
            
            if 'account_number' not in person_company_columns:
                cursor.execute("ALTER TABLE person_company_options ADD COLUMN account_number VARCHAR(50)")
                conn.commit()
                print("‚úì Added 'account_number' column to person_company_options table")
            else:
                print("‚úì 'account_number' column already exists in person_company_options table")
            
            if 'bank_name' not in person_company_columns:
                cursor.execute("ALTER TABLE person_company_options ADD COLUMN bank_name VARCHAR(200)")
                conn.commit()
                print("‚úì Added 'bank_name' column to person_company_options table")
            else:
                print("‚úì 'bank_name' column already exists in person_company_options table")
            
            # Migrate: Add on_hold columns to payment_requests table if they don't exist
            cursor.execute("PRAGMA table_info(payment_requests)")
            payment_request_columns = [row[1] for row in cursor.fetchall()]
            
            payment_on_hold_columns = [
                ('manager_on_hold_date', 'DATE'),
                ('manager_on_hold_by', 'VARCHAR(100)'),
                ('manager_on_hold_by_user_id', 'INTEGER'),
                ('manager_on_hold_reason', 'TEXT')
            ]
            
            for col_name, col_type in payment_on_hold_columns:
                if col_name not in payment_request_columns:
                    cursor.execute(f"ALTER TABLE payment_requests ADD COLUMN {col_name} {col_type}")
                    conn.commit()
                    print(f"‚úì Added '{col_name}' column to payment_requests table")
                else:
                    print(f"‚úì '{col_name}' column already exists in payment_requests table")
            
            # Migrate: Add cash_receiver column to payment_requests table if it doesn't exist
            if 'cash_receiver' not in payment_request_columns:
                cursor.execute("ALTER TABLE payment_requests ADD COLUMN cash_receiver VARCHAR(200)")
                conn.commit()
                print("‚úì Added 'cash_receiver' column to payment_requests table")
            else:
                print("‚úì 'cash_receiver' column already exists in payment_requests table")
            
            # Migrate: Add is_draft column to payment_requests table if it doesn't exist
            if 'is_draft' not in payment_request_columns:
                cursor.execute("ALTER TABLE payment_requests ADD COLUMN is_draft BOOLEAN DEFAULT 0")
                conn.commit()
                print("‚úì Added 'is_draft' column to payment_requests table")
            else:
                print("‚úì 'is_draft' column already exists in payment_requests table")
            
            conn.close()
        except Exception as e:
            print(f"Warning: Could not migrate columns: {e}")
        
        # Automatically initialize location priorities from existing branches
        # This is SAFE: Only reads from branches table and inserts into location_priorities table
        # Does NOT modify branches or payment_requests tables - existing requests are unaffected
        try:
            from models import LocationPriority, Branch
            
            # Default priorities matching the old hardcoded order
            default_priorities = {
                'Office': 1,
                'Kucu': 2,
                'Boom': 3,
                'Thoum': 4,
                'Kitchen': 5
            }
            
            # Get all unique location names from branches table (READ ONLY - no modifications)
            all_locations = db.session.query(Branch.restaurant).distinct().all()
            location_names = [loc[0] for loc in all_locations if loc[0]]  # Filter out None/empty values
            
            if location_names:
                created_count = 0
                skipped_count = 0
                
                for location_name in location_names:
                    # Check if location priority already exists (idempotent - safe to run multiple times)
                    existing = LocationPriority.query.filter_by(location_name=location_name).first()
                    
                    if existing:
                        skipped_count += 1
                        continue
                    
                    # Get priority from defaults, or use a high number for new locations
                    priority = default_priorities.get(location_name, 999)
                    
                    try:
                        location_priority = LocationPriority(
                            location_name=location_name,
                            priority=priority,
                            is_active=True,
                            created_by_user_id=None  # System initialization
                        )
                        
                        db.session.add(location_priority)
                        created_count += 1
                        
                    except Exception as e:
                        print(f"Warning: Could not create location priority for '{location_name}': {e}")
                        db.session.rollback()
                        continue
                
                # Commit all new location priorities
                if created_count > 0:
                    try:
                        db.session.commit()
                        print(f"‚úì Auto-initialized {created_count} location priorit{'y' if created_count == 1 else 'ies'} from existing branches")
                        if skipped_count > 0:
                            print(f"  (Skipped {skipped_count} location{'s' if skipped_count != 1 else ''} that already had priorities)")
                    except Exception as e:
                        db.session.rollback()
                        print(f"Warning: Could not commit location priorities: {e}")
                elif skipped_count > 0:
                    print(f"‚úì All {skipped_count} location{'s' if skipped_count != 1 else ''} already have priorities configured")
        except Exception as e:
            # Don't break app startup if location initialization fails
            print(f"Warning: Could not auto-initialize location priorities: {e}")
            print("  (This is non-critical - you can manually add location priorities later)")
        
        # Check for timing alerts on startup
        try:
            check_finance_approval_timing_alerts()
            print("Timing alerts check completed on startup")
        except Exception as e:
            print(f"Error checking timing alerts on startup: {e}")
        
        # Start background scheduler in a separate thread
        scheduler_thread = threading.Thread(target=background_scheduler, daemon=True)
        scheduler_thread.start()
        print("Background scheduler started")
    
    socketio.run(app, debug=True, host='0.0.0.0', port=5005)

