{% extends "base.html" %}

{% block title %}New Payment Request{% endblock %}

{% block content %}
<div class="dashboard-container">
    <div class="dashboard-header">
        <h1><i class="fas fa-plus-circle"></i> New Payment Request</h1>
        <p>Submit a new payment request</p>
    </div>

    <div class="card">
        <div class="card-body">
            <form method="POST" action="{% if draft %}{{ url_for('edit_draft', draft_id=draft.request_id) }}{% else %}{{ url_for('new_request') }}{% endif %}" id="requestForm" enctype="multipart/form-data">
                <div class="form-row">
                    <div class="form-group">
                        <label for="request_type">Request Type *</label>
                        <select name="request_type" id="request_type" required onchange="handleRequestTypeChange()">
                            <option value="">-- Select Type --</option>
                            {% if available_request_types %}
                                {# Non-"Others" first #}
                                {% for request_type in available_request_types | rejectattr('name', 'equalto', 'Others') %}
                                <option value="{{ request_type.name }}">{{ request_type.name }}</option>
                                {% endfor %}
                                {# Ensure "Others" is always last if present #}
                                {% for request_type in available_request_types | selectattr('name', 'equalto', 'Others') %}
                                <option value="{{ request_type.name }}">{{ request_type.name }}</option>
                                {% endfor %}
                            {% else %}
                                <option value="" disabled>No request types available for your department</option>
                            {% endif %}
                        </select>
                        <small class="form-text text-muted">
                            {% if available_request_types %}
                                Available request types for {{ user.department }} department
                            {% else %}
                                No request types configured for your department. Please contact IT to set up request types.
                            {% endif %}
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="requestor_name">Requestor Name *</label>
                        <input type="text" name="requestor_name" id="requestor_name" value="{{ user.name if user else '' }}" required>
                    </div>

                    <div class="form-group">
                        <label for="branch_name">Branch Name *</label>
                        <div class="branch-select-container">
                            <div id="branch_chips_container" class="branch-chips-container"></div>
                            <input type="text" id="branch_search" class="form-control" placeholder="Search branches..." autocomplete="off">
                            <select name="branch_name" id="branch_name" class="form-control" style="display: none;">
                                <option value="">-- Select Branch --</option>
                                {% if available_branches %}
                                    {% set current_restaurant = "" %}
                                    {% for branch in available_branches %}
                                        {% set restaurant = branch.restaurant %}
                                        {% if restaurant != current_restaurant %}
                                            {% if current_restaurant != "" %}
                                                </optgroup>
                                            {% endif %}
                                            <optgroup label="{{ restaurant }} (Location)" data-restaurant="{{ restaurant }}">
                                            {% set current_restaurant = restaurant %}
                                        {% endif %}
                                        <option value="{{ branch.name }}" data-restaurant="{{ restaurant }}">{{ branch.name }}</option>
                                    {% endfor %}
                                    {% if current_restaurant != "" %}
                                        </optgroup>
                                    {% endif %}
                                {% endif %}
                            </select>
                            <input type="hidden" name="branch_names" id="branch_names" value="">
                            <div id="branch_dropdown" class="branch-dropdown" style="display: none;"></div>
                        </div>
                        <small class="form-text text-muted">Type to search or select the branch location for this request</small>
                    </div>
                    
                    <style>
                    /* Style for grouped dropdown */
                    .branch-select-container {
                        position: relative;
                    }
                    
                    .branch-chips-container {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 8px;
                        margin-bottom: 0;
                        min-height: 0;
                    }
                    
                    .branch-chips-container:not(:empty) {
                        margin-bottom: 8px;
                    }
                    
                    .branch-chip {
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        padding: 6px 12px;
                        background: #000;
                        color: white;
                        border-radius: 20px;
                        font-size: 13px;
                        font-weight: 500;
                    }
                    
                    .branch-chip .remove-chip {
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        width: 18px;
                        height: 18px;
                        background: rgba(255, 255, 255, 0.2);
                        border: none;
                        border-radius: 50%;
                        color: white;
                        cursor: pointer;
                        font-size: 12px;
                        padding: 0;
                        transition: background 0.2s;
                        line-height: 1;
                    }
                    
                    .branch-chip .remove-chip:hover {
                        background: rgba(255, 255, 255, 0.3);
                    }
                    
                    .branch-dropdown {
                        position: absolute;
                        top: 100%;
                        left: 0;
                        right: 0;
                        background: white;
                        border: 1px solid #ced4da;
                        border-top: none;
                        border-radius: 0 0 0.375rem 0.375rem;
                        max-height: 200px;
                        overflow-y: auto;
                        z-index: 1000;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    }
                    
                    .branch-group {
                        background-color: #f8f9fa;
                        padding: 8px 12px;
                        font-weight: bold;
                        color: #495057;
                        border-bottom: 1px solid #dee2e6;
                        font-size: 12px;
                        text-transform: uppercase;
                    }
                    
                    .branch-option {
                        padding: 8px 20px;
                        cursor: pointer;
                        border-bottom: 1px solid #f1f3f4;
                        transition: background-color 0.2s;
                        -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile/trackpad */
                        touch-action: manipulation; /* Optimize for touch/trackpad */
                        user-select: none; /* Prevent text selection */
                    }
                    
                    .branch-option:hover {
                        background-color: #e9ecef;
                    }
                    
                    .branch-option:active {
                        background-color: #dee2e6; /* Visual feedback for soft touches */
                    }
                    
                    .branch-option.selected {
                        background-color: #007bff;
                        color: white;
                    }
                    
                    .branch-option.hidden {
                        display: none;
                    }
                    
                    optgroup {
                        font-weight: bold;
                        color: #495057;
                        background-color: #f8f9fa;
                        padding: 5px 0;
                    }
                    
                    optgroup option {
                        font-weight: normal;
                        color: #212529;
                        padding-left: 20px;
                    }
                    
                    #branch_name {
                        font-size: 14px;
                    }
                    
                    /* Style for supplier dropdown (similar to branch dropdown) */
                    .supplier-select-container {
                        position: relative;
                    }
                    
                    .supplier-dropdown {
                        position: absolute;
                        top: 100%;
                        left: 0;
                        right: 0;
                        background: white;
                        border: 1px solid #ced4da;
                        border-top: none;
                        border-radius: 0 0 0.375rem 0.375rem;
                        max-height: 200px;
                        overflow-y: auto;
                        z-index: 1000;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    }
                    
                    .supplier-option {
                        padding: 8px 20px;
                        cursor: pointer;
                        border-bottom: 1px solid #f1f3f4;
                        transition: background-color 0.2s;
                    }
                    
                    .supplier-option:hover {
                        background-color: #e9ecef;
                    }
                    
                    .supplier-option.selected {
                        background-color: #007bff;
                        color: white;
                    }
                    
                    .supplier-option.hidden {
                        display: none;
                    }
    
    /* Tooltip styling (match view_item_request.html tooltip) */
    .tooltip-wrapper {
        position: relative;
        display: inline-block;
    }

    .tooltip-wrapper .tooltip-icon {
        color: #6c757d;
        margin-left: 8px;
        cursor: help;
        font-size: 0.9em;
        vertical-align: middle;
    }

    .tooltip-wrapper .tooltip-text {
        visibility: hidden;
        /* Let the tooltip size to its content but constrain maximum width */
        width: auto;
        max-width: 320px;
        background-color: #333;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 8px 12px;
        position: fixed !important;
        z-index: 99999 !important;
        bottom: auto;
        left: auto;
        margin-left: 0;
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.875rem;
        font-weight: normal;
        line-height: 1.4;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        pointer-events: none;
        white-space: normal;
        word-wrap: break-word;
        display: inline-block;
    }

    .tooltip-wrapper .tooltip-text::after {
        content: "";
        position: absolute;
        top: 100%;
        /* place arrow near the very left side of the tooltip box (inside padding area) */
        left: 8px;
        margin-left: 0;
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
    }

    .tooltip-wrapper:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
    }
    /* Show tooltip when wrapper has tooltip-visible (used for tap on mobile) */
    .tooltip-wrapper.tooltip-visible .tooltip-text {
        visibility: visible;
        opacity: 1;
        pointer-events: auto;
    }
    /* Responsive-only adjustments: slightly larger icon and touch-friendly spacing */
    @media (max-width: 768px) {
        .tooltip-wrapper {
            display: none !important; /* hide info icon and tooltip wrapper on mobile */
        }
        .tooltip-wrapper .tooltip-icon {
            font-size: 1.15rem; /* larger icon on mobile */
            margin-left: 6px;
        }
        .tooltip-wrapper .tooltip-text {
            font-size: 0.95rem;
            max-width: 280px;
        }
    }

    /* Ensure supplier option text and icon are vertically centered */
    .supplier-option {
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: flex-start;
    }

    .supplier-option .supplier-option-text {
        display: inline-block;
        flex: 0 1 auto;
        min-width: 0; /* allow text to truncate if needed */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .tooltip-wrapper {
        display: inline-flex;
        align-items: center;
        flex: 0 0 auto;
        margin-left: 0px; /* moved slightly more left */
    }
                    </style>
                </div>

                <div id="othersDescriptionGroup" class="form-group" style="display: none;">
                    <label for="others_description">Please specify the type of request *</label>
                    <input type="text" name="others_description" id="others_description" placeholder="Enter the specific type of request">
                    <small class="form-text text-muted">Please provide a brief description of what this request is for.</small>
                </div>

                <div id="personCompanyGroup" class="form-group">
                    <label for="person_company">Person/Company Name *</label>
                    <!-- Text input for non-supplier request types -->
                    <input type="text" name="person_company" id="person_company" required>
                    
                    <!-- Searchable dropdown for supplier request types -->
                    <div id="person_company_select_container" class="supplier-select-container" style="display: none;">
                        <input type="text" id="person_company_search" class="form-control" placeholder="Search supplier..." autocomplete="off">
                        <select name="person_company_select" id="person_company_select" class="form-control" style="display: none;">
                            <option value="">-- Select Supplier --</option>
                        </select>
                        <div id="person_company_dropdown" class="supplier-dropdown" style="display: none;"></div>
                    </div>
                    <small id="person_company_auto_note" class="auto-populated-note" style="display: none; color: #28a745; font-style: italic; margin-top: 4px;">
                        <i class="fas fa-info-circle"></i> Bank-related fields are automatically populated based on chosen Person/Company Name
                    </small>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="department">Department *</label>
                        <input type="text" name="department" id="department" value="{{ user.department }}" readonly>
                    </div>

                    <div class="form-group">
                        <label for="date">Date of Submission</label>
                        <input type="text" name="date" id="date" value="{{ today }}" readonly style="background: #f5f5f5; cursor: not-allowed;">
                        <small style="color: #666;">Automatically set to today's date</small>
                    </div>
                </div>

                <div class="form-group">
                    <label for="purpose">Purpose/Description *</label>
                    <textarea name="purpose" id="purpose" rows="4" required></textarea>
                </div>

                <div class="form-group">
                    <label for="payment_method">Payment Method *</label>
                    <select name="payment_method" id="payment_method" required onchange="handlePaymentMethodChange()">
                        <option value="Card" selected>Card</option>
                        <option value="Cheque">Cheque</option>
                        <option value="Cash">Cash</option>
                    </select>
                </div>

                <div class="form-group" id="bank_name_group">
                    <label for="bank_name">Bank Name *</label>
                    <select name="bank_name" id="bank_name" required onchange="showSwiftCode()">
                        <option value="">-- Select Bank --</option>
                        <option value="Bank Dhofar">Bank Dhofar</option>
                        <option value="Bank Muscat">Bank Muscat</option>
                        <option value="National Bank of Oman">National Bank of Oman</option>
                        <option value="Oman Arab Bank">Oman Arab Bank</option>
                        <option value="Bank Sohar">Bank Sohar</option>
                        <option value="HSBC Bank Oman">HSBC Bank Oman</option>
                        <option value="Ahli Bank">Ahli Bank</option>
                        <option value="Oman Development Bank">Oman Development Bank</option>
                        <option value="Oman Housing Bank">Oman Housing Bank</option>
                        <option value="Meethaq Islamic Banking (Bank Dhofar)">Meethaq Islamic Banking (Bank Dhofar)</option>
                        <option value="Meethaq Islamic Banking (Bank Muscat)">Meethaq Islamic Banking (Bank Muscat)</option>
                        <option value="Muzn Islamic Banking (National Bank of Oman)">Muzn Islamic Banking (National Bank of Oman)</option>
                        <option value="Al Hilal Islamic Banking (Ahli Bank)">Al Hilal Islamic Banking (Ahli Bank)</option>
                        <option value="National Bank of Abu Dhabi">National Bank of Abu Dhabi</option>
                        <option value="Qatar National Bank">Qatar National Bank</option>
                        <option value="Standard Chartered Bank">Standard Chartered Bank</option>
                        <option value="Bank of Baroda">Bank of Baroda</option>
                        <option value="Bank of Beirut">Bank of Beirut</option>
                        <option value="State Bank of India">State Bank of India</option>
                        <option value="Habib Bank AG Zurich">Habib Bank AG Zurich</option>
                        <option value="Alizz Islamic Bank">Alizz Islamic Bank</option>
                        <option value="Sohar Islamic (Sohar Bank)">Sohar Islamic (Sohar Bank)</option>
                        <option value="Al Yusr Islamic Banking Services (Oman Arab Bank)">Al Yusr Islamic Banking Services (Oman Arab Bank)</option>
                        <option value="Bank Nizwa">Bank Nizwa</option>
                        <option value="Mashreq Bank">Mashreq Bank</option>
                    </select>
                    <small id="bank_name_auto_note" class="auto-populated-note" style="display: none; color: #28a745; font-style: italic; margin-top: 4px;">
                        <i class="fas fa-info-circle"></i> Automatically populated based on chosen Person/Company Name
                    </small>
                    <div id="swift-code-display" style="margin-top: 8px; padding: 10px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; display: none;">
                        <strong>SWIFT Code:</strong> <span id="swift-code-text"></span>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="account_name">Account Name *</label>
                        <input type="text" name="account_name" id="account_name" required>
                        <small id="account_name_auto_note" class="auto-populated-note" style="display: none; color: #28a745; font-style: italic; margin-top: 4px;">
                            <i class="fas fa-info-circle"></i> Automatically populated based on chosen Person/Company Name
                        </small>
                    </div>

                    <div class="form-group" id="account_number_group">
                        <label for="account_number">Account Number *</label>
                        <input type="text" name="account_number" id="account_number" pattern="[0-9]+" title="Please enter numbers only (maximum 16 digits)" required maxlength="16">
                        <small id="account_number_auto_note" class="auto-populated-note" style="display: none; color: #28a745; font-style: italic; margin-top: 4px;">
                            <i class="fas fa-info-circle"></i> Automatically populated based on chosen Person/Company Name
                        </small>
                        <small style="display: block; margin-top: 4px;">Numbers only (maximum 16 digits)</small>
                    </div>
                </div>

                <div class="form-group">
                    <label for="amount">Amount (OMR) *</label>
                    <div style="position: relative;">
                        <span style="position: absolute; left: 12px; top: 12px; color: #666; font-weight: 600;">OMR</span>
                        <input type="text" name="amount" id="amount" required style="padding-left: 55px;" placeholder="0.000">
                    </div>
                    <small>Omani Rials (OMR) - Numbers only (automatically formatted with commas)</small>
                    <small id="amount_auto_note" class="auto-populated-note" style="display: none; color: #28a745; font-style: italic; margin-top: 4px;">
                        <i class="fas fa-info-circle"></i> Amount has been automatically populated based on the current "Money Spent (since last finance refund)" value
                    </small>
                </div>

                <div class="form-group">
                    <label>Receipt/Proof of Payment (Optional)</label>
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <button type="button" id="add-files-btn" class="btn btn-primary" style="white-space: nowrap;">
                            <i class="fas fa-plus"></i> Add Files
                        </button>
                        <span style="color: #666; font-size: 14px;">
                            <i class="fas fa-info-circle" style="margin-right: 5px;"></i>
                            Click to select one or multiple files
                        </span>
                    </div>
                    <small>Upload multiple receipts or proof of payment (PDF, JPG, PNG, DOC, DOCX, XLS, XLSX - Max 50MB each)</small>
                    <div id="file-preview" style="margin-top: 10px;"></div>
                    
                    <!-- Hidden file input for actual file selection -->
                    <input type="file" name="receipt_files" id="receipt_files" accept=".pdf,.jpg,.jpeg,.png,.doc,.docx,.xls,.xlsx" multiple style="display: none;">
                </div>

                <!-- Show only for Supplier/Rental type -->
                <div id="recurringFields" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="recurring">Payment Type</label>
                            <select name="recurring" id="recurring" onchange="handleRecurringChange()">
                                <option value="One-Time">One-Time</option>
                                <option value="Recurring">Recurring</option>
                            </select>
                        </div>

                        <!-- Hidden field to store the custom recurring interval -->
                        <input type="hidden" name="recurring_interval" id="recurring_interval" value="">
                        
                        <!-- Hidden fields for variable amounts -->
                        <input type="hidden" name="variable_amounts" id="variable_amounts" value="false">
                        <input type="hidden" name="payment_schedule" id="payment_schedule" value="[]">
                        
                        <!-- Edit button - shown when Recurring is selected -->
                        <div id="configureButton" class="form-group" style="display: none; margin-top: 35px;">
                            <button type="button" class="btn btn-outline-primary" onclick="openRecurringModal()">
                                <i class="fas fa-edit"></i> Edit Payment Schedule
                                </button>
                        </div>
                    </div>

                    <!-- New Custom Repeat Modal -->
                    <div id="recurringModal" class="recurring-modal" style="display: none;">
                        <div class="recurring-modal-overlay" onclick="closeRecurringModal()"></div>
                        <div class="recurring-modal-container">
                            <div class="recurring-modal-header">
                                <div class="header-content">
                                    <i class="fas fa-calendar-alt"></i>
                                    <h2>Configure Recurring Payment</h2>
                                </div>
                                <button type="button" class="close-btn" onclick="closeRecurringModal()">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            
                            <div class="recurring-modal-body">
                                <!-- Payment Interval Tabs -->
                                <div class="interval-tabs">
                                    <button type="button" class="interval-tab active" id="monthlyTab" onclick="switchToMonthly()">
                                        <i class="fas fa-calendar-alt"></i>
                                        <span>Monthly</span>
                                    </button>
                                    <button type="button" class="interval-tab" id="customTab" onclick="switchToCustom()">
                                        <i class="fas fa-calendar-plus"></i>
                                        <span>Custom</span>
                                    </button>
                                </div>

                                <!-- Monthly Configuration -->
                                <div id="monthlyConfig" class="interval-config-content">
                                    <!-- Interval Configuration -->
                                    <div class="config-section">
                                        <h3><i class="fas fa-repeat"></i> Payment Schedule</h3>
                                        <div class="interval-config">
                                            <label>Every</label>
                                            <input type="number" id="intervalValue" value="1" min="1" max="99" onchange="updateSchedulePreview()">
                                            <span>month(s)</span>
                                        </div>
                                    </div>

                                <!-- Specific Options -->
                                <div class="config-section" id="specificOptions">
                                    <h3><i class="fas fa-cog"></i> Specific Settings</h3>
                                    

                                    <!-- Monthly Options -->
                                    <div id="monthlyOptions" class="specific-options">
                                        <div class="monthly-config">
                                            <div class="month-year-selector">
                                                <label>Select month and year:</label>
                                                <div class="date-selector">
                                                    <select id="monthSelect" onchange="updateCalendarDays()">
                                                        <option value="0">January</option>
                                                        <option value="1">February</option>
                                                        <option value="2">March</option>
                                                        <option value="3">April</option>
                                                        <option value="4">May</option>
                                                        <option value="5">June</option>
                                                        <option value="6">July</option>
                                                        <option value="7">August</option>
                                                        <option value="8">September</option>
                                                        <option value="9">October</option>
                                                        <option value="10">November</option>
                                                        <option value="11">December</option>
                                                    </select>
                                                    <select id="yearSelect" onchange="updateCalendarDays()">
                                                        <!-- Years will be populated by JavaScript -->
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="calendar-container">
                                                <label>Select starting date:</label>
                                                <div id="calendarGrid" class="calendar-grid">
                                                    <!-- Calendar will be generated by JavaScript -->
                                        </div>
                                    </div>

                                            <!-- End Date Selection -->
                                            <div class="end-date-section" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e0e0e0;">
                                                <h4 style="margin-bottom: 1rem; color: #333; font-size: 1rem;">
                                                    <i class="fas fa-calendar-times"></i> End Date (Optional)
                                                </h4>
                                                <div class="end-date-config">
                                                    <div class="end-date-toggle" style="margin-bottom: 1rem;">
                                                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                                            <input type="checkbox" id="endDateToggle" onchange="toggleEndDate()" style="margin: 0;">
                                                            <span>Set an end date for this recurring payment</span>
                                                </label>
                                            </div>
                                                    
                                                    <div id="endDateSection" style="display: none;">
                                                        <div class="end-date-selector">
                                                            <label>Select end month and year (automatically set to 30th of the month):</label>
                                                            <div class="date-selector">
                                                                <select id="endMonthSelect" onchange="updateSchedulePreview()">
                                                                    <option value="0">January</option>
                                                                    <option value="1">February</option>
                                                                    <option value="2">March</option>
                                                                    <option value="3">April</option>
                                                                    <option value="4">May</option>
                                                                    <option value="5">June</option>
                                                                    <option value="6">July</option>
                                                                    <option value="7">August</option>
                                                                    <option value="8">September</option>
                                                                    <option value="9">October</option>
                                                                    <option value="10">November</option>
                                                                    <option value="11">December</option>
                                                                </select>
                                                                <select id="endYearSelect" onchange="updateSchedulePreview()">
                                                                    <!-- Years will be populated by JavaScript -->
                                                                </select>
                                        </div>
                                    </div>

                                                        <div class="end-date-display" style="margin-top: 1rem; padding: 0.75rem; background-color: #f5f5f5; border-radius: 4px;">
                                                            <p style="margin: 0; color: #666;">
                                                                <i class="fas fa-info-circle"></i> 
                                                                <strong>End Date:</strong> <span id="endDateDisplay">30th of selected month/year</span>
                                                            </p>
                                                        </div>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                    </div>

                                </div>

                                <!-- Variable Amount Configuration (Monthly only) -->
                                <div class="config-section">
                                    <h3><i class="fas fa-money-bill-wave"></i> Variable Amounts</h3>
                                    <div class="variable-amount-config">
                                        <div class="amount-toggle">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="variableAmountsToggle" onchange="toggleVariableAmounts()">
                                                <span class="toggle-slider"></span>
                                            </label>
                                            <span class="toggle-label">Use different amounts for each payment</span>
                                        </div>
                                        
                                        <div id="variableAmountsSection" class="variable-amounts-section" style="display: none;">
                                            <div class="total-amount-display">
                                                <label>Total Amount: <span id="totalAmountDisplay">0</span> OMR</label>
                                            </div>
                                            
                                            <div class="payment-amounts-container">
                                                <div id="paymentAmountsList" class="payment-amounts-list">
                                                    <!-- Payment amount inputs will be generated here -->
                                                </div>
                                                
                                                <div class="add-payment-section">
                                                    <button type="button" id="addPaymentBtn" class="btn-add-payment" onclick="addNewPayment()">
                                                        <i class="fas fa-plus"></i> Add Payment
                                                    </button>
                                                </div>
                                            </div>
                                            
                                            <div class="amount-summary">
                                                <div class="summary-row">
                                                    <span>Total Allocated:</span>
                                                    <span id="totalAllocated">0.000</span> OMR
                                                </div>
                                                <div class="summary-row">
                                                    <span>Remaining:</span>
                                                    <span id="remainingAmount">0.000</span> OMR
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                </div>

                                <!-- Custom Configuration -->
                                <div id="customConfig" class="interval-config-content" style="display: none;">
                                    <div class="config-section">
                                        <h3><i class="fas fa-calendar-plus"></i> Custom Payment Schedule</h3>
                                        <div class="custom-date-config">
                                            <div class="custom-dates-header">
                                                <label>Add custom payment dates:</label>
                                                <button type="button" class="btn-add-date" onclick="addCustomDate()">
                                                    <i class="fas fa-plus"></i> Add Date
                                                </button>
                                            </div>
                                            
                                            <div id="customDatesList" class="custom-dates-list">
                                                <!-- Custom dates will be added here -->
                                            </div>
                                            
                                            <div class="custom-dates-info">
                                                <p><i class="fas fa-info-circle"></i> Add specific dates for your payment schedule. You can add as many dates as needed.</p>
                                            </div>
                                            
                                            <!-- Custom Amount Summary -->
                                            <div class="custom-amount-summary">
                                                <div class="summary-row">
                                                    <span>Total Amount:</span>
                                                    <span id="customTotalAmount">0.000</span> OMR
                                                </div>
                                                <div class="summary-row">
                                                    <span>Total Allocated:</span>
                                                    <span id="customTotalAllocated">0.000</span> OMR
                                                </div>
                                                <div class="summary-row">
                                                    <span>Remaining:</span>
                                                    <span id="customRemainingAmount">0.000</span> OMR
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Schedule Preview -->
                                <div class="config-section">
                                    <h3><i class="fas fa-eye"></i> Preview</h3>
                                    <div class="schedule-preview">
                                        <div class="preview-content">
                                            <i class="fas fa-calendar-check"></i>
                                            <div class="preview-text">
                                                <strong>Payment Schedule:</strong>
                                                <span id="schedulePreview">Every month</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="recurring-modal-footer">
                                <button type="button" class="btn-start-fresh" onclick="clearSavedPreferences()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px;">
                                    <i class="fas fa-refresh"></i> Start Fresh
                                </button>
                                <button type="button" class="btn-save" onclick="saveRecurringConfig()">
                                    <i class="fas fa-check"></i> Save Configuration
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-actions">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        {% if draft %}
                        <button type="button" class="btn btn-success" onclick="saveConfigurationBeforeSubmit(); submitDraft(); return false;" style="background:#28a745;border-color:#28a745;color:#ffffff;">
                            <i class="fas fa-paper-plane"></i> Submit Draft
                        </button>
                        {% else %}
                        <button type="submit" class="btn btn-success" onclick="saveConfigurationBeforeSubmit()" style="background:#28a745;border-color:#28a745;color:#ffffff;">
                            <i class="fas fa-paper-plane"></i> Submit Request
                        </button>
                        {% endif %}
                        <button type="button" class="btn btn-secondary" onclick="saveAsDraft()" style="background-color: #6c757d; border-color: #6c757d;">
                            <i class="fas fa-save"></i> Save as Draft
                        </button>
                    </div>
                    <a href="{% if draft %}{{ url_for('drafts') }}{% else %}{{ url_for('dashboard') }}{% endif %}" class="btn btn-secondary">
                        <i class="fas fa-times"></i> Cancel
                    </a>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Supplier options mapping by department and request type
// Structure: { department: { requestType: [options] } }
const supplierOptions = {
    'Finance': {
        'Freshener Supplier': ['Dr. Scent'],
        'Water Supplier': ['Tanker', 'Ain Oman'],
        'Cleaning Supplier': ['Al-Naba', 'Creative Icon'],
        'Furniture Supplier': ['Ultimate Furnishing'],
        'Customer Service': ['Lubek'],
        'Gas Supplier': ['Muscat Gas Supplier', 'Al Amerat Gas Supplier', 'Nizwa Gas Supplier', 'Rustaq Gas Supplier', 'Al-Swaiq Gas Supplier', 'Sohar Gas Supplier', 'Al Amer Sohar City Center Gas Supplier', 'Golden Quality Gas'],
        'Food Supplier': ['Al Amer Oman Mall Supplier', 'Al-Ismaily', 'Chef Middle East', 'Al Amer Majestic', 'Bid Food', 'Al Khan (PRF)'],
        'Spices Supplier': ['Gazal Al Khadara'],
        'Soft Drinks Supplier': ['Adhwa Al-Billa Drinks', 'Oman Refreshment'],
        'Pest Control': ['Al-Shuhoomi'],
        'Bakery': ['Al-Amin', 'Bakery LLC', 'Asalat Al Duqum'],
        'Oil Supplier': ['Areej Oil'],
        'Maintenance': ['Al-Bashiq'],
        'Vegetable/Fruits Supplier': ['Alsadeen (Jalapeno)', 'Sindal', 'Sohol Al-Fiha', 'Al-Sowgra'],
        'Cheese Supplier': ['Gulf Technical'],
        'Syrup Supplier': ['Catering Solution'],
        'Packing/Printing': ['Oman Printer', 'Al-Madenah', 'Excellent Packing', 'Al Andalus', 'Al Khalijia Company for Converting Industries'],
        'Plastics Supplier': ['Al-Mera', 'Hotpack'],
        'Garbage Plastic Supplier': ['Ariq'],
        'Petrol': ['Oman Oil'],
        'Utilities Expenses': ['Majid Al Futaim (Oman Mall)', 'Majid Al Futaim (Avenues Mall)', 'Majid Al Futaim (City Center Qurum)', 'Majid Al Futaim (City Center Sohar)', 'IBN Arshad Trading'],
        'Rental Expenses': ['Majid Al Futaim (Oman Mall)', 'Majid Al Futaim (Avenues Mall)', 'Majid Al Futaim (City Center Qurum)', 'Majid Al Futaim (City Center Sohar)'],
        'Salary Expenses': ['Noora Al Khadhouri'],
        'Social Insurance': ['SPF']
    }
    // Add other departments here as needed
    // Example:
    // 'HR': {
    //     'Salary Expenses': ['Company A', 'Company B']
    // }
};

// Date is already set to today's date in the template, no need to set it here

// Add event listener for amount field changes
const amountField = document.getElementById('amount');
if (amountField) {
    amountField.addEventListener('input', function() {
        // If variable amounts are enabled, update the total amount display
        const variableAmountsToggle = document.getElementById('variableAmountsToggle');
        if (variableAmountsToggle && variableAmountsToggle.checked) {
            const totalAmount = parseFloat(this.value) || 0;
            const totalAmountDisplay = document.getElementById('totalAmountDisplay');
            if (totalAmountDisplay) {
                totalAmountDisplay.textContent = totalAmount.toFixed(3);
            }
            updateAmountSummary();
        }
    });
}

// Handle payment method change - hide/show account number and bank name fields
function handlePaymentMethodChange() {
    const paymentMethod = document.getElementById('payment_method');
    const accountNumberGroup = document.getElementById('account_number_group');
    const accountNumberInput = document.getElementById('account_number');
    const bankNameGroup = document.getElementById('bank_name_group');
    const bankNameInput = document.getElementById('bank_name');
    
    if (paymentMethod && accountNumberGroup && accountNumberInput) {
        if (paymentMethod.value === 'Cheque') {
            // Hide account number field when Cheque is selected
            accountNumberGroup.style.display = 'none';
            accountNumberInput.removeAttribute('required');
            accountNumberInput.removeAttribute('pattern'); // Remove pattern validation
            accountNumberInput.value = ''; // Clear the value
            // Show bank name field for Cheque
            if (bankNameGroup) bankNameGroup.style.display = 'block';
            if (bankNameInput) {
                bankNameInput.setAttribute('required', 'required');
            }
        } else if (paymentMethod.value === 'Cash') {
            // Hide account number field when Cash is selected, but keep bank name
            accountNumberGroup.style.display = 'none';
            accountNumberInput.removeAttribute('required');
            accountNumberInput.removeAttribute('pattern');
            accountNumberInput.value = ''; // Clear the value
            // Show bank name field for Cash (still required)
            if (bankNameGroup) bankNameGroup.style.display = 'block';
            if (bankNameInput) {
                bankNameInput.setAttribute('required', 'required');
            }
        } else {
            // Show account number and bank name fields when Card is selected
            accountNumberGroup.style.display = 'block';
            accountNumberInput.setAttribute('required', 'required');
            accountNumberInput.setAttribute('pattern', '[0-9]+'); // Restore pattern validation
            // Show bank name field for Card
            if (bankNameGroup) bankNameGroup.style.display = 'block';
            if (bankNameInput) {
                bankNameInput.setAttribute('required', 'required');
            }
        }
    }
}

// New Recurring Modal JavaScript
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the modal
    initializeRecurringModal();
    
    // Initialize searchable branch dropdown
    initializeBranchSearch();
    
    // Ensure SWIFT code updates when bank name changes
    const bankSelect = document.getElementById('bank_name');
    if (bankSelect) {
        // Add event listener in addition to inline onchange for reliability
        bankSelect.addEventListener('change', showSwiftCode);
        // Also call it initially in case a bank is already selected
        showSwiftCode();
    }
    
    // Initialize payment method handler
    handlePaymentMethodChange();
    
    // Add event listeners to account fields to clear auto-populated flag on manual edit
    const accountNameInput = document.getElementById('account_name');
    const accountNumberInput = document.getElementById('account_number');
    const bankNameInput = document.getElementById('bank_name');
    
    if (accountNameInput) {
        const accountNameNote = document.getElementById('account_name_auto_note');
        accountNameInput.addEventListener('input', function() {
            // Clear auto-populated flag when user manually edits
            this.dataset.autoPopulated = 'false';
            // Hide note when manually edited
            if (accountNameNote) accountNameNote.style.display = 'none';
        });
        accountNameInput.addEventListener('focus', function() {
            // If field is empty or was auto-populated, allow user to edit
            if (!this.value || this.dataset.autoPopulated === 'true') {
                this.dataset.autoPopulated = 'false';
                // Hide note when user starts editing
                if (accountNameNote) accountNameNote.style.display = 'none';
            }
        });
    }
    
    // Add event listeners to amount field to clear auto-populated flag on manual edit
    const amountInput = document.getElementById('amount');
    if (amountInput) {
        const amountNote = document.getElementById('amount_auto_note');
        amountInput.addEventListener('input', function() {
            // Clear auto-populated flag when user manually edits
            // Only hide note if the value was actually changed (not just focused)
            if (this.dataset.autoPopulated === 'true') {
                this.dataset.autoPopulated = 'false';
                // Hide note when manually edited
                if (amountNote) amountNote.style.display = 'none';
            }
        });
        // Note: We don't add a 'focus' event listener so the note stays visible when clicking
    }
    
    if (accountNumberInput) {
        const accountNumberNote = document.getElementById('account_number_auto_note');
        accountNumberInput.addEventListener('input', function() {
            // Clear auto-populated flag when user manually edits
            this.dataset.autoPopulated = 'false';
            // Hide note when manually edited
            if (accountNumberNote) accountNumberNote.style.display = 'none';
        });
        accountNumberInput.addEventListener('focus', function() {
            // If field is empty or was auto-populated, allow user to edit
            if (!this.value || this.dataset.autoPopulated === 'true') {
                this.dataset.autoPopulated = 'false';
                // Hide note when user starts editing
                if (accountNumberNote) accountNumberNote.style.display = 'none';
            }
        });
    }
    
    if (bankNameInput) {
        const bankNameNote = document.getElementById('bank_name_auto_note');
        bankNameInput.addEventListener('change', function() {
            // Clear auto-populated flag when user manually edits
            this.dataset.autoPopulated = 'false';
            // Hide note when manually edited
            if (bankNameNote) bankNameNote.style.display = 'none';
        });
        bankNameInput.addEventListener('focus', function() {
            // If field is empty or was auto-populated, allow user to edit
            if (!this.value || this.dataset.autoPopulated === 'true') {
                this.dataset.autoPopulated = 'false';
                // Hide note when user starts editing
                if (bankNameNote) bankNameNote.style.display = 'none';
            }
        });
    }
    
    // Function to clear auto-populated bank-related fields (make it globally accessible)
    window.clearAutoPopulatedBankFields = function() {
        const accountNameInput = document.getElementById('account_name');
        const accountNumberInput = document.getElementById('account_number');
        const bankNameInput = document.getElementById('bank_name');
        const accountNameNote = document.getElementById('account_name_auto_note');
        const accountNumberNote = document.getElementById('account_number_auto_note');
        const bankNameNote = document.getElementById('bank_name_auto_note');
        const personCompanyNote = document.getElementById('person_company_auto_note');
        
        if (accountNameInput && accountNameInput.dataset.autoPopulated === 'true') {
            accountNameInput.value = '';
            accountNameInput.dataset.autoPopulated = 'false';
            if (accountNameNote) accountNameNote.style.display = 'none';
        }
        
        if (accountNumberInput && accountNumberInput.dataset.autoPopulated === 'true') {
            accountNumberInput.value = '';
            accountNumberInput.dataset.autoPopulated = 'false';
            if (accountNumberNote) accountNumberNote.style.display = 'none';
        }
        
        if (bankNameInput && bankNameInput.dataset.autoPopulated === 'true') {
            bankNameInput.value = '';
            bankNameInput.dataset.autoPopulated = 'false';
            if (bankNameNote) bankNameNote.style.display = 'none';
            // Hide SWIFT code display if it was shown
            if (typeof showSwiftCode === 'function') {
                showSwiftCode();
            }
        }
        
        // Hide Person/Company Name note when fields are cleared
        if (personCompanyNote) personCompanyNote.style.display = 'none';
    };
    
    // Add event listener to person_company text input (for non-supplier request types)
    const personCompanyInput = document.getElementById('person_company');
    const personCompanyNote = document.getElementById('person_company_auto_note');
    if (personCompanyInput) {
        personCompanyInput.addEventListener('input', function() {
            // If the field is cleared or changed, clear auto-populated bank fields
            if (!this.value.trim()) {
                clearAutoPopulatedBankFields();
                // Hide note
                if (personCompanyNote) personCompanyNote.style.display = 'none';
            }
        });
        
        personCompanyInput.addEventListener('change', function() {
            // If the field is cleared or changed, clear auto-populated bank fields
            if (!this.value.trim()) {
                clearAutoPopulatedBankFields();
                // Hide note
                if (personCompanyNote) personCompanyNote.style.display = 'none';
            }
        });
    }
    
    // Add event listener to person_company_search (for supplier dropdown)
    const personCompanySearch = document.getElementById('person_company_search');
    if (personCompanySearch) {
        personCompanySearch.addEventListener('input', function() {
            // If the search field is cleared, clear auto-populated bank fields
            if (!this.value.trim()) {
                const hiddenSelect = document.getElementById('person_company_select');
                if (hiddenSelect && !hiddenSelect.value) {
                    clearAutoPopulatedBankFields();
                    // Hide note
                    if (personCompanyNote) personCompanyNote.style.display = 'none';
                }
            }
        });
        
        // Also listen for when the hidden select value changes
        const personCompanySelect = document.getElementById('person_company_select');
        if (personCompanySelect) {
            // Store the previous value to detect changes
            let previousValue = personCompanySelect.value;
            
            // Use MutationObserver to detect when the value changes
            const observer = new MutationObserver(function() {
                const currentValue = personCompanySelect.value;
                if (currentValue !== previousValue) {
                    // Value changed - if it's empty, clear auto-populated fields
                    if (!currentValue) {
                        clearAutoPopulatedBankFields();
                        // Hide note
                        if (personCompanyNote) personCompanyNote.style.display = 'none';
                    }
                    previousValue = currentValue;
                }
            });
            
            observer.observe(personCompanySelect, {
                attributes: true,
                attributeFilter: ['value']
            });
            
            // Also listen for change events
            personCompanySelect.addEventListener('change', function() {
                if (!this.value) {
                    clearAutoPopulatedBankFields();
                    // Hide note
                    if (personCompanyNote) personCompanyNote.style.display = 'none';
                }
            });
        }
    }
});

function initializeBranchSearch() {
    const searchInput = document.getElementById('branch_search');
    const hiddenSelect = document.getElementById('branch_name');
    const dropdown = document.getElementById('branch_dropdown');
    const chipsContainer = document.getElementById('branch_chips_container');
    const hiddenInput = document.getElementById('branch_names');
    
    if (!searchInput || !hiddenSelect || !dropdown || !chipsContainer || !hiddenInput) return;
    
    // Array to store selected branches {value: string, text: string}
    let selectedBranches = [];
    
    // Flag to track if we're clicking on an option
    let clickingOnOption = false;
    let blurTimeout = null;
    
    // Flag to prevent dropdown from opening during initial draft population
    let suppressDropdownOpen = false;
    
    // Function to update chips display
    function updateChips() {
        chipsContainer.innerHTML = '';
        selectedBranches.forEach((branch, index) => {
            const chip = document.createElement('div');
            chip.className = 'branch-chip';
            chip.innerHTML = `
                <span>${branch.text}</span>
                <button type="button" class="remove-chip" onclick="removeBranchChip(${index})" title="Remove branch"></button>
            `;
            chipsContainer.appendChild(chip);
        });
        
        // Update hidden input with comma-separated values
        hiddenInput.value = selectedBranches.map(b => b.value).join(',');
    }
    
    // Function to remove a branch chip
    window.removeBranchChip = function(index) {
        selectedBranches.splice(index, 1);
        updateChips();
        updateDropdownSelection();
    };
    
    // Function to update dropdown to show selected branches
    function updateDropdownSelection() {
        const options = dropdown.querySelectorAll('.branch-option');
        options.forEach(option => {
            const value = option.getAttribute('data-value');
            const isSelected = selectedBranches.some(b => b.value === value);
            if (isSelected) {
                option.classList.add('selected');
            } else {
                option.classList.remove('selected');
            }
        });
    }
    
    // Build dropdown from select options
    function buildDropdown() {
        dropdown.innerHTML = '';
        const options = hiddenSelect.querySelectorAll('option');
        let currentGroup = null;
        
        options.forEach(option => {
            if (option.value === '') return; // Skip placeholder
            
            const restaurant = option.getAttribute('data-restaurant') || 'Other';
            
            // Create group header if needed
            if (!currentGroup || currentGroup !== restaurant) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'branch-group';
                groupDiv.textContent = restaurant + ' (Location)';
                groupDiv.setAttribute('data-restaurant', restaurant);
                dropdown.appendChild(groupDiv);
                currentGroup = restaurant;
            }
            
            // Create option
            const optionDiv = document.createElement('div');
            optionDiv.className = 'branch-option';
            optionDiv.textContent = option.textContent;
            optionDiv.setAttribute('data-value', option.value);
            optionDiv.setAttribute('data-restaurant', restaurant);
            
            let optionHandled = false;
            let optionTimeout = null;
            
            // Function to handle option selection with debouncing
            function handleOptionSelection(e) {
                if (optionHandled) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                clickingOnOption = true;
                optionHandled = true;
                selectBranch(option.value, option.textContent);
                
                // Clear any existing timeout
                if (optionTimeout) {
                    clearTimeout(optionTimeout);
                }
                
                // Reset flag after a delay to allow for soft touches
                optionTimeout = setTimeout(() => {
                    optionHandled = false;
                }, 400);
            }
            
            // Use mousedown for better trackpad support (fires before blur)
            // This works for both mouse and most trackpad interactions
            optionDiv.addEventListener('mousedown', handleOptionSelection, { passive: false });
            
            // Support for touch devices and trackpads (soft touches)
            optionDiv.addEventListener('touchstart', handleOptionSelection, { passive: false });
            
            // Pointer events for better cross-device support (including soft trackpad touches)
            optionDiv.addEventListener('pointerdown', function(e) {
                // Handle all pointer types, including soft touches
                handleOptionSelection(e);
            }, { passive: false });
            
            // Mouseup as additional fallback for soft trackpad touches
            // Some soft touches might not trigger mousedown but will trigger mouseup
            optionDiv.addEventListener('mouseup', function(e) {
                // Only handle if mousedown didn't already handle it
                setTimeout(() => {
                    if (!optionHandled) {
                        handleOptionSelection(e);
                    }
                }, 10);
            }, { passive: false });
            
            // Touchend as fallback for soft touches
            optionDiv.addEventListener('touchend', function(e) {
                // Only handle if touchstart didn't already handle it
                setTimeout(() => {
                    if (!optionHandled) {
                        handleOptionSelection(e);
                    }
                }, 10);
            }, { passive: false });
            
            // Keep click as final fallback for accessibility and edge cases
            optionDiv.addEventListener('click', function(e) {
                // Only handle if no other event handled it
                setTimeout(() => {
                    if (!optionHandled && !clickingOnOption) {
                        handleOptionSelection(e);
                    }
                }, 50);
            }, { passive: false });
            
            dropdown.appendChild(optionDiv);
        });
        
        updateDropdownSelection();
    }
    
    // Make selectBranch globally accessible for draft pre-fill
    window.selectBranch = function(value, text) {
        // Clear any pending blur timeout
        if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = null;
        }
        
        // Check if branch is already selected - if so, remove it (toggle behavior)
        const existingIndex = selectedBranches.findIndex(b => b.value === value);
        if (existingIndex !== -1) {
            // Branch already selected, remove it
            selectedBranches.splice(existingIndex, 1);
            updateChips();
            updateDropdownSelection();
            
            // Only open dropdown if not suppressed (during draft population)
            if (!suppressDropdownOpen) {
                // Clear search input but keep dropdown open so user can continue selecting
                searchInput.value = '';
                dropdown.style.display = 'block';
                // Re-focus after a small delay to ensure it works with soft touches
                setTimeout(() => {
                    searchInput.focus();
                }, 50);
            }
            
            // Reset flag after a delay to allow for soft trackpad touches
            setTimeout(() => {
                clickingOnOption = false;
            }, 200);
            return;
        }
        
        // Add to selected branches
        selectedBranches.push({ value: value, text: text });
        updateChips();
        updateDropdownSelection();
        
        // Only open dropdown if not suppressed (during draft population)
        if (!suppressDropdownOpen) {
            // Clear search input but keep dropdown open so user can continue selecting
            searchInput.value = '';
            dropdown.style.display = 'block';
            // Re-focus after a small delay to ensure it works with soft touches
            setTimeout(() => {
                searchInput.focus();
            }, 50);
        }
        
        // Reset flag after a delay to allow for soft trackpad touches
        setTimeout(() => {
            clickingOnOption = false;
        }, 200);
    }
    
    // Expose the suppressDropdownOpen flag globally so draft loading can use it
    window.setSuppressDropdownOpen = function(value) {
        suppressDropdownOpen = value;
    };
    
    function filterBranches(searchTerm) {
        const options = dropdown.querySelectorAll('.branch-option');
        const groups = dropdown.querySelectorAll('.branch-group');
        
        let hasVisibleOptions = false;
        
        options.forEach(option => {
            const text = option.textContent.toLowerCase();
            const restaurant = option.getAttribute('data-restaurant').toLowerCase();
            const matches = text.includes(searchTerm.toLowerCase()) || restaurant.includes(searchTerm.toLowerCase());
            
            if (matches) {
                option.classList.remove('hidden');
                hasVisibleOptions = true;
            } else {
                option.classList.add('hidden');
            }
        });
        
        // Show/hide groups based on visible options
        groups.forEach(group => {
            const restaurant = group.getAttribute('data-restaurant');
            const hasVisibleOptionsInGroup = Array.from(options).some(option => 
                option.getAttribute('data-restaurant') === restaurant && !option.classList.contains('hidden')
            );
            
            if (hasVisibleOptionsInGroup) {
                group.style.display = 'block';
            } else {
                group.style.display = 'none';
            }
        });
        
        dropdown.style.display = hasVisibleOptions ? 'block' : 'none';
    }
    
    // Event listeners
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.trim();
        if (searchTerm.length > 0) {
            filterBranches(searchTerm);
        } else {
            // Show all options when search is empty
            dropdown.querySelectorAll('.branch-option').forEach(option => {
                option.classList.remove('hidden');
            });
            dropdown.querySelectorAll('.branch-group').forEach(group => {
                group.style.display = 'block';
            });
            dropdown.style.display = 'block';
        }
    });
    
    searchInput.addEventListener('focus', function() {
        if (this.value.trim() === '') {
            dropdown.style.display = 'block';
        }
    });
    
    searchInput.addEventListener('blur', function() {
        // Delay hiding to allow clicks on options (especially for soft trackpad touches)
        // Clear any existing timeout first
        if (blurTimeout) {
            clearTimeout(blurTimeout);
        }
        blurTimeout = setTimeout(() => {
            // Only hide if not clicking on an option
            // Give extra time for soft touches that might have delayed event firing
            if (!clickingOnOption) {
                dropdown.style.display = 'none';
            }
            blurTimeout = null;
        }, 300); // Increased timeout for better soft trackpad support
    });
    
    // Also prevent blur on mousedown/touchstart on dropdown options
    dropdown.addEventListener('mousedown', function(e) {
        e.preventDefault();
    });
    
    dropdown.addEventListener('touchstart', function(e) {
        e.preventDefault();
    });
    
    dropdown.addEventListener('pointerdown', function(e) {
        e.preventDefault();
    });
    
    // Hide dropdown when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !dropdown.contains(e.target) && !chipsContainer.contains(e.target)) {
            dropdown.style.display = 'none';
        }
    });
    
    // Also handle touch events for better mobile/trackpad support
    document.addEventListener('touchend', function(e) {
        if (!searchInput.contains(e.target) && !dropdown.contains(e.target) && !chipsContainer.contains(e.target)) {
            dropdown.style.display = 'none';
        }
    });
    
    // Initialize dropdown
    buildDropdown();
    updateChips();
}

function handleRequestTypeChange() {
    const requestType = document.getElementById('request_type').value;
    const recurringFields = document.getElementById('recurringFields');
    
    // Hide others description field first
    document.getElementById('othersDescriptionGroup').style.display = 'none';
    
    // Remove required attribute from others description field
    document.getElementById('others_description').required = false;
    
    // Person/Company Name field is always visible and required
    document.getElementById('personCompanyGroup').style.display = 'block';
    
    // Get department from the form
    const department = document.getElementById('department').value;
    
    const personCompanyInput = document.getElementById('person_company');
    const personCompanyContainer = document.getElementById('person_company_select_container');
    const personCompanySelect = document.getElementById('person_company_select');
    const personCompanySearch = document.getElementById('person_company_search');
    const personCompanyNote = document.getElementById('person_company_auto_note');
    
    // Clear person/company name field when request type changes
    if (personCompanyInput) {
        personCompanyInput.value = '';
    }
    if (personCompanySearch) {
        personCompanySearch.value = '';
    }
    if (personCompanySelect) {
        personCompanySelect.value = '';
    }
    
    // Hide Person/Company Name note
    if (personCompanyNote) {
        personCompanyNote.style.display = 'none';
    }
    
    // Clear auto-populated bank-related fields
    if (typeof window.clearAutoPopulatedBankFields === 'function') {
        window.clearAutoPopulatedBankFields();
    }
    
    // Reset supplier selection tracking if it exists
    if (window.supplierSearchInitialized) {
        // Try to access the currentSelectedSupplier from the supplier search scope
        // We'll reset it when initializeSupplierSearch is called again
    }
    
    // By default, show the simple text input (fallback) and hide supplier container.
    // If supplier options exist for the selected department + request type, we'll
    // switch to the searchable dropdown below.
    if (personCompanyInput) {
        personCompanyInput.style.display = 'block';
        personCompanyInput.required = true;
    }
    if (personCompanyContainer) {
        personCompanyContainer.style.display = 'none';
    }
    
    // Show appropriate field based on request type
    if (requestType === 'Others') {
        // Show others description field
        document.getElementById('othersDescriptionGroup').style.display = 'block';
        document.getElementById('others_description').required = true;
    }
    
    // Always show Payment Type dropdown for all request types
    recurringFields.style.display = 'block';
    
    // Handle auto-population of amount for "Bank money" request type (Procurement Department Manager only)
    const amountInput = document.getElementById('amount');
    const amountNote = document.getElementById('amount_auto_note');
    const userDepartment = department || '{{ user.department if user else "" }}';
    const userRole = '{{ user.role if user else "" }}';
    
    if (requestType === 'Bank money' && userDepartment === 'Procurement' && userRole === 'Department Manager') {
        // Fetch current money spent value and auto-populate amount
        fetch('/api/procurement/money-spent')
            .then(response => response.json())
            .then(data => {
                if (data.money_spent !== undefined && amountInput) {
                    // Format the amount with commas (3 decimal places)
                    const formattedAmount = parseFloat(data.money_spent).toFixed(3).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    amountInput.value = formattedAmount;
                    amountInput.dataset.autoPopulated = 'true';
                    // Show the note
                    if (amountNote) {
                        amountNote.style.display = 'block';
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching money spent:', error);
            });
    } else {
        // Clear auto-populated flag and hide note if not "Bank money"
        if (amountInput && amountInput.dataset.autoPopulated === 'true') {
            amountInput.value = '';
            amountInput.dataset.autoPopulated = 'false';
        }
        if (amountNote) {
            amountNote.style.display = 'none';
        }
    }
    
    // If we have a department and a request type, try to fetch supplier/person options.
    // populateSupplierOptions now returns a Promise that resolves with the fetched options.
    if (department && requestType) {
        populateSupplierOptions(department, requestType)
            .then(options => {
                if (options && options.length > 0) {
                    // There are options available -> show supplier search/select and hide text input
                    if (personCompanyContainer) personCompanyContainer.style.display = 'block';
                    if (personCompanyInput) {
                        personCompanyInput.style.display = 'none';
                        personCompanyInput.required = false;
                    }
                    // Ensure supplier search is initialized once
                    if (!window.supplierSearchInitialized) {
                        initializeSupplierSearch();
                        window.supplierSearchInitialized = true;
                    } else if (typeof window.buildSupplierDropdown === 'function') {
                        // Rebuild dropdown to reflect new options
                        window.buildSupplierDropdown();
                    }
                } else {
                    // No options -> keep the simple text input visible
                    if (personCompanyContainer) personCompanyContainer.style.display = 'none';
                    if (personCompanyInput) {
                        personCompanyInput.style.display = 'block';
                        personCompanyInput.required = true;
                    }
                }
            })
            .catch(err => {
                console.error('Error fetching person/company options:', err);
                // On error, fall back to text input
                if (personCompanyContainer) personCompanyContainer.style.display = 'none';
                if (personCompanyInput) {
                    personCompanyInput.style.display = 'block';
                    personCompanyInput.required = true;
                }
            });
    }
}

function populateSupplierOptions(department, requestType) {
    const select = document.getElementById('person_company_select');
    const searchInput = document.getElementById('person_company_search');
    
    // Clear existing options
    select.innerHTML = '<option value="">-- Select Supplier --</option>';
    
    // Fetch options from API
    if (department && requestType) {
        return fetch(`/api/person-company-options?department=${encodeURIComponent(department)}&request_type=${encodeURIComponent(requestType)}`)
            .then(response => response.json())
            .then(data => {
                const options = data.options || [];
                
                // Store options data for account auto-population
                if (!window.supplierOptionsData) {
                    window.supplierOptionsData = {};
                }
                
                // Add options
                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    const optionName = typeof option === 'string' ? option : option.name;
                    optionElement.value = optionName;
                    optionElement.textContent = optionName;
                    
                    // Store account information if available
                    if (typeof option === 'object') {
                        if (option.account_name) optionElement.setAttribute('data-account-name', option.account_name);
                        if (option.account_number) optionElement.setAttribute('data-account-number', option.account_number);
                        if (option.bank_name) optionElement.setAttribute('data-bank-name', option.bank_name);
                        if (option.description) optionElement.setAttribute('data-description', option.description);

                        window.supplierOptionsData[optionName] = {
                            account_name: option.account_name || '',
                            account_number: option.account_number || '',
                            bank_name: option.bank_name || '',
                            description: option.description || ''
                        };
                    }
                    
                    select.appendChild(optionElement);
                });
                
                // Clear search input
                if (searchInput) {
                    searchInput.value = '';
                }
                
                // Rebuild dropdown if supplier search is initialized
                if (window.supplierSearchInitialized && typeof window.buildSupplierDropdown === 'function') {
                    window.buildSupplierDropdown();
                }

                // Return options array for caller to decide visibility
                return options;
            })
            .catch(error => {
                console.error('Error fetching supplier options:', error);
                // Clear search input on error
                if (searchInput) {
                    searchInput.value = '';
                }
                return [];
            });
    } else {
        // Clear search input if no department/request type
        if (searchInput) {
            searchInput.value = '';
        }
        return Promise.resolve([]);
    }
}

function initializeSupplierSearch() {
    const searchInput = document.getElementById('person_company_search');
    const hiddenSelect = document.getElementById('person_company_select');
    const dropdown = document.getElementById('person_company_dropdown');
    
    if (!searchInput || !hiddenSelect || !dropdown) return;
    
    // Flag to track if we're clicking on an option
    let clickingOnOption = false;
    let blurTimeout = null;
    // Track currently selected supplier
    let currentSelectedSupplier = null;
    
    // Build dropdown from select options
    function buildSupplierDropdown() {
        dropdown.innerHTML = '';
        const options = hiddenSelect.querySelectorAll('option');
        
            options.forEach(option => {
            if (option.value === '') return; // Skip placeholder
            
            // Create option
            const optionDiv = document.createElement('div');
            optionDiv.className = 'supplier-option';
            optionDiv.setAttribute('data-value', option.value);
            
            // Text container
            const textSpan = document.createElement('span');
            textSpan.className = 'supplier-option-text';
            textSpan.textContent = option.textContent;
            optionDiv.appendChild(textSpan);

            // Store account information if available
            if (option.getAttribute('data-account-name')) {
                optionDiv.setAttribute('data-account-name', option.getAttribute('data-account-name'));
            }
            if (option.getAttribute('data-account-number')) {
                optionDiv.setAttribute('data-account-number', option.getAttribute('data-account-number'));
            }
            if (option.getAttribute('data-bank-name')) {
                optionDiv.setAttribute('data-bank-name', option.getAttribute('data-bank-name'));
            }
            if (option.getAttribute('data-description')) {
                optionDiv.setAttribute('data-description', option.getAttribute('data-description'));
                // Create tooltip wrapper matching view_item_request style
                const tooltipWrapper = document.createElement('span');
                tooltipWrapper.className = 'tooltip-wrapper';
                const descText = option.getAttribute('data-description') || '';
                // Escape HTML for safer insertion
                const escapeHtml = (s) => String(s || '').replace(/[&<>"]/g, function(c) {
                    return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c];
                });
                tooltipWrapper.innerHTML = '<i class=\"fas fa-info-circle tooltip-icon\" aria-hidden=\"true\"></i>' +
                                           '<span class=\"tooltip-text\">' + escapeHtml(descText) + '</span>';
                optionDiv.appendChild(tooltipWrapper);
                // Prevent the option from being selected when interacting with the icon.
                // Use a click handler that prevents default and stops propagation, and toggles persistent tooltip visibility.
                tooltipWrapper.addEventListener('click', function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    const currentlyVisible = tooltipWrapper.classList.contains('tooltip-visible');
                    // Close other visible tooltips first
                    document.querySelectorAll('.tooltip-wrapper.tooltip-visible').forEach(w => {
                        if (w !== tooltipWrapper) w.classList.remove('tooltip-visible');
                    });
                    if (currentlyVisible) {
                        tooltipWrapper.classList.remove('tooltip-visible');
                    } else {
                        tooltipWrapper.classList.add('tooltip-visible');
                        positionTooltip(tooltipWrapper);
                    }
                }, { passive: false });
                // Bind positioning handlers so tooltip positions like the view page
                bindTooltipPositioning(tooltipWrapper);
            }
            
            // Use mousedown instead of click for better trackpad support
            optionDiv.addEventListener('mousedown', function(e) {
                e.preventDefault(); // Prevent blur from firing
                clickingOnOption = true;
                const accountName = optionDiv.getAttribute('data-account-name') || '';
                const accountNumber = optionDiv.getAttribute('data-account-number') || '';
                const bankName = optionDiv.getAttribute('data-bank-name') || '';
                selectSupplier(option.value, option.textContent, accountName, accountNumber, bankName);
            });
            
            // Keep click as fallback for accessibility
            optionDiv.addEventListener('click', function(e) {
                if (!clickingOnOption) {
                    const accountName = optionDiv.getAttribute('data-account-name') || '';
                    const accountNumber = optionDiv.getAttribute('data-account-number') || '';
                    const bankName = optionDiv.getAttribute('data-bank-name') || '';
                    selectSupplier(option.value, option.textContent, accountName, accountNumber, bankName);
                }
            });
            
            dropdown.appendChild(optionDiv);
        });
    }

    // Tooltip positioning helpers (mirrors view_item_request behavior)
    function positionTooltip(tooltipWrapper) {
        var icon = tooltipWrapper.querySelector('.tooltip-icon');
        var tooltip = tooltipWrapper.querySelector('.tooltip-text');
        if (icon && tooltip) {
            var iconRect = icon.getBoundingClientRect();
            // Align tooltip so its left edge positions such that the arrow (at left:8px)
            // points to the icon center. Compute left = iconCenter - arrowOffset.
            var iconCenter = iconRect.left + (iconRect.width / 2);
            var arrowOffset = 18; // reduced to shift tooltip slightly right relative to previous position
            tooltip.style.left = (iconCenter - arrowOffset) + 'px';

            // For responsive/tap mode, bring the tooltip closer to the icon vertically.
            var isMobileViewport = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
            var isTapVisible = tooltipWrapper.classList && tooltipWrapper.classList.contains('tooltip-visible');
            if (isMobileViewport || isTapVisible) {
                // Move tooltip down a bit so it's closer to the icon on mobile/tap (smaller offset)
                tooltip.style.top = (iconRect.top - tooltip.offsetHeight + 4) + 'px';
            } else {
                tooltip.style.top = (iconRect.top - tooltip.offsetHeight - 8) + 'px';
            }
        }
    }

    function bindTooltipPositioning(wrapper) {
        if (!wrapper || wrapper.dataset.tooltipBound === 'true') return;
        wrapper.dataset.tooltipBound = 'true';
        ['mouseenter', 'touchstart'].forEach(evt => {
            wrapper.addEventListener(evt, function() { positionTooltip(wrapper); }, { passive: true });
        });
        // Re-position on scroll/resize while visible
        ['scroll', 'resize'].forEach(evt => {
            window.addEventListener(evt, function() {
                var tooltip = wrapper.querySelector('.tooltip-text');
                if (tooltip && tooltip.style.visibility === 'visible') {
                    positionTooltip(wrapper);
                }
            });
        });
    }
    
    // Responsive: enable tap-to-open behavior on touch/small screens
    function enableTapTooltipsOnMobile() {
        const supportsTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // consider mobile if touch-capable or narrow viewport
        const isMobileViewport = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
        const enableTap = supportsTouch || isMobileViewport;

        document.querySelectorAll('.tooltip-wrapper').forEach(wrapper => {
            if (wrapper._tapHandlerBound) return;
            wrapper._tapHandlerBound = true;
            wrapper.addEventListener('click', function (e) {
                if (!enableTap) return;
                e.stopPropagation();
                // Toggle visible class
                const currentlyVisible = wrapper.classList.contains('tooltip-visible');
                // Close other visible tooltips
                document.querySelectorAll('.tooltip-wrapper.tooltip-visible').forEach(w => {
                    if (w !== wrapper) w.classList.remove('tooltip-visible');
                });
                if (currentlyVisible) {
                    wrapper.classList.remove('tooltip-visible');
                } else {
                    wrapper.classList.add('tooltip-visible');
                    positionTooltip(wrapper);
                }
            }, { passive: false });
        });

        // Close tooltips when tapping outside
        document.addEventListener('click', function () {
            document.querySelectorAll('.tooltip-wrapper.tooltip-visible').forEach(w => w.classList.remove('tooltip-visible'));
        });
    }
    
    function selectSupplier(value, text, accountName, accountNumber, bankName) {
        // Clear any pending blur timeout
        if (blurTimeout) {
            clearTimeout(blurTimeout);
            blurTimeout = null;
        }
        
        // Validate that the selected value is in the allowed options
        const allowedOptions = Array.from(hiddenSelect.querySelectorAll('option'))
            .map(opt => opt.value)
            .filter(val => val !== ''); // Exclude placeholder
        
        if (!allowedOptions.includes(value)) {
            alert('Invalid supplier selected. Please select from the dropdown options.');
            searchInput.value = '';
            hiddenSelect.value = '';
            document.getElementById('person_company').value = '';
            // Clear auto-populated fields when invalid selection
            if (typeof clearAutoPopulatedBankFields === 'function') {
                clearAutoPopulatedBankFields();
            }
            currentSelectedSupplier = null;
            return;
        }
        
        // If supplier changed, clear previous auto-populated fields first
        if (currentSelectedSupplier && currentSelectedSupplier !== value) {
            if (typeof clearAutoPopulatedBankFields === 'function') {
                clearAutoPopulatedBankFields();
            }
        }
        
        searchInput.value = text;
        hiddenSelect.value = value;
        currentSelectedSupplier = value;
        
        // Update the hidden person_company input for form submission
        document.getElementById('person_company').value = value;
        
        // Auto-populate account fields if available
        const accountNameInput = document.getElementById('account_name');
        const accountNumberInput = document.getElementById('account_number');
        const bankNameInput = document.getElementById('bank_name');
        
        // Get account info from stored data or from parameters
        let finalAccountName = accountName || '';
        let finalAccountNumber = accountNumber || '';
        let finalBankName = bankName || '';
        
        // Check if we have stored account data for this supplier
        if (window.supplierOptionsData && window.supplierOptionsData[value]) {
            finalAccountName = window.supplierOptionsData[value].account_name || '';
            finalAccountNumber = window.supplierOptionsData[value].account_number || '';
            finalBankName = window.supplierOptionsData[value].bank_name || '';
        }
        
        // Get note elements
        const accountNameNote = document.getElementById('account_name_auto_note');
        const accountNumberNote = document.getElementById('account_number_auto_note');
        const bankNameNote = document.getElementById('bank_name_auto_note');
        const personCompanyNote = document.getElementById('person_company_auto_note');
        
        // Check if any bank-related fields will be auto-populated
        const hasBankInfo = finalAccountName || finalAccountNumber || finalBankName;
        
        // Show/hide Person/Company Name note based on whether bank info exists
        if (personCompanyNote) {
            if (hasBankInfo) {
                personCompanyNote.style.display = 'block';
            } else {
                personCompanyNote.style.display = 'none';
            }
        }
        
        // Only populate if account info exists and fields are empty or were previously auto-populated
        if (accountNameInput) {
            // Check if the current value was auto-populated (we'll track this)
            const wasAutoPopulated = accountNameInput.dataset.autoPopulated === 'true';
            if (finalAccountName && (!accountNameInput.value || wasAutoPopulated)) {
                accountNameInput.value = finalAccountName;
                accountNameInput.dataset.autoPopulated = 'true';
                // Show note
                if (accountNameNote) accountNameNote.style.display = 'block';
            }
        }
        
        if (accountNumberInput) {
            const wasAutoPopulated = accountNumberInput.dataset.autoPopulated === 'true';
            if (finalAccountNumber && (!accountNumberInput.value || wasAutoPopulated)) {
                accountNumberInput.value = finalAccountNumber;
                accountNumberInput.dataset.autoPopulated = 'true';
                // Show note
                if (accountNumberNote) accountNumberNote.style.display = 'block';
            }
        }
        
        if (bankNameInput) {
            const wasAutoPopulated = bankNameInput.dataset.autoPopulated === 'true';
            if (finalBankName && (!bankNameInput.value || wasAutoPopulated)) {
                bankNameInput.value = finalBankName;
                bankNameInput.dataset.autoPopulated = 'true';
                // Show note
                if (bankNameNote) bankNameNote.style.display = 'block';
                // Trigger change event to show SWIFT code if applicable
                if (typeof showSwiftCode === 'function') {
                    showSwiftCode();
                }
            }
        }
        
        dropdown.style.display = 'none';
        searchInput.blur();
        
        // Reset flag after a short delay
        setTimeout(() => {
            clickingOnOption = false;
        }, 100);
    }
    
    function filterSuppliers(searchTerm) {
        const options = dropdown.querySelectorAll('.supplier-option');
        
        let hasVisibleOptions = false;
        
        options.forEach(option => {
            const text = option.textContent.toLowerCase();
            const matches = text.includes(searchTerm.toLowerCase());
            
            if (matches) {
                option.classList.remove('hidden');
                hasVisibleOptions = true;
            } else {
                option.classList.add('hidden');
            }
        });
        
        dropdown.style.display = hasVisibleOptions ? 'block' : 'none';
    }
    
    // Event listeners
    searchInput.addEventListener('input', function() {
        const searchTerm = this.value.trim();
        if (searchTerm.length > 0) {
            filterSuppliers(searchTerm);
        } else {
            // Show all options when search is empty
            dropdown.querySelectorAll('.supplier-option').forEach(option => {
                option.classList.remove('hidden');
            });
            dropdown.style.display = 'block';
        }
    });
    
    searchInput.addEventListener('focus', function() {
        if (this.value.trim() === '') {
            dropdown.style.display = 'block';
        } else {
            filterSuppliers(this.value.trim());
        }
    });
    
    searchInput.addEventListener('blur', function() {
        // Delay hiding to allow clicks on options
        // Clear any existing timeout first
        if (blurTimeout) {
            clearTimeout(blurTimeout);
        }
        blurTimeout = setTimeout(() => {
            // Only hide if not clicking on an option
            if (!clickingOnOption) {
                // Validate that the current value matches a valid option
                const currentValue = this.value.trim();
                const hiddenSelectValue = hiddenSelect.value;
                
                // If there's a value but it doesn't match the selected option, clear it
                if (currentValue && !hiddenSelectValue) {
                    // User typed something but didn't select from dropdown - clear it
                    this.value = '';
                    document.getElementById('person_company').value = '';
                    // Clear auto-populated fields
                    if (typeof clearAutoPopulatedBankFields === 'function') {
                        clearAutoPopulatedBankFields();
                    }
                    currentSelectedSupplier = null;
                } else if (currentValue && hiddenSelectValue) {
                    // Ensure the displayed value matches the selected option
                    const selectedOption = hiddenSelect.querySelector(`option[value="${hiddenSelectValue}"]`);
                    if (selectedOption && selectedOption.textContent !== currentValue) {
                        // Value doesn't match - reset to selected option text
                        this.value = selectedOption.textContent;
                    }
                } else if (!currentValue && !hiddenSelectValue) {
                    // Both are empty - clear auto-populated fields
                    if (typeof clearAutoPopulatedBankFields === 'function') {
                        clearAutoPopulatedBankFields();
                    }
                    currentSelectedSupplier = null;
                }
                
                dropdown.style.display = 'none';
            }
            blurTimeout = null;
        }, 200);
    });
    
    // Listen for changes to the hidden select to clear fields when supplier is cleared
    hiddenSelect.addEventListener('change', function() {
        if (!this.value) {
            // Supplier was cleared - clear auto-populated fields
            if (typeof window.clearAutoPopulatedBankFields === 'function') {
                window.clearAutoPopulatedBankFields();
            }
            currentSelectedSupplier = null;
            searchInput.value = '';
            document.getElementById('person_company').value = '';
        }
    });
    
    // Prevent form submission if search input has a value that doesn't match a valid option
    searchInput.addEventListener('keydown', function(e) {
        // Prevent Enter key from submitting if value doesn't match an option
        if (e.key === 'Enter') {
            e.preventDefault();
            const typedValue = this.value.trim();
            const options = Array.from(hiddenSelect.querySelectorAll('option'))
                .filter(opt => opt.value !== '')
                .map(opt => ({ value: opt.value, text: opt.textContent.toLowerCase() }));
            
            // Check if typed value matches any option (case-insensitive)
            const matchingOption = options.find(opt => opt.text === typedValue.toLowerCase());
            
            if (matchingOption) {
                // Select the matching option
                selectSupplier(matchingOption.value, matchingOption.text);
            } else {
                // No match - clear and show error
                alert('Please select a supplier from the dropdown. You cannot enter a custom value.');
                this.value = '';
                hiddenSelect.value = '';
                document.getElementById('person_company').value = '';
                // Clear auto-populated fields
                if (typeof window.clearAutoPopulatedBankFields === 'function') {
                    window.clearAutoPopulatedBankFields();
                }
                currentSelectedSupplier = null;
                this.focus();
            }
        }
    });
    
    // Hide dropdown when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
            dropdown.style.display = 'none';
        }
    });
    
    // Initialize dropdown
    buildSupplierDropdown();
    
    // Store function globally so it can be called when options change
    window.buildSupplierDropdown = buildSupplierDropdown;
}

function handleRecurringChange() {
    const recurring = document.getElementById('recurring').value;
    
    if (recurring === 'Recurring') {
        // Show the edit button
        document.getElementById('configureButton').style.display = 'block';
        // Clear any existing configuration to start fresh
        document.getElementById('recurring_interval').value = '';
        // Open the modal automatically
        openRecurringModal();
    } else {
        document.getElementById('recurring_interval').value = '';
        closeRecurringModal();
        // Hide the edit button
        document.getElementById('configureButton').style.display = 'none';
    }
}

function initializeRecurringModal() {
    console.log(' DEBUG: initializeRecurringModal - starting');
    
    // Set default values
    updateFrequencyOptions();
    updateSchedulePreview();
    initializeCalendar();
    
    console.log(' DEBUG: initializeRecurringModal - completed');
}

function initializeCalendar() {
    // Set current month and year as default
    const now = new Date();
    document.getElementById('monthSelect').value = now.getMonth();
    
    // Clear existing options first
    const yearSelect = document.getElementById('yearSelect');
    yearSelect.innerHTML = '';
    
    // Populate years (current year  5 years)
    const currentYear = now.getFullYear();
    for (let i = currentYear - 2; i <= currentYear + 3; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        if (i === currentYear) {
            option.selected = true;
        }
        yearSelect.appendChild(option);
    }
    
    updateCalendarDays();
    highlightCurrentDate();
}


function highlightCurrentDate() {
    const now = new Date();
    const currentDay = now.getDate();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    const selectedMonth = parseInt(document.getElementById('monthSelect').value);
    const selectedYear = parseInt(document.getElementById('yearSelect').value);
    
    // Only highlight if we're viewing the current month and year
    if (selectedMonth === currentMonth && selectedYear === currentYear) {
        const calendarDays = document.querySelectorAll('.calendar-day');
        calendarDays.forEach(day => {
            if (parseInt(day.dataset.day) === currentDay) {
                day.classList.add('current-date');
            }
        });
    }
}



function updateCalendarDays() {
    const monthSelect = document.getElementById('monthSelect');
    const yearSelect = document.getElementById('yearSelect');
    const calendarGrid = document.getElementById('calendarGrid');
    
    if (!monthSelect || !yearSelect || !calendarGrid) {
        console.error('Calendar elements not found');
        return;
    }
    
    const month = parseInt(monthSelect.value);
    const year = parseInt(yearSelect.value);
    
    // Validate year and month
    if (isNaN(year) || isNaN(month)) {
        console.error('Invalid year or month');
        return;
    }
    
    // Get first day of month and number of days
    // JavaScript getDay() returns: 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
    // Our header is: Sun(0), Mon(1), Tue(2), Wed(3), Thu(4), Fri(5), Sat(6)
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    
    calendarGrid.innerHTML = '';
    
    // Create calendar header
    const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    dayHeaders.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'calendar-header';
        dayHeader.textContent = day;
        calendarGrid.appendChild(dayHeader);
    });
    
    // Add empty cells for days before the first day of the month
    // firstDay already matches our header order (0=Sunday, 1=Monday, etc.)
    for (let i = 0; i < firstDay; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'calendar-day empty';
        calendarGrid.appendChild(emptyCell);
    }
    
    // Add days of the month
    const today = new Date();
    const currentDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    
    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = document.createElement('div');
        dayCell.className = 'calendar-day';
        dayCell.textContent = day;
        dayCell.dataset.day = day;
        dayCell.dataset.year = year;
        dayCell.dataset.month = month;
        
        // Check if this day is in the past
        const dayDate = new Date(year, month, day);
        if (dayDate < currentDate) {
            // Disable past dates
            dayCell.classList.add('disabled');
            dayCell.style.opacity = '0.3';
            dayCell.style.cursor = 'not-allowed';
            dayCell.title = 'Cannot select past dates. Please choose today or a future date.';
        } else {
            dayCell.onclick = function() { 
                console.log(' DEBUG: onclick triggered for day:', day);
                console.log(' DEBUG: calling toggleCalendarDay with this:', this);
                console.log(' DEBUG: toggleCalendarDay function exists:', typeof toggleCalendarDay);
                try {
                    if (typeof toggleCalendarDay === 'function') {
                        console.log(' DEBUG: About to call toggleCalendarDay...');
                        toggleCalendarDay(this); 
                        console.log(' DEBUG: toggleCalendarDay call completed');
                    } else {
                        console.error(' DEBUG: toggleCalendarDay is not a function');
                    }
                } catch (error) {
                    console.error(' DEBUG: Error in toggleCalendarDay:', error);
                }
            };
        }
        
        // Check if this date is already selected
        if (isDateSelected(year, month, day)) {
            dayCell.classList.add('selected');
        }
        
        calendarGrid.appendChild(dayCell);
    }
    
    // Highlight current date if viewing current month
    const now = new Date();
    if (month === now.getMonth() && year === now.getFullYear()) {
        const currentDay = now.getDate();
        const currentDayElement = document.querySelector(`#calendarGrid .calendar-day[data-day="${currentDay}"]`);
        if (currentDayElement) {
            currentDayElement.classList.add('current-date');
        }
    }
    
    updateSchedulePreview();
    highlightCurrentDate();
    
    // Refresh end date display if it's visible
    const endDateSection = document.getElementById('endDateSection');
    if (endDateSection && endDateSection.style.display !== 'none') {
        updateEndDateDisplay();
    }
}

function toggleCalendarDay(dayElement) {
    console.log(' DEBUG: toggleCalendarDay called with element:', dayElement);
    
    // Check if the day is disabled (past date)
    if (dayElement.classList.contains('disabled')) {
        alert('Cannot select past dates. Please choose today or a future date.');
        return;
    }
    
    const year = parseInt(dayElement.dataset.year);
    const month = parseInt(dayElement.dataset.month);
    const day = parseInt(dayElement.dataset.day);
    
    console.log(' DEBUG: toggleCalendarDay - year:', year, 'month:', month, 'day:', day);
    console.log(' DEBUG: toggleCalendarDay - selectedDates before:', selectedDates);
    
    if (dayElement.classList.contains('selected')) {
        // Remove from selection
        dayElement.classList.remove('selected');
        removeSelectedDate(year, month, day);
        console.log(' DEBUG: toggleCalendarDay - removed date');
    } else {
        // Clear all previous selections (only allow one date)
        document.querySelectorAll('#calendarGrid .calendar-day.selected').forEach(el => {
            el.classList.remove('selected');
        });
        selectedDates = []; // Clear the array
        
        // Add the new selection
        dayElement.classList.add('selected');
        addSelectedDate(year, month, day);
        console.log(' DEBUG: toggleCalendarDay - selected single date');
    }
    
    console.log(' DEBUG: toggleCalendarDay - selectedDates after:', selectedDates);
    
    updateSchedulePreview();
    
    // Refresh end date display if it's visible
    const endDateSection = document.getElementById('endDateSection');
    if (endDateSection && endDateSection.style.display !== 'none') {
        updateEndDateDisplay();
    }
    
    // If variable amounts are enabled, refresh the payment inputs
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log('Date selection changed, refreshing variable amounts...');
        generatePaymentAmountInputs();
        updateAmountSummary();
    }
}

// Tab switching functions
function switchToMonthly() {
    // Update tab appearance
    document.getElementById('monthlyTab').classList.add('active');
    document.getElementById('customTab').classList.remove('active');
    
    // Show monthly config, hide custom config
    document.getElementById('monthlyConfig').style.display = 'block';
    document.getElementById('customConfig').style.display = 'none';
    
    // Initialize calendar for monthly mode
    initializeCalendar();
    
    // Update amount summary to ensure proper button state
    updateAmountSummary();
    updateSchedulePreview();
}

function switchToCustom() {
    // Update tab appearance
    document.getElementById('customTab').classList.add('active');
    document.getElementById('monthlyTab').classList.remove('active');
    
    // Show custom config, hide monthly config
    document.getElementById('customConfig').style.display = 'block';
    document.getElementById('monthlyConfig').style.display = 'none';
    
    // Initialize custom dates if not already done
    if (document.getElementById('customDatesList').children.length === 0) {
        if (customDates && customDates.length > 0) {
            // Create DOM elements for existing custom dates
            customDates.forEach((dateObj, index) => {
                const customDatesList = document.getElementById('customDatesList');
                const dateItem = document.createElement('div');
                dateItem.className = 'custom-date-item';
                dateItem.id = dateObj.id;
                
                // Use the correct index for event handlers
                const currentIndex = index;
                dateItem.innerHTML = `
                    <span class="date-label">Date:</span>
                    <input type="date" id="${dateObj.id}_date" value="${dateObj.date}" onchange="updateCustomDate(${currentIndex})">
                    <span class="amount-label">Amount:</span>
                    <input type="number" id="${dateObj.id}_amount" value="${dateObj.amount}" step="0.001" min="0" onchange="updateCustomDate(${currentIndex})" onkeydown="handleAmountKeyPress(event, ${currentIndex})">
                    <button type="button" class="btn-remove-date" onclick="removeCustomDate('${dateObj.id}')">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                
                customDatesList.appendChild(dateItem);
            });
        } else {
            showCustomDatesEmpty();
        }
    }
    
    // Update custom amount summary (this will also update button state)
    updateCustomAmountSummary();
    updateSchedulePreview();
}

// Custom date management
let customDates = [];

function addCustomDate() {
    // Check if button is disabled (all amount allocated)
    const addDateButton = document.querySelector('.btn-add-date');
    if (addDateButton && addDateButton.disabled) {
        return; // Don't add date if button is disabled
    }
    
    const customDatesList = document.getElementById('customDatesList');
    
    // Remove empty state if it exists
    const emptyState = customDatesList.querySelector('.custom-dates-empty');
    if (emptyState) {
        emptyState.remove();
    }
    
    const dateId = 'customDate_' + Date.now();
    const dateItem = document.createElement('div');
    dateItem.className = 'custom-date-item';
    dateItem.id = dateId;
    
    // Get today's date as default
    const today = new Date();
    const todayString = today.toISOString().split('T')[0];
    
    dateItem.innerHTML = `
        <span class="date-label">Date:</span>
        <input type="date" id="${dateId}_date" value="${todayString}" onchange="updateCustomDate(${customDates.length})">
        <span class="amount-label">Amount:</span>
        <input type="number" id="${dateId}_amount" value="0.000" step="0.001" min="0" onchange="updateCustomDate(${customDates.length})" onkeydown="handleAmountKeyPress(event, ${customDates.length})">
        <button type="button" class="btn-remove-date" onclick="removeCustomDate('${dateId}')">
            <i class="fas fa-trash"></i>
        </button>
    `;
    
    customDatesList.appendChild(dateItem);
    
    // Add to customDates array
    customDates.push({
        id: dateId,
        date: todayString,
        amount: 0.000
    });
    
    updateCustomAmountSummary();
    updateSchedulePreview();
}

function removeCustomDate(dateId) {
    // Remove from DOM
    const dateItem = document.getElementById(dateId);
    if (dateItem) {
        dateItem.remove();
    }
    
    // Remove from customDates array
    customDates = customDates.filter(date => date.id !== dateId);
    
    // Show empty state if no dates left
    if (customDates.length === 0) {
        showCustomDatesEmpty();
    }
    
    updateCustomAmountSummary();
    updateSchedulePreview();
}

function updateCustomDate(index) {
    console.log(' DEBUG: updateCustomDate - called with index:', index, 'customDates.length:', customDates.length);
    if (index >= 0 && index < customDates.length) {
        const dateId = customDates[index].id;
        const dateInput = document.getElementById(dateId + '_date');
        const amountInput = document.getElementById(dateId + '_amount');
        
        console.log(' DEBUG: updateCustomDate - dateId:', dateId, 'dateInput:', dateInput, 'amountInput:', amountInput);
        
        if (dateInput && amountInput) {
            const oldAmount = customDates[index].amount;
            customDates[index].date = dateInput.value;
            customDates[index].amount = parseFloat(amountInput.value) || 0;
            console.log(' DEBUG: updateCustomDate - updated amount from', oldAmount, 'to', customDates[index].amount);
        }
    }
    
    console.log(' DEBUG: updateCustomDate - calling updateCustomAmountSummary');
    updateCustomAmountSummary();
    updateSchedulePreview();
}

function handleAmountKeyPress(event, index) {
    console.log(' DEBUG: handleAmountKeyPress - key pressed:', event.key, 'index:', index);
    if (event.key === 'Enter') {
        console.log(' DEBUG: handleAmountKeyPress - Enter key detected, calling updateCustomDate');
        event.preventDefault();
        updateCustomDate(index);
    }
}

function updateCustomAmountSummary() {
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    let totalAllocated = 0;
    
    // Calculate total allocated from custom dates
    customDates.forEach(date => {
        totalAllocated += date.amount || 0;
    });
    
    const remaining = totalAmount - totalAllocated;
    
    // Update the display
    const totalAmountElement = document.getElementById('customTotalAmount');
    const totalAllocatedElement = document.getElementById('customTotalAllocated');
    const remainingElement = document.getElementById('customRemainingAmount');
    
    if (totalAmountElement) {
        totalAmountElement.textContent = totalAmount.toFixed(3);
    }
    if (totalAllocatedElement) {
        totalAllocatedElement.textContent = totalAllocated.toFixed(3);
    }
    if (remainingElement) {
        remainingElement.textContent = remaining.toFixed(3);
        
        // Color code the remaining amount
        if (remaining < 0) {
            remainingElement.style.color = '#dc3545'; // Red for over-allocated
        } else if (remaining === 0) {
            remainingElement.style.color = '#28a745'; // Green for fully allocated
        } else {
            remainingElement.style.color = '#6c757d'; // Gray for partially allocated
        }
    }
    
    // Check if total allocated doesn't match the total amount
    const isMismatch = totalAmount > 0 && Math.abs(totalAllocated - totalAmount) > 0.001;
    
    // Enable/disable Save Configuration button based on amount match
    // Only disable if we're not in post-save mode (i.e., during active editing)
    const saveButton = document.querySelector('button[onclick="saveRecurringConfig()"]');
    if (saveButton && !window.isPostSaveMode) {
        if (isMismatch) {
            saveButton.disabled = true;
            saveButton.style.opacity = '0.5';
            saveButton.style.cursor = 'not-allowed';
        } else {
            saveButton.disabled = false;
            saveButton.style.opacity = '1';
            saveButton.style.cursor = 'pointer';
        }
    }
    
    // Enable/disable Add Date button based on remaining amount
    const addDateButton = document.querySelector('.btn-add-date');
    if (addDateButton) {
        if (remaining <= 0) {
            addDateButton.disabled = true;
            addDateButton.style.opacity = '0.5';
            addDateButton.style.cursor = 'not-allowed';
            addDateButton.title = 'Cannot add more dates. All amount has been allocated.';
        } else {
            addDateButton.disabled = false;
            addDateButton.style.opacity = '1';
            addDateButton.style.cursor = 'pointer';
            addDateButton.title = 'Add a new payment date';
        }
    }
}

function showCustomDatesEmpty() {
    const customDatesList = document.getElementById('customDatesList');
    customDatesList.innerHTML = `
        <div class="custom-dates-empty">
            <i class="fas fa-calendar-plus"></i>
            <p>No custom dates added yet. Click "Add Date" to start building your payment schedule.</p>
        </div>
    `;
}

function openRecurringModal() {
    document.getElementById('recurringModal').style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Initialize calendar when modal opens
    initializeCalendar();
    
    // Load existing configuration if any, or load temporary config
    loadExistingConfig();
    
    updateSchedulePreview();
}

function clearSavedPreferences() {
    // Clear saved preferences from localStorage
    localStorage.removeItem('paymentScheduleInterval');
    localStorage.removeItem('paymentScheduleStartDate');
    localStorage.removeItem('customPaymentDates');
    
    // Reset the form to defaults
    document.getElementById('intervalValue').value = '1';
    document.getElementById('yearSelect').value = new Date().getFullYear();
    document.getElementById('monthSelect').value = new Date().getMonth();
    
    // Clear all selected dates
    selectedDates = [];
    
    updateCalendarDays();
    
    // Clear any selected days
    document.querySelectorAll('#monthlyOptions .calendar-day.selected').forEach(day => {
        day.classList.remove('selected');
    });
    
    // Clear custom dates
    customDates = [];
    document.getElementById('customDatesList').innerHTML = '';
    
    updateSchedulePreview();
    
    console.log(' DEBUG: clearSavedPreferences - cleared all saved preferences');
}

// Temporary storage for unsaved configuration
let tempRecurringConfig = '';

function saveTempConfig() {
    // Check which tab is active
    const customTab = document.getElementById('customTab');
    const isCustomActive = customTab && customTab.classList.contains('active');
    
    let config = '';
    
    if (isCustomActive) {
        // Save custom configuration
        console.log('saveTempConfig - saving custom configuration');
        if (customDates.length === 0) {
            config = '';
        } else {
            config = 'custom:';
            const sortedDates = [...customDates].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dateStrings = sortedDates.map(date => `${date.date}:${date.amount}`);
            config += dateStrings.join(',');
        }
    } else {
        // Save monthly configuration
        const interval = document.getElementById('intervalValue').value;
        config = `monthly:${interval}`;
        
        // Handle monthly options - store the single selected date
        if (selectedDates && selectedDates.length > 0) {
            // Get the first (and only) selected date
            const date = selectedDates[0];
            const monthNum = String(date.month + 1).padStart(2, '0'); // Convert 0-based to 1-based and pad
            const dayNum = String(date.day).padStart(2, '0');
            const dateString = `${date.year}-${monthNum}-${dayNum}`;
            
            // Store the single date in the config
            config += `:date:${dateString}`;
            console.log('saveTempConfig - Selected date for config:', dateString);
        }
        
        // Add end date if set
        const endDateToggle = document.getElementById('endDateToggle');
        if (endDateToggle && endDateToggle.checked) {
            const endDate = getSelectedEndDate();
            if (endDate) {
                config += `:end:${endDate}`;
                console.log('saveTempConfig - Added end date to config:', endDate);
            }
        }
    }
    
    console.log('Saving temp config:', config);
    tempRecurringConfig = config;
    
    // Also save to the hidden field so it persists when reopening the modal
    document.getElementById('recurring_interval').value = config;
}

function loadExistingConfig() {
    const config = document.getElementById('recurring_interval').value || tempRecurringConfig;
    console.log('Loading config:', config);
    
    // Load saved preferences if there's no existing configuration
    if (!config) {
        console.log('No existing config, loading saved preferences...');
        
        // Load saved preferences from localStorage
        const savedInterval = localStorage.getItem('paymentScheduleInterval');
        const savedStartDate = localStorage.getItem('paymentScheduleStartDate');
        
        if (savedInterval) {
            console.log('Loading saved interval:', savedInterval);
            document.getElementById('intervalValue').value = savedInterval;
        }
        
        if (savedStartDate) {
            console.log('Loading saved start date:', savedStartDate);
            // Parse and set the saved start date
            const date = new Date(savedStartDate);
            if (!isNaN(date.getTime())) {
                selectedDates = [{
                    year: date.getFullYear(),
                    month: date.getMonth(),
                    day: date.getDate()
                }];
                updateCalendar();
            }
        }
        
               // Load saved custom dates if any
               const savedCustomDates = localStorage.getItem('customPaymentDates');
               if (savedCustomDates) {
                   try {
                       const customDatesData = JSON.parse(savedCustomDates);
                       if (Array.isArray(customDatesData) && customDatesData.length > 0) {
                           customDates = customDatesData;
                           // Note: DOM elements will be created when switching to custom tab
                           switchToCustom();
                       }
                   } catch (e) {
                       console.log('Error loading saved custom dates:', e);
                   }
               }
        
        // Load variable amounts state and payment schedule data
        const savedVariableAmounts = localStorage.getItem('variableAmountsEnabled');
        const savedPaymentSchedule = localStorage.getItem('paymentScheduleData');
        
        if (savedVariableAmounts === 'true') {
            console.log('Loading saved variable amounts configuration');
            
            // Enable variable amounts toggle
            const variableAmountsToggle = document.getElementById('variableAmountsToggle');
            if (variableAmountsToggle) {
                variableAmountsToggle.checked = true;
                toggleVariableAmounts();
            }
            
            // Load payment schedule data
            if (savedPaymentSchedule) {
                try {
                    const paymentSchedule = JSON.parse(savedPaymentSchedule);
                    console.log('Loading saved payment schedule:', paymentSchedule);
                    
                    // Set the payment schedule field
                    document.getElementById('payment_schedule').value = savedPaymentSchedule;
                    
                    // Store the payment schedule for later use
                    window.savedPaymentSchedule = paymentSchedule;
                    
                    // Generate payment inputs after a delay to ensure the modal is fully loaded
                    setTimeout(() => {
                        if (window.savedPaymentSchedule) {
                            generatePaymentAmountInputsFromSchedule(window.savedPaymentSchedule);
                            updateAmountSummary();
                        }
                    }, 300);
                } catch (e) {
                    console.log('Error loading saved payment schedule:', e);
                }
            }
        }
        
        console.log('Saved preferences loaded successfully');
    } else {
        console.log('Existing config found, loading from config...');
        
        // Load from existing configuration
        const parts = config.split(':');
        const frequency = parts[0];
        const interval = parts[1];
        
        if (frequency === 'custom') {
            // Load custom configuration
            console.log('Loading custom configuration');
            
            // Clear existing custom dates
            customDates = [];
            document.getElementById('customDatesList').innerHTML = '';
            
            // Load custom dates from config
            if (parts.length > 1) {
                // Join all parts after the first one (frequency) to get the full custom dates string
                const customDatesString = parts.slice(1).join(':');
                const customDatesArray = customDatesString.split(',');
                
                customDatesArray.forEach((dateAmountPair, index) => {
                    const [date, amount] = dateAmountPair.split(':');
                    if (date) {
                        // Add to customDates array
                        const dateId = 'customDate_' + Date.now() + '_' + index;
                        customDates.push({
                            id: dateId,
                            date: date,
                            amount: parseFloat(amount) || 0
                        });
                    }
                });
            }
            
            // Switch to custom tab AFTER populating customDates array
            switchToCustom();
            
            // Update preview and amount summary after all DOM elements are created
            setTimeout(() => {
                updateSchedulePreview();
                updateCustomAmountSummary();
            }, 200);
            
        } else {
            // Load monthly configuration
            console.log('Loading monthly configuration');
            
            // Switch to monthly tab
            switchToMonthly();
            
            // All configurations are monthly now
            updateFrequencyOptions();
            
            // Set interval from config
            document.getElementById('intervalValue').value = interval;
            
            // Load monthly settings
            if (frequency === 'monthly' && parts[2] === 'days') {
                const days = parts[3].split(',');
                // Set the correct month and year first if they exist
                if (parts.length > 5) {
                    const year = parseInt(parts[5]);
                    const month = parseInt(parts[4]) - 1; // Convert 1-based to 0-based for dropdown
                    document.getElementById('yearSelect').value = year;
                    document.getElementById('monthSelect').value = month;
                    
                    // Add days to selectedDates array
                    selectedDates = [];
                days.forEach(day => {
                        addSelectedDate(year, month, parseInt(day));
                    });
                    
                    updateCalendarDays();
                }
                // Then select the days
                setTimeout(() => {
                    updateSchedulePreview();
                }, 100);
            } else if (frequency === 'monthly' && parts[2] === 'date') {
                // Handle single date configuration
                const dateString = parts[3];
                const [year, month, day] = dateString.split('-').map(num => parseInt(num));
                
                // Set the correct month and year
                document.getElementById('yearSelect').value = year;
                document.getElementById('monthSelect').value = month - 1; // Convert to 0-based
                
                // Add the single date to selectedDates
                selectedDates = [{
                    year: year,
                    month: month - 1, // Convert to 0-based
                    day: day
                }];
                
                updateCalendarDays();
                
                // Update preview
                setTimeout(() => {
                    updateSchedulePreview();
                }, 100);
            }
            
            // Load end date if it exists
            const endDateIndex = parts.indexOf('end');
            if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
                const endDate = parts[endDateIndex + 1];
                console.log('Loading end date:', endDate);
                
                // Parse end date and set the selectors
                const [year, month] = endDate.split('-').map(num => parseInt(num));
                document.getElementById('endDateToggle').checked = true;
                document.getElementById('endDateSection').style.display = 'block';
                
                // Populate end year options BEFORE setting the values
                populateEndYearOptions();
                
                // Set the month and year for end date
                document.getElementById('endMonthSelect').value = month - 1; // Convert to 0-based
                document.getElementById('endYearSelect').value = year;
                
                // Update display and preview
                setTimeout(() => {
                    updateEndDateDisplay();
                    updateSchedulePreview();
                }, 200);
            }
            
            // Load variable amounts state and data
            const variableAmountsFieldElement = document.getElementById('variable_amounts');
            const paymentScheduleFieldElement = document.getElementById('payment_schedule');
            
            if (variableAmountsFieldElement && variableAmountsFieldElement.value === 'true') {
                console.log('Loading variable amounts configuration');
                
                // Enable variable amounts toggle
                const variableAmountsToggleElement = document.getElementById('variableAmountsToggle');
                if (variableAmountsToggleElement) {
                    variableAmountsToggleElement.checked = true;
                    toggleVariableAmounts();
                }
                
                // Load payment schedule data
                if (paymentScheduleFieldElement && paymentScheduleFieldElement.value) {
                    try {
                        const paymentSchedule = JSON.parse(paymentScheduleFieldElement.value);
                        console.log('Loading payment schedule:', paymentSchedule);
                        
                        // Store the payment schedule for later use
                        window.savedPaymentSchedule = paymentSchedule;
                        
                        // Generate payment inputs after a delay to ensure the modal is fully loaded
                        setTimeout(() => {
                            if (window.savedPaymentSchedule) {
                                generatePaymentAmountInputsFromSchedule(window.savedPaymentSchedule);
                                updateAmountSummary();
                            }
                        }, 300);
                    } catch (e) {
                        console.log('Error loading payment schedule:', e);
                    }
                }
            }
        }
    }
}

function closeRecurringModal() {
    // Don't save temp config here as it overwrites the saved configuration
    // The configuration should already be saved by saveRecurringConfig()
    
    // Update payment schedule if variable amounts are enabled
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log(' DEBUG: closeRecurringModal - updating payment schedule before closing');
        updatePaymentSchedule();
    }
    
    document.getElementById('recurringModal').style.display = 'none';
    document.body.style.overflow = 'auto';
}

function updateFrequencyOptions() {
    // All recurring payments are monthly by default
    // Show monthly options
        document.getElementById('monthlyOptions').style.display = 'block';
    
    updateSchedulePreview();
}

function toggleDay(button) {
    button.classList.toggle('selected');
    updateSchedulePreview();
}


// Multi-month date selection functions
let selectedDates = []; // Store all selected dates across months

// Initialize selectedDates array if not already done
if (typeof selectedDates === 'undefined') {
    selectedDates = [];
}

function isDateSelected(year, month, day) {
    return selectedDates.some(date => 
        date.year === year && date.month === month && date.day === day
    );
}

function addSelectedDate(year, month, day) {
    const dateKey = `${year}-${month}-${day}`;
    if (!selectedDates.some(date => date.key === dateKey)) {
        selectedDates.push({ year, month, day, key: dateKey });
    }
}

function removeSelectedDate(year, month, day) {
    const dateKey = `${year}-${month}-${day}`;
    selectedDates = selectedDates.filter(date => date.key !== dateKey);
}

function getSelectedDatesForCurrentMonth() {
    const currentMonth = parseInt(document.getElementById('monthSelect').value);
    const currentYear = parseInt(document.getElementById('yearSelect').value);
    return selectedDates.filter(date => 
        date.year === currentYear && date.month === currentMonth
    );
}

// End Date Functions
function toggleEndDate() {
    const endDateToggle = document.getElementById('endDateToggle');
    const endDateSection = document.getElementById('endDateSection');
    
    if (endDateToggle.checked) {
        endDateSection.style.display = 'block';
        // Initialize end date selectors
        initializeEndDateSelectors();
    } else {
        endDateSection.style.display = 'none';
    }
    
    updateSchedulePreview();
}

function initializeEndDateSelectors() {
    // Set default end date to 1 year from now
    const now = new Date();
    const nextYear = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());
    
    document.getElementById('endMonthSelect').value = nextYear.getMonth();
    document.getElementById('endYearSelect').value = nextYear.getFullYear();
    
    // Populate end year options
    populateEndYearOptions();
    
    // Update the display
    updateEndDateDisplay();
}

function populateEndYearOptions() {
    const endYearSelect = document.getElementById('endYearSelect');
    const currentYear = new Date().getFullYear();
    
    // Clear existing options
    endYearSelect.innerHTML = '';
    
    // Add years from current year to 10 years in the future
    for (let year = currentYear; year <= currentYear + 10; year++) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        endYearSelect.appendChild(option);
    }
}

function updateEndDateDisplay() {
    const monthSelect = document.getElementById('endMonthSelect');
    const yearSelect = document.getElementById('endYearSelect');
    const endDateDisplay = document.getElementById('endDateDisplay');
    
    if (!monthSelect || !yearSelect || !endDateDisplay) {
        return;
    }
    
    // Get the calculated end date
    const endDate = getSelectedEndDate();
    if (!endDate) {
        return;
    }
    
    // Parse the end date to get month, day, and year
    const [year, month, day] = endDate.split('-').map(num => parseInt(num));
    
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    
    endDateDisplay.textContent = `${monthNames[month - 1]} ${day}, ${year}`;
}

// End date is now calculated as one day before the same day of month as starting date

function getSelectedEndDate() {
    // Get the selected end month/year
    const endMonth = parseInt(document.getElementById('endMonthSelect').value) + 1; // Convert to 1-based
    const endYear = parseInt(document.getElementById('endYearSelect').value);
    
    // Get the starting date from selectedDates
    let startDay = 1; // Default fallback
    if (selectedDates && selectedDates.length > 0) {
        startDay = selectedDates[0].day;
        console.log(' DEBUG: getSelectedEndDate - using start day from selectedDates:', startDay);
    } else {
        console.log(' DEBUG: getSelectedEndDate - no selectedDates, using default start day:', startDay);
    }
    
    // Calculate the end date as one day before the same day of the month
    // For example, if start date is Nov 5, 2025 and end is March 2026, result should be March 4, 2026
    let endDay = startDay - 1;
    
    // Handle edge case where start day is 1 (result would be 0)
    if (endDay <= 0) {
        // If start day is 1, use the last day of the selected end month
        const tempDate = new Date(endYear, endMonth, 0); // Last day of the selected end month
        endDay = tempDate.getDate();
        console.log(' DEBUG: getSelectedEndDate - start day is 1, using last day of selected end month:', endDay);
    }
    
    // Handle February 29th in non-leap years
    if (endMonth === 2 && endDay === 29 && !isLeapYear(endYear)) {
        endDay = 28;
        console.log(' DEBUG: getSelectedEndDate - adjusted for non-leap year February:', endDay);
    }
    
    // Handle cases where the calculated day doesn't exist in the target month
    const daysInMonth = new Date(endYear, endMonth, 0).getDate();
    if (endDay > daysInMonth) {
        endDay = daysInMonth;
        console.log(' DEBUG: getSelectedEndDate - adjusted to last day of month:', endDay);
    }
    
    console.log(' DEBUG: getSelectedEndDate - year:', endYear, 'month:', endMonth, 'day:', endDay);
    
    const result = `${endYear}-${endMonth.toString().padStart(2, '0')}-${endDay.toString().padStart(2, '0')}`;
    console.log(' DEBUG: getSelectedEndDate - returning:', result);
    return result;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

function updateSchedulePreview() {
    console.log(' DEBUG: updateSchedulePreview - starting');
    
    // Check which tab is active
    const monthlyTab = document.getElementById('monthlyTab');
    const isMonthlyActive = monthlyTab && monthlyTab.classList.contains('active');
    
    let preview = '';
    
    if (isMonthlyActive) {
        // Monthly configuration
        const interval = document.getElementById('intervalValue').value;
        console.log(' DEBUG: updateSchedulePreview - monthly mode, interval:', interval);
        console.log(' DEBUG: updateSchedulePreview - selectedDates:', selectedDates);
        
        preview = `Every ${interval} month(s)`;
        
        // Save configuration to hidden field in real-time
        saveConfigurationToHiddenField();
        
        // Handle monthly options - use all selected dates across months
        if (selectedDates && selectedDates.length > 0) {
            const selectedDays = selectedDates
                .map(date => {
                    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                    return `${monthNames[date.month]} ${date.day}, ${date.year}`;
                })
                .sort((a, b) => {
                    // Sort by actual date
                    const dateA = new Date(a);
                    const dateB = new Date(b);
                    return dateA - dateB;
                });
            
            console.log(' DEBUG: updateSchedulePreview - selected days:', selectedDays);
            
            if (selectedDays.length > 0) {
                preview += ` starting on ${selectedDays.join(', ')}`;
            }
        }
        
        // Add end date information if set
        const endDateToggle = document.getElementById('endDateToggle');
        if (endDateToggle && endDateToggle.checked) {
            const endDate = getSelectedEndDate();
            if (endDate) {
                // Parse date string to avoid timezone issues
                const [year, month, day] = endDate.split('-').map(num => parseInt(num));
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const formattedEndDate = `${monthNames[month - 1]} ${day}, ${year}`;
                preview += ` until ${formattedEndDate}`;
                console.log(' DEBUG: updateSchedulePreview - end date string:', endDate, '-> formatted:', formattedEndDate);
                
                // Update the end date display
                updateEndDateDisplay();
            }
        }
    } else {
        // Custom configuration
        console.log(' DEBUG: updateSchedulePreview - custom mode, customDates:', customDates);
        
        if (customDates.length === 0) {
            preview = 'No custom dates added yet';
        } else {
            // Sort custom dates by date
            const sortedDates = [...customDates].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            if (sortedDates.length === 1) {
                const date = new Date(sortedDates[0].date);
                const formattedDate = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                preview = `Custom payment on ${formattedDate}`;
            } else {
                const firstDate = new Date(sortedDates[0].date);
                const lastDate = new Date(sortedDates[sortedDates.length - 1].date);
                const firstFormatted = firstDate.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                const lastFormatted = lastDate.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                preview = `Custom payments: ${sortedDates.length} installments from ${firstFormatted} to ${lastFormatted}`;
            }
        }
        
        // Save custom configuration to hidden field
        saveCustomConfigurationToHiddenField();
    }
    
    console.log(' DEBUG: updateSchedulePreview - final preview:', preview);
    const previewElement = document.getElementById('schedulePreview');
    if (previewElement) {
        previewElement.textContent = preview;
    }
    
    // Handle variable amounts for monthly mode only
    if (isMonthlyActive) {
        const variableAmountsToggle = document.getElementById('variableAmountsToggle');
        if (variableAmountsToggle && variableAmountsToggle.checked) {
            console.log(' DEBUG: updateSchedulePreview - schedule preview updated, refreshing variable amounts...');
            generatePaymentAmountInputs();
            updateAmountSummary();
        }
    }
}

function saveConfigurationToHiddenField() {
    const interval = document.getElementById('intervalValue').value;
    console.log(' DEBUG: saveConfigurationToHiddenField - interval value:', interval);
    
    let config = `monthly:${interval}`;
    
    // Handle monthly options - store the single selected date
    if (selectedDates.length > 0) {
        // Get the first (and only) selected date
        const date = selectedDates[0];
        const monthNum = String(date.month + 1).padStart(2, '0'); // Convert 0-based to 1-based and pad
        const dayNum = String(date.day).padStart(2, '0');
        const dateString = `${date.year}-${monthNum}-${dayNum}`;
        
        // Store the single date in the config
        config += `:date:${dateString}`;
        console.log(' DEBUG: saveConfigurationToHiddenField - selected date:', dateString);
    }
    
    // Add end date if set
    const endDateToggle = document.getElementById('endDateToggle');
    if (endDateToggle && endDateToggle.checked) {
        const endDate = getSelectedEndDate();
        if (endDate) {
            config += `:end:${endDate}`;
            console.log(' DEBUG: saveConfigurationToHiddenField - added end date:', endDate);
        }
    }
    
    console.log(' DEBUG: saveConfigurationToHiddenField - final config:', config);
    document.getElementById('recurring_interval').value = config;
    
    // Save the user's choice for payment schedule as default
    localStorage.setItem('paymentScheduleInterval', interval);
    console.log(' DEBUG: saveConfigurationToHiddenField - saved interval to localStorage:', interval);
    
    // Save the user's choice for starting date
    if (selectedDates && selectedDates.length > 0) {
        const selectedMonth = parseInt(document.getElementById('monthSelect').value);
        const selectedYear = parseInt(document.getElementById('yearSelect').value);
        const startDate = {
            year: selectedYear,
            month: selectedMonth,
            days: selectedDates.map(d => d.day)
        };
        localStorage.setItem('paymentScheduleStartDate', JSON.stringify(startDate));
        console.log(' DEBUG: saveConfigurationToHiddenField - saved start date to localStorage:', startDate);
    }
}

function saveCustomConfigurationToHiddenField() {
    console.log(' DEBUG: saveCustomConfigurationToHiddenField - customDates:', customDates);
    
    if (customDates.length === 0) {
        document.getElementById('recurring_interval').value = '';
        return;
    }
    
    // Create custom configuration string
    let config = 'custom:';
    
    // Add all custom dates
    const sortedDates = [...customDates].sort((a, b) => new Date(a.date) - new Date(b.date));
    const dateStrings = sortedDates.map(date => `${date.date}:${date.amount}`);
    config += dateStrings.join(',');
    
    console.log(' DEBUG: saveCustomConfigurationToHiddenField - final config:', config);
    document.getElementById('recurring_interval').value = config;
}

function saveRecurringConfig() {
    // Check which tab is active
    const monthlyTab = document.getElementById('monthlyTab');
    const isMonthlyActive = monthlyTab && monthlyTab.classList.contains('active');
    
    let config = '';
    
    if (isMonthlyActive) {
        // Monthly configuration
        const interval = document.getElementById('intervalValue').value;
        config = `monthly:${interval}`;
        
        console.log('Saving recurring config - frequency: monthly, interval:', interval);
        
        // Handle monthly options - store the single selected date
        if (selectedDates && selectedDates.length > 0) {
            // Get the first (and only) selected date
            const date = selectedDates[0];
            const monthNum = String(date.month + 1).padStart(2, '0'); // Convert 0-based to 1-based and pad
            const dayNum = String(date.day).padStart(2, '0');
            const dateString = `${date.year}-${monthNum}-${dayNum}`;
            
            // Store the single date in the config
            config += `:date:${dateString}`;
            console.log('Selected date for config:', dateString);
        }
        
        // Add end date if set
        const endDateToggle = document.getElementById('endDateToggle');
        if (endDateToggle && endDateToggle.checked) {
            const endDate = getSelectedEndDate();
            if (endDate) {
                config += `:end:${endDate}`;
                console.log('Added end date to config:', endDate);
            }
        }
    } else {
        // Custom configuration
        console.log('Saving recurring config - frequency: custom, customDates:', customDates);
        
        if (customDates.length === 0) {
            alert('Please add at least one custom payment date before saving.');
            return;
        }
        
        // Create custom configuration string
        config = 'custom:';
        
        // Add all custom dates
        const sortedDates = [...customDates].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dateStrings = sortedDates.map(date => `${date.date}:${date.amount}`);
        config += dateStrings.join(',');
        
        // Save custom dates to localStorage for future use
        localStorage.setItem('customPaymentDates', JSON.stringify(customDates));
    }
    
    console.log('Final config being saved:', config);
    document.getElementById('recurring_interval').value = config;
    
    // Save variable amounts state and payment schedule data
    const variableAmountsToggleElement = document.getElementById('variableAmountsToggle');
    const variableAmountsField = document.getElementById('variable_amounts');
    const paymentScheduleField = document.getElementById('payment_schedule');
    
    if (variableAmountsToggleElement && variableAmountsToggleElement.checked) {
        console.log('Saving variable amounts configuration');
        variableAmountsField.value = 'true';
        
        // Update payment schedule before saving
        updatePaymentSchedule();
        
        // Save variable amounts state to localStorage
        localStorage.setItem('variableAmountsEnabled', 'true');
        localStorage.setItem('paymentScheduleData', paymentScheduleField.value);
    } else {
        variableAmountsField.value = 'false';
        paymentScheduleField.value = '[]';
        
        // Clear variable amounts state from localStorage
        localStorage.removeItem('variableAmountsEnabled');
        localStorage.removeItem('paymentScheduleData');
    }
    
    // Save preferences to localStorage for future use
    if (isMonthlyActive) {
        const interval = document.getElementById('intervalValue').value;
        localStorage.setItem('paymentScheduleInterval', interval);
        
        // Save start date if selected
        if (selectedDates && selectedDates.length > 0) {
            const date = selectedDates[0];
            const startDate = {
                year: date.year,
                month: date.month,
                day: date.day
            };
            localStorage.setItem('paymentScheduleStartDate', JSON.stringify(startDate));
        }
    }
    
    // Verify the config was saved
    setTimeout(() => {
        const savedConfig = document.getElementById('recurring_interval').value;
        console.log('Config verification after save:', savedConfig);
        console.log('Config verification length:', savedConfig ? savedConfig.length : 0);
    }, 50);
    
    // Show the current configuration
    showCurrentConfig();
    
    // If variable amounts are enabled, regenerate the payment inputs
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log('Regenerating payment inputs after config save...');
        // Add a small delay to ensure the configuration is properly saved
        setTimeout(() => {
            generatePaymentAmountInputs();
            // Don't disable save button after successful save - just update amounts
            updateAmountSummaryAfterSave();
        }, 100);
    }
    
    // Clear temporary storage since config is now saved
    tempRecurringConfig = '';
    
    closeRecurringModal();
}

function showCurrentConfig() {
    // Always show the edit button when this function is called
    document.getElementById('configureButton').style.display = 'block';
}

function saveConfigurationBeforeSubmit() {
    console.log(' DEBUG: saveConfigurationBeforeSubmit - saving configuration before form submission');
    
    // Check if we're in custom mode and save the configuration
    const customTab = document.getElementById('customTab');
    if (customTab && customTab.classList.contains('active')) {
        console.log(' DEBUG: saveConfigurationBeforeSubmit - custom tab is active, saving custom configuration');
        saveCustomConfigurationToHiddenField();
    } else {
        console.log(' DEBUG: saveConfigurationBeforeSubmit - monthly tab is active, saving monthly configuration');
        saveConfigurationToHiddenField();
    }
    
    // Log the final configuration
    const finalConfig = document.getElementById('recurring_interval').value;
    console.log(' DEBUG: saveConfigurationBeforeSubmit - final recurring_interval value:', finalConfig);
}

// Helper function to parse amount with commas
function parseAmountWithCommas(amountString) {
    if (!amountString) return 0;
    // Remove commas and parse as float
    return parseFloat(amountString.replace(/,/g, '')) || 0;
}

// Variable Amount Functions
function toggleVariableAmounts() {
    const toggle = document.getElementById('variableAmountsToggle');
    const section = document.getElementById('variableAmountsSection');
    const variableAmountsField = document.getElementById('variable_amounts');
    
    console.log(' DEBUG: toggleVariableAmounts - toggle checked:', toggle.checked);
    console.log(' DEBUG: toggleVariableAmounts - section element:', section);
    console.log(' DEBUG: toggleVariableAmounts - variable amounts field:', variableAmountsField);
    
    if (toggle.checked) {
        section.style.display = 'block';
        variableAmountsField.value = 'true';
        console.log(' DEBUG: toggleVariableAmounts - variable amounts enabled, generating inputs...');
        
        // Get the current amount
        const currentAmount = document.getElementById('amount').value;
        console.log(' DEBUG: toggleVariableAmounts - current amount:', currentAmount);
        
        // Check if we have a recurring configuration
        const recurringConfig = document.getElementById('recurring_interval').value;
        console.log(' DEBUG: toggleVariableAmounts - recurring config when toggling:', recurringConfig);
        console.log(' DEBUG: toggleVariableAmounts - recurring config length:', recurringConfig ? recurringConfig.length : 0);
        console.log(' DEBUG: toggleVariableAmounts - recurring config type:', typeof recurringConfig);
        
        generatePaymentAmountInputs();
        updateAmountSummary();
    } else {
        section.style.display = 'none';
        variableAmountsField.value = 'false';
        document.getElementById('payment_schedule').value = '[]';
    }
}

function generatePaymentAmountInputs() {
    const container = document.getElementById('paymentAmountsList');
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    
    console.log(' DEBUG: generatePaymentAmountInputs - starting');
    console.log('Container element:', container);
    console.log('Total amount:', totalAmount);
    
    if (!container) {
        console.error('Payment amounts list container not found!');
        return;
    }
    
    // Check for existing schedule data in the hidden field
    const existingScheduleData = document.getElementById('payment_schedule').value;
    console.log(' DEBUG: generatePaymentAmountInputs - existing schedule data:', existingScheduleData);
    
    let existingSchedule = [];
    if (existingScheduleData && existingScheduleData !== '[]') {
        try {
            existingSchedule = JSON.parse(existingScheduleData);
            console.log(' DEBUG: generatePaymentAmountInputs - parsed existing schedule:', existingSchedule);
        } catch (e) {
            console.error('Error parsing existing schedule data:', e);
        }
    }
    
    // Get the selected dates from the schedule
    const scheduleDates = getScheduleDates();
    console.log(' DEBUG: generatePaymentAmountInputs - schedule dates:', scheduleDates);
    console.log(' DEBUG: generatePaymentAmountInputs - schedule dates length:', scheduleDates ? scheduleDates.length : 0);
    
    container.innerHTML = '';
    
    if (scheduleDates.length === 0) {
        // If no schedule dates are available, generate some default dates using user's saved choices
        console.log('No schedule dates found, generating default dates using user choices...');
        const defaultDates = generateDefaultDatesWithUserChoices();
        console.log('Default dates generated with user choices:', defaultDates);
        
        defaultDates.forEach((date, index) => {
            // Find existing amount for this date
            const existingAmount = existingSchedule.find(item => item.date === date)?.amount || 0;
            console.log(` DEBUG: generatePaymentAmountInputs - date ${date}, existing amount: ${existingAmount}`);
            
            const paymentDiv = document.createElement('div');
            paymentDiv.className = 'payment-amount-item';
            paymentDiv.innerHTML = `
                <div class="payment-info">
                    <label>Payment ${index + 1}:</label>
                    <span class="payment-date">${date}</span>
                </div>
                <div class="amount-input-container">
                    <span class="currency-symbol">OMR</span>
                    <input type="number" 
                           class="payment-amount-input" 
                           step="0.001" 
                           min="0" 
                           max="${totalAmount}"
                           placeholder="0.000"
                           value="${existingAmount}"
                           onchange="validateAndUpdateAmount(this)" onkeydown="handleVariableAmountKeyPress(event, this)"
                           data-payment-index="${index}"
                           data-payment-date="${date}">
                </div>
                <div class="payment-actions">
                    <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            container.appendChild(paymentDiv);
        });
    } else {
        scheduleDates.forEach((date, index) => {
            // Find existing amount for this date
            const existingAmount = existingSchedule.find(item => item.date === date)?.amount || 0;
            console.log(` DEBUG: generatePaymentAmountInputs - date ${date}, existing amount: ${existingAmount}`);
            
            const paymentDiv = document.createElement('div');
            paymentDiv.className = 'payment-amount-item';
            paymentDiv.innerHTML = `
                <div class="payment-info">
                    <label>Payment ${index + 1}:</label>
                    <span class="payment-date">${date}</span>
                </div>
                <div class="amount-input-container">
                    <span class="currency-symbol">OMR</span>
                    <input type="number" 
                           class="payment-amount-input" 
                           step="0.001" 
                           min="0" 
                           max="${totalAmount}"
                           placeholder="0.000"
                           value="${existingAmount}"
                           onchange="validateAndUpdateAmount(this)" onkeydown="handleVariableAmountKeyPress(event, this)"
                           data-payment-index="${index}"
                           data-payment-date="${date}">
                </div>
                <div class="payment-actions">
                    <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            container.appendChild(paymentDiv);
        });
    }
    
    // Update total amount display
    const totalAmountDisplay = document.getElementById('totalAmountDisplay');
    if (totalAmountDisplay) {
        totalAmountDisplay.textContent = totalAmount.toFixed(3);
    }
    
    // Update add button state and amount summary
    updateAddButtonState();
    updateAmountSummary();
    
    console.log(' DEBUG: generatePaymentAmountInputs - completed successfully');
}

function generatePaymentAmountInputsFromSchedule(paymentSchedule) {
    console.log(' DEBUG: generatePaymentAmountInputsFromSchedule - starting with schedule:', paymentSchedule);
    
    const container = document.getElementById('paymentAmountsList');
    if (!container) {
        console.error('Payment amounts list container not found!');
        return;
    }
    
    // Clear existing inputs
    container.innerHTML = '';
    
    // Get the current amount
    const currentAmount = document.getElementById('amount').value;
    const totalAmount = parseAmountWithCommas(currentAmount);
    console.log(' DEBUG: generatePaymentAmountInputsFromSchedule - total amount:', totalAmount);
    
    if (!paymentSchedule || paymentSchedule.length === 0) {
        console.log(' DEBUG: generatePaymentAmountInputsFromSchedule - no payment schedule data');
        return;
    }
    
    // Create payment inputs for each scheduled payment
    paymentSchedule.forEach((payment, index) => {
        const paymentDiv = document.createElement('div');
        paymentDiv.className = 'payment-amount-item';
        paymentDiv.innerHTML = `
            <div class="payment-info">
                <label>Payment ${index + 1}:</label>
                <span class="payment-date">${payment.date}</span>
            </div>
            <div class="amount-input-container">
                <span class="currency-symbol">OMR</span>
                <input type="number" 
                       class="payment-amount-input" 
                       value="${payment.amount}" 
                       step="0.001" 
                       min="0" 
                       max="${totalAmount}"
                       data-payment-date="${payment.date}"
                       data-payment-index="${index}"
                       onchange="validateAndUpdateAmount(this)" 
                       onkeydown="handleVariableAmountKeyPress(event, this)">
            </div>
            <div class="payment-actions">
                <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        
        container.appendChild(paymentDiv);
    });
    
    // Update total amount display
    const totalAmountDisplay = document.getElementById('totalAmountDisplay');
    if (totalAmountDisplay) {
        totalAmountDisplay.textContent = totalAmount.toFixed(3);
    }
    
    // Update add button state and amount summary
    updateAddButtonState();
    updateAmountSummary();
    
    console.log(' DEBUG: generatePaymentAmountInputsFromSchedule - completed');
}

function generateDefaultDates() {
    // Generate default dates for the case where schedule isn't configured yet
    const dates = [];
    
    // Try to get the actual configured date from the recurring interval
    const config = document.getElementById('recurring_interval').value;
    console.log('Current config:', config);
    
    let startDate;
    
    if (config) {
        // Parse the configuration to get the actual selected date
        const parts = config.split(':');
        console.log('Config parts:', parts);
        
        // Try to extract date information from any configuration type
        startDate = extractStartDateFromConfig(parts);
        
        if (startDate) {
            console.log('Using configured start date:', startDate.toISOString().split('T')[0]);
        } else {
            console.log('Could not extract date from config, using current date');
            startDate = new Date();
        }
    } else {
        // Fallback to current date
        console.log('No config found, using current date');
        startDate = new Date();
    }
    
    // Start with just one payment date
    dates.push(startDate.toISOString().split('T')[0]);
    console.log('Generated default dates:', dates);
    
    return dates;
}

function generateDefaultDatesWithUserChoices() {
    console.log(' DEBUG: generateDefaultDatesWithUserChoices - starting');
    
    // Generate default dates using the user's saved choices
    const dates = [];
    
    // Get saved user choices
    const savedInterval = localStorage.getItem('paymentScheduleInterval');
    const savedStartDate = localStorage.getItem('paymentScheduleStartDate');
    console.log(' DEBUG: generateDefaultDatesWithUserChoices - saved interval:', savedInterval, 'saved start date:', savedStartDate);
    
    let startDate;
    let interval = 1; // Default interval
    
    // Use saved interval if available
    if (savedInterval) {
        interval = parseInt(savedInterval);
        console.log(' DEBUG: generateDefaultDatesWithUserChoices - using saved interval:', interval);
    } else {
        console.log(' DEBUG: generateDefaultDatesWithUserChoices - no saved interval, using default:', interval);
    }
    
    // Use saved start date if available
    if (savedStartDate) {
        try {
            const startDateData = JSON.parse(savedStartDate);
            console.log(' DEBUG: generateDefaultDatesWithUserChoices - parsed start date data:', startDateData);
            // Use the earliest day as the start date
            const earliestDay = Math.min(...startDateData.days);
            startDate = new Date(startDateData.year, startDateData.month, earliestDay);
            console.log(' DEBUG: generateDefaultDatesWithUserChoices - using saved start date:', startDate.toISOString().split('T')[0]);
        } catch (e) {
            console.error(' DEBUG: generateDefaultDatesWithUserChoices - error parsing saved start date:', e);
            startDate = new Date();
        }
    } else {
        console.log(' DEBUG: generateDefaultDatesWithUserChoices - no saved start date, checking config');
        // Try to get from current configuration
        const config = document.getElementById('recurring_interval').value;
        console.log(' DEBUG: generateDefaultDatesWithUserChoices - config:', config);
        if (config) {
            const parts = config.split(':');
            startDate = extractStartDateFromConfig(parts);
            console.log(' DEBUG: generateDefaultDatesWithUserChoices - extracted start date from config:', startDate);
        }
        
        if (!startDate) {
            console.log(' DEBUG: generateDefaultDatesWithUserChoices - no start date found, using current date');
            startDate = new Date();
        }
    }
    
    // Generate the first payment date (always the starting date)
    const firstDate = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
    dates.push(firstDate);
    
    console.log(' DEBUG: generateDefaultDatesWithUserChoices - final dates:', dates);
    return dates;
}

function extractStartDateFromConfig(parts) {
        const frequency = parts[0];
    
    if (frequency === 'monthly' && parts.length > 2 && parts[2] === 'days') {
        // Monthly configuration with specific days
        const days = parts[3].split(',').map(d => parseInt(d.trim()));
        const year = parseInt(parts[4]) || new Date().getFullYear();
        const month = parseInt(parts[5]) - 1 || new Date().getMonth(); // Convert 1-based to 0-based
        
        // Use the earliest day as the start date
        const earliestDay = Math.min(...days);
        
        console.log('Monthly config - days:', days, 'earliest day:', earliestDay, 'year:', year, 'month:', month);
        const date = new Date(year, month, earliestDay);
        console.log('Created date object:', date);
        console.log('Date ISO string:', date.toISOString());
        console.log('Date local string:', date.toLocaleDateString());
        return date;
    }
    
    return null;
}

function getScheduleDates() {
    // This function should extract dates from the current schedule configuration
    const config = document.getElementById('recurring_interval').value;
    console.log(' DEBUG: getScheduleDates - config:', config);
    
    if (!config) {
        console.log(' DEBUG: getScheduleDates - no config found, returning empty array');
        return [];
    }
    
    // Parse the configuration and generate dates
    const parts = config.split(':');
    const frequency = parts[0];
    console.log(' DEBUG: getScheduleDates - frequency:', frequency);
    
    const dates = [];
    
    if (frequency === 'custom') {
        // Handle custom dates
        console.log(' DEBUG: getScheduleDates - processing custom dates');
        
        if (parts.length > 1) {
            const customDatesString = parts[1];
            const customDatesArray = customDatesString.split(',');
            
            customDatesArray.forEach(dateAmountPair => {
                const [date, amount] = dateAmountPair.split(':');
                if (date) {
                    dates.push(date);
                    console.log(' DEBUG: getScheduleDates - custom date:', date, 'amount:', amount);
                }
            });
        }
        
        // Sort dates chronologically
        dates.sort((a, b) => new Date(a) - new Date(b));
        
        console.log(' DEBUG: getScheduleDates - final custom dates:', dates, 'total:', dates.length);
        return dates;
    }
    
    // Handle monthly configuration
    const interval = parseInt(parts[1]);
    console.log(' DEBUG: getScheduleDates - interval:', interval);
    
    // Get the start date from the specific settings using the flexible extractor
    let startDate = extractStartDateFromConfig(parts);
    console.log(' DEBUG: getScheduleDates - extracted start date:', startDate);
    
    if (!startDate) {
        console.log(' DEBUG: getScheduleDates - could not extract start date, using current date');
        startDate = new Date();
    }
    
    // Use local date formatting to avoid timezone issues
    const startDateString = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
    console.log(' DEBUG: getScheduleDates - using start date for schedule:', startDateString);
    
    // Check for end date in the configuration
    let endDate = null;
    const endDateIndex = parts.indexOf('end');
    if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
        endDate = new Date(parts[endDateIndex + 1]);
        console.log(' DEBUG: getScheduleDates - found end date:', parts[endDateIndex + 1], '-> parsed:', endDate);
    }
    
    // Generate payment dates based on the configuration
    if (frequency === 'monthly' && parts.length > 2 && parts[2] === 'date') {
        // Handle single date format
        const baseDate = parts[3];
        console.log(' DEBUG: getScheduleDates - base date:', baseDate);
        
        // Generate recurring payment dates based on the interval
        const startDate = new Date(baseDate);
        let numPayments = endDate ? 100 : 4; // Generate up to 100 if end date exists, otherwise 4
        
        for (let i = 0; i < numPayments; i++) {
            const paymentDate = new Date(startDate);
            paymentDate.setMonth(paymentDate.getMonth() + (interval * i));
            
            // Check if this payment date exceeds the end date
            if (endDate && paymentDate > endDate) {
                console.log(` DEBUG: getScheduleDates - payment ${i + 1} exceeds end date, stopping`);
                break;
            }
            
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            dates.push(dateString);
            console.log(` DEBUG: getScheduleDates - payment ${i + 1}:`, dateString);
        }
    } else if (frequency === 'monthly' && parts.length > 2 && parts[2] === 'days') {
        // Handle old format for backward compatibility (single month, multiple days)
        const days = parts[3].split(',').map(d => parseInt(d.trim()));
        const year = parseInt(parts[4]) || new Date().getFullYear();
        const month = parseInt(parts[5]) - 1 || new Date().getMonth(); // Convert 1-based to 0-based
        
        console.log(' DEBUG: getScheduleDates - generating dates for multiple days:', days, 'year:', year, 'month:', month);
        
        // Generate dates for all days in the first occurrence
        for (const day of days) {
            const paymentDate = new Date(year, month, day);
            
            // Check if this payment date exceeds the end date
            if (endDate && paymentDate > endDate) {
                console.log(` DEBUG: getScheduleDates - payment date exceeds end date, skipping`);
                continue;
            }
            
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            dates.push(dateString);
        }
    } else {
        // Generate payment dates based on the configuration (monthly only)
        console.log(' DEBUG: getScheduleDates - generating payment dates with interval:', interval);
        let numPayments = endDate ? 100 : 4; // Generate up to 100 if end date exists, otherwise 4
        
        for (let i = 0; i < numPayments; i++) {
            const paymentDate = new Date(startDate);
            
            // All payments are monthly - use the user's chosen interval
            paymentDate.setMonth(paymentDate.getMonth() + (interval * i));
            
            // Check if this payment date exceeds the end date
            if (endDate && paymentDate > endDate) {
                console.log(` DEBUG: getScheduleDates - payment ${i + 1} exceeds end date, stopping`);
                break;
            }
            
            // Use local date formatting to avoid timezone issues
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            console.log(` DEBUG: getScheduleDates - payment ${i + 1} date:`, dateString, '(added', interval * i, 'months)');
            dates.push(dateString);
        }
    }
    
    console.log(' DEBUG: getScheduleDates - final generated dates:', dates, 'total:', dates.length);
    return dates;
}

function updateAmountSummary() {
    const inputs = document.querySelectorAll('.payment-amount-input');
    let totalAllocated = 0;
    
    inputs.forEach(input => {
        const amount = parseFloat(input.value) || 0;
        totalAllocated += amount;
    });
    
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    const remaining = totalAmount - totalAllocated;
    
    document.getElementById('totalAllocated').textContent = totalAllocated.toFixed(3);
    document.getElementById('remainingAmount').textContent = remaining.toFixed(3);
    
    // Check if total allocated doesn't match the total amount
    const isMismatch = totalAmount > 0 && Math.abs(totalAllocated - totalAmount) > 0.001;
    
    if (isMismatch) {
        // Show alert if there's a mismatch
        const mismatchAlert = document.getElementById('amountMismatchAlert');
        if (mismatchAlert) {
            mismatchAlert.style.display = 'block';
    } else {
            // Create alert if it doesn't exist
            createAmountMismatchAlert();
        }
    } else {
        // Hide alert if amounts match
        const mismatchAlert = document.getElementById('amountMismatchAlert');
        if (mismatchAlert) {
            mismatchAlert.style.display = 'none';
        }
    }
    
    // Enable/disable Save Configuration button based on amount match
    // Only disable if we're not in post-save mode (i.e., during active editing)
    const saveButton = document.querySelector('button[onclick="saveRecurringConfig()"]');
    if (saveButton && !window.isPostSaveMode) {
        if (isMismatch) {
            saveButton.disabled = true;
            saveButton.style.opacity = '0.5';
            saveButton.style.cursor = 'not-allowed';
        } else {
            saveButton.disabled = false;
            saveButton.style.opacity = '1';
            saveButton.style.cursor = 'pointer';
        }
    }
    
    // Update the payment schedule data
    updatePaymentSchedule();
    
    // Update the add button state
    updateAddButtonState();
}

function updateAmountSummaryAfterSave() {
    // Set post-save mode to temporarily disable amount validation
    window.isPostSaveMode = true;
    
    const inputs = document.querySelectorAll('.payment-amount-input');
    let totalAllocated = 0;
    
    inputs.forEach(input => {
        const amount = parseFloat(input.value) || 0;
        totalAllocated += amount;
    });
    
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    const remaining = totalAmount - totalAllocated;
    
    document.getElementById('totalAllocated').textContent = totalAllocated.toFixed(3);
    document.getElementById('remainingAmount').textContent = remaining.toFixed(3);
    
    // Check if total allocated doesn't match the total amount
    const isMismatch = totalAmount > 0 && Math.abs(totalAllocated - totalAmount) > 0.001;
    
    if (isMismatch) {
        // Show alert if there's a mismatch
        const mismatchAlert = document.getElementById('amountMismatchAlert');
        if (mismatchAlert) {
            mismatchAlert.style.display = 'block';
        } else {
            // Create alert if it doesn't exist
            createAmountMismatchAlert();
        }
    } else {
        // Hide alert if amounts match
        const mismatchAlert = document.getElementById('amountMismatchAlert');
        if (mismatchAlert) {
            mismatchAlert.style.display = 'none';
        }
    }
    
    // Update the payment schedule data
    updatePaymentSchedule();
    
    // Update the add button state
    updateAddButtonState();
    
    // After a successful save, we need to re-enable validation for future edits
    // Set a flag to indicate we're now in "editing mode" again
    setTimeout(() => {
        window.isPostSaveMode = false;
        // Re-enable amount validation for future edits
        updateAmountSummary();
    }, 100);
}

// Prevent form submission when Enter is pressed in recurring payment modal
document.addEventListener('DOMContentLoaded', function() {
    // Add event listener to prevent Enter key from submitting form when in recurring modal
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            // Check if we're in the recurring payment modal
            const recurringModal = document.getElementById('recurringModal');
            if (recurringModal && recurringModal.style.display !== 'none') {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }
    });
    
    // Also prevent form submission on Enter in the main form when recurring modal is open
    const mainForm = document.querySelector('form');
    if (mainForm) {
        mainForm.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                const recurringModal = document.getElementById('recurringModal');
                if (recurringModal && recurringModal.style.display !== 'none') {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }
        });
    }
});

function createAmountMismatchAlert() {
    // Create the alert element
    const alertDiv = document.createElement('div');
    alertDiv.id = 'amountMismatchAlert';
    alertDiv.className = 'alert alert-warning';
    alertDiv.style.cssText = 'margin: 10px 0; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; color: #856404; display: block;';
    alertDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        <strong>Amount Mismatch:</strong> Please ensure the total allocated amount matches the total amount (OMR ${parseAmountWithCommas(document.getElementById('amount').value).toFixed(3)}).
    `;
    
    // Find the variable amounts section and insert the alert
    const variableAmountsSection = document.querySelector('.variable-amounts-section');
    if (variableAmountsSection) {
        variableAmountsSection.insertBefore(alertDiv, variableAmountsSection.firstChild);
    }
}

function updatePaymentSchedule() {
    const inputs = document.querySelectorAll('.payment-amount-input');
    const schedule = [];
    
    inputs.forEach(input => {
        const amount = parseFloat(input.value) || 0;
        if (amount > 0) {
            // Get the date from the data attribute
            const paymentDate = input.getAttribute('data-payment-date');
            console.log(' DEBUG: updatePaymentSchedule - input amount:', amount, 'date:', paymentDate);
            schedule.push({
                date: paymentDate,
                amount: amount
            });
        }
    });
    
    console.log(' DEBUG: updatePaymentSchedule - final schedule:', schedule);
    document.getElementById('payment_schedule').value = JSON.stringify(schedule);
}

// New functions for dynamic payment management

function addNewPayment() {
    console.log(' DEBUG: addNewPayment - starting to add new payment');
    
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    const remainingAmount = getRemainingAmount();
    console.log(' DEBUG: addNewPayment - total amount:', totalAmount, 'remaining amount:', remainingAmount);
    
    // Check if there's remaining amount to allocate
    if (remainingAmount <= 0) {
        alert('Cannot add more payments. All amount has been allocated.');
        return;
    }
    
    // Get the recurring configuration to determine selected days
    const config = document.getElementById('recurring_interval').value;
    console.log(' DEBUG: addNewPayment - config:', config);
    
    if (!config) {
        alert('No recurring configuration found. Please configure recurring payment first.');
        return;
    }
    
    const parts = config.split(':');
    const interval = parseInt(parts[1]); // Get the user's chosen interval
    console.log(' DEBUG: addNewPayment - parsed interval:', interval);
    
    // Check for end date in the configuration
    let endDate = null;
    const endDateIndex = parts.indexOf('end');
    if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
        endDate = new Date(parts[endDateIndex + 1]);
        console.log(' DEBUG: addNewPayment - found end date:', parts[endDateIndex + 1], '-> parsed:', endDate);
    }
    
    if (parts.length > 2 && parts[2] === 'date') {
        console.log(' DEBUG: addNewPayment - handling single date format');
        // Handle single date format
        const baseDate = parts[3];
        console.log(' DEBUG: addNewPayment - base date:', baseDate);
        
        // Get the current number of payments to determine the next payment
        const existingPayments = document.querySelectorAll('.payment-amount-item');
        const nextPaymentNumber = existingPayments.length + 1;
        
        // Calculate the next payment date
        const startDate = new Date(baseDate);
        startDate.setMonth(startDate.getMonth() + (interval * existingPayments.length));
        
        // Check if this payment date exceeds the end date
        if (endDate && startDate > endDate) {
            alert('Cannot add more payments. The next payment date would exceed the end date.');
            console.log(' DEBUG: addNewPayment - next payment would exceed end date, aborting');
            return;
        }
        
        const dateString = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
        
        console.log(' DEBUG: addNewPayment - creating payment:', nextPaymentNumber, 'for date:', dateString);
        
        // Create the new payment element
        const container = document.getElementById('paymentAmountsList');
        const paymentDiv = document.createElement('div');
        paymentDiv.className = 'payment-amount-item';
        paymentDiv.innerHTML = `
            <div class="payment-info">
                <label>Payment ${nextPaymentNumber}:</label>
                <span class="payment-date">${dateString}</span>
            </div>
            <div class="amount-input-container">
                <span class="currency-symbol">OMR</span>
                <input type="number" 
                       class="payment-amount-input" 
                       step="0.001" 
                       min="0" 
                       max="${remainingAmount}"
                       placeholder="0.000"
                       onchange="validateAndUpdateAmount(this)" onkeydown="handleVariableAmountKeyPress(event, this)"
                       data-payment-index="${nextPaymentNumber - 1}"
                       data-payment-date="${dateString}">
            </div>
            <div class="payment-actions">
                <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        
        container.appendChild(paymentDiv);
    } else if (parts.length > 2 && parts[2] === 'days') {
        console.log(' DEBUG: addNewPayment - handling multiple days');
        // Handle multiple days for monthly payments
        const days = parts[3].split(',').map(d => parseInt(d.trim()));
        const year = parseInt(parts[4]) || new Date().getFullYear();
        const month = parseInt(parts[5]) - 1 || new Date().getMonth(); // Convert 1-based to 0-based
        
        console.log(' DEBUG: addNewPayment - days:', days, 'year:', year, 'month:', month);
        
        // Get the current number of payments to determine the next payment number
        const existingPayments = document.querySelectorAll('.payment-amount-item');
        const nextPaymentNumber = existingPayments.length + 1;
        
        // Calculate how many complete payment cycles we've had
        // Each cycle includes all selected days
        const paymentCycles = Math.floor((nextPaymentNumber - 1) / days.length);
        // Add the interval for the next cycle (paymentCycles already represents completed cycles)
        const nextMonth = month + (interval * paymentCycles);
        
        console.log(' DEBUG: addNewPayment - payment cycles:', paymentCycles, 'next payment number:', nextPaymentNumber, 'next month:', nextMonth);
        
        // Generate new payment dates for all selected days
        const container = document.getElementById('paymentAmountsList');
        
        for (let i = 0; i < days.length; i++) {
            const day = days[i];
            const paymentDate = new Date(year, nextMonth, day);
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            
            console.log(' DEBUG: addNewPayment - creating payment for day:', day, 'date:', dateString);
            
            const paymentDiv = document.createElement('div');
            paymentDiv.className = 'payment-amount-item';
            paymentDiv.innerHTML = `
                <div class="payment-info">
                    <label>Payment ${nextPaymentNumber + i}:</label>
                    <span class="payment-date">${dateString}</span>
                </div>
                <div class="amount-input-container">
                    <span class="currency-symbol">OMR</span>
                    <input type="number" 
                           class="payment-amount-input" 
                           step="0.001" 
                           min="0" 
                           max="${remainingAmount}"
                           placeholder="0.000"
                           onchange="validateAndUpdateAmount(this)" onkeydown="handleVariableAmountKeyPress(event, this)"
                           data-payment-index="${nextPaymentNumber + i - 1}"
                           data-payment-date="${dateString}">
                </div>
                <div class="payment-actions">
                    <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            container.appendChild(paymentDiv);
        }
    } else {
        console.log(' DEBUG: addNewPayment - handling single day with interval:', interval);
        // Handle single day or other frequencies using dynamic interval
        const nextDate = generateNextPaymentDateWithInterval(interval);
        
        // Get the current number of payments to determine the next payment number
        const existingPayments = document.querySelectorAll('.payment-amount-item');
        const nextPaymentNumber = existingPayments.length + 1;
        
        console.log(' DEBUG: addNewPayment - next payment number:', nextPaymentNumber, 'next date:', nextDate);
        
        // Create the new payment element
        const container = document.getElementById('paymentAmountsList');
        const paymentDiv = document.createElement('div');
        paymentDiv.className = 'payment-amount-item';
        paymentDiv.innerHTML = `
            <div class="payment-info">
                <label>Payment ${nextPaymentNumber}:</label>
                <span class="payment-date">${nextDate}</span>
            </div>
            <div class="amount-input-container">
                <span class="currency-symbol">OMR</span>
                <input type="number" 
                       class="payment-amount-input" 
                       step="0.001" 
                       min="0" 
                       max="${remainingAmount}"
                       placeholder="0.000"
                       onchange="validateAndUpdateAmount(this)" onkeydown="handleVariableAmountKeyPress(event, this)"
                       data-payment-index="${nextPaymentNumber - 1}"
                       data-payment-date="${nextDate}">
            </div>
            <div class="payment-actions">
                <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        
        container.appendChild(paymentDiv);
    }
    
    // Update the add button state
    updateAddButtonState();
    console.log(' DEBUG: addNewPayment - completed');
}

function generateNextPaymentDate() {
    // Get the last payment date and add 2 months (fallback for backward compatibility)
    const existingDates = Array.from(document.querySelectorAll('.payment-date')).map(el => el.textContent);
    if (existingDates.length === 0) {
        return '2025-10-14'; // First payment date
    }
    
    const lastDate = new Date(existingDates[existingDates.length - 1]);
    const nextDate = new Date(lastDate);
    nextDate.setMonth(nextDate.getMonth() + 2); // Add 2 months
    
    return nextDate.toISOString().split('T')[0];
}

function generateNextPaymentDateWithInterval(interval) {
    console.log(' DEBUG: generateNextPaymentDateWithInterval - interval:', interval);
    
    // Get the last payment date and add the user's chosen interval
    const existingDates = Array.from(document.querySelectorAll('.payment-date')).map(el => el.textContent);
    console.log(' DEBUG: generateNextPaymentDateWithInterval - existing dates:', existingDates);
    
    if (existingDates.length === 0) {
        // If no existing dates, get the start date from the configuration
        const config = document.getElementById('recurring_interval').value;
        console.log(' DEBUG: generateNextPaymentDateWithInterval - no existing dates, checking config:', config);
        
        if (config) {
            const parts = config.split(':');
            const startDate = extractStartDateFromConfig(parts);
            if (startDate) {
                const dateString = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
                console.log(' DEBUG: generateNextPaymentDateWithInterval - using start date from config:', dateString);
                return dateString;
            }
        }
        console.log(' DEBUG: generateNextPaymentDateWithInterval - using fallback date');
        return '2025-10-14'; // Fallback first payment date
    }
    
    const lastDate = new Date(existingDates[existingDates.length - 1]);
    const nextDate = new Date(lastDate);
    console.log(' DEBUG: generateNextPaymentDateWithInterval - last date:', lastDate, 'adding', interval, 'months');
    
    nextDate.setMonth(nextDate.getMonth() + interval); // Add the user's chosen interval
    
    const result = nextDate.toISOString().split('T')[0];
    console.log(' DEBUG: generateNextPaymentDateWithInterval - result:', result);
    return result;
}

function removePayment(button) {
    const paymentItem = button.closest('.payment-amount-item');
    paymentItem.remove();
    
    // Renumber the remaining payments
    renumberPayments();
    updateAmountSummary();
    updateAddButtonState();
}

function renumberPayments() {
    const paymentItems = document.querySelectorAll('.payment-amount-item');
    paymentItems.forEach((item, index) => {
        const label = item.querySelector('label');
        if (label) {
            label.textContent = `Payment ${index + 1}:`;
        }
    });
}

function handleVariableAmountKeyPress(event, input) {
    console.log(' DEBUG: handleVariableAmountKeyPress - key pressed:', event.key, 'input:', input);
    if (event.key === 'Enter') {
        console.log(' DEBUG: handleVariableAmountKeyPress - Enter key detected, calling validateAndUpdateAmount');
        event.preventDefault();
        validateAndUpdateAmount(input);
    }
}

function validateAndUpdateAmount(input) {
    const enteredAmount = parseFloat(input.value) || 0;
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    
    // First, get the remaining amount BEFORE this input is considered
    const otherInputs = Array.from(document.querySelectorAll('.payment-amount-input')).filter(inp => inp !== input);
    let otherAllocated = 0;
    otherInputs.forEach(inp => {
        otherAllocated += parseFloat(inp.value) || 0;
    });
    const remainingAmount = totalAmount - otherAllocated;
    
    // Check if the entered amount exceeds the total amount
    if (enteredAmount > totalAmount) {
        alert(`Cannot allocate more than the total amount (${totalAmount.toFixed(3)} OMR).`);
        input.value = totalAmount.toFixed(3);
        updateInputMaxValues();
        updateAmountSummary();
        return;
    }
    
    // Check if the entered amount exceeds the remaining amount (allowing for small floating point differences)
    if (enteredAmount > remainingAmount + 0.001) {
        alert(`Cannot allocate more than the remaining amount (${remainingAmount.toFixed(3)} OMR).`);
        input.value = remainingAmount.toFixed(3);
    }
    
    // Update the max attribute for all inputs
    updateInputMaxValues();
    updateAmountSummary();
}

function getRemainingAmount() {
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    const inputs = document.querySelectorAll('.payment-amount-input');
    let totalAllocated = 0;
    
    inputs.forEach(input => {
        totalAllocated += parseFloat(input.value) || 0;
    });
    
    return totalAmount - totalAllocated;
}

function updateInputMaxValues() {
    const totalAmount = parseAmountWithCommas(document.getElementById('amount').value);
    const inputs = document.querySelectorAll('.payment-amount-input');
    
    inputs.forEach(input => {
        // Calculate remaining amount excluding this specific input
        const otherInputs = Array.from(inputs).filter(inp => inp !== input);
        let otherAllocated = 0;
        otherInputs.forEach(inp => {
            otherAllocated += parseFloat(inp.value) || 0;
        });
        const remainingAmount = totalAmount - otherAllocated;
        
        input.max = Math.max(0, remainingAmount);
    });
}

function updateAddButtonState() {
    const addButton = document.getElementById('addPaymentBtn');
    const remainingAmount = getRemainingAmount();
    
    // Check if the next payment would exceed the end date
    const config = document.getElementById('recurring_interval').value;
    let isEndDateExceeded = false;
    
    if (config) {
        const parts = config.split(':');
        const endDateIndex = parts.indexOf('end');
        
        if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
            const endDate = new Date(parts[endDateIndex + 1]);
            
            // Calculate what the next payment date would be
            if (parts.length > 2 && parts[2] === 'date') {
                const baseDate = parts[3];
                const interval = parseInt(parts[1]);
                const existingPayments = document.querySelectorAll('.payment-amount-item');
                
                const nextPaymentDate = new Date(baseDate);
                nextPaymentDate.setMonth(nextPaymentDate.getMonth() + (interval * existingPayments.length));
                
                if (nextPaymentDate > endDate) {
                    isEndDateExceeded = true;
                }
            }
        }
    }
    
    if (remainingAmount <= 0) {
        addButton.disabled = true;
        addButton.innerHTML = '<i class="fas fa-plus"></i> All Amount Allocated';
        addButton.style.opacity = '0.5';
    } else if (isEndDateExceeded) {
        addButton.disabled = true;
        addButton.innerHTML = '<i class="fas fa-plus"></i> End Date Reached';
        addButton.style.opacity = '0.5';
    } else {
        addButton.disabled = false;
        addButton.innerHTML = '<i class="fas fa-plus"></i> Add Payment';
        addButton.style.opacity = '1';
    }
}

// Add real-time validation for account number
document.getElementById('account_number').addEventListener('input', function(e) {
    const value = e.target.value;
    // Remove any non-numeric characters as user types
    const numericValue = value.replace(/[^0-9]/g, '');
    if (value !== numericValue) {
        e.target.value = numericValue;
    }
    // Limit to 16 digits
    if (numericValue.length > 16) {
        e.target.value = numericValue.substring(0, 16);
    }
});

// Add comma formatting for amount field
document.getElementById('amount').addEventListener('input', function(e) {
    let value = e.target.value;
    
    // Remove any non-numeric characters except decimal point
    const cleanValue = value.replace(/[^0-9.]/g, '');
    
    // Handle multiple decimal points - keep only the first one
    const parts = cleanValue.split('.');
    if (parts.length > 2) {
        value = parts[0] + '.' + parts.slice(1).join('');
    } else {
        value = cleanValue;
    }
    
    // Format with commas for thousands
    if (value) {
        const parts = value.split('.');
        const integerPart = parts[0];
        const decimalPart = parts.length > 1 ? '.' + parts[1] : '';
        
        // Add commas to integer part
        const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        
        e.target.value = formattedInteger + decimalPart;
    }
});

// Allow only numbers and decimal point in amount field
document.getElementById('amount').addEventListener('keydown', function(e) {
    // Allow: backspace, delete, tab, escape, enter, decimal point
    if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
        // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
        (e.keyCode === 65 && e.ctrlKey === true) ||
        (e.keyCode === 67 && e.ctrlKey === true) ||
        (e.keyCode === 86 && e.ctrlKey === true) ||
        (e.keyCode === 88 && e.ctrlKey === true) ||
        // Allow: home, end, left, right, down, up
        (e.keyCode >= 35 && e.keyCode <= 40)) {
        return;
    }
    // Ensure that it is a number and stop the keypress
    if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
        e.preventDefault();
    }
});

// Comprehensive form validation function
function validateRequestForm() {
    const errors = [];
    let firstErrorField = null;
    
    // Validate Request Type
    const requestType = document.getElementById('request_type').value;
    if (!requestType) {
        errors.push('Please select a request type.');
        if (!firstErrorField) firstErrorField = document.getElementById('request_type');
    }
    
    // Validate Requestor Name
    const requestorName = document.getElementById('requestor_name').value.trim();
    if (!requestorName) {
        errors.push('Please enter your name.');
        if (!firstErrorField) firstErrorField = document.getElementById('requestor_name');
    }
    
    // Validate Branch Name - check for at least one branch selected
    const branchNames = document.getElementById('branch_names').value;
    if (!branchNames || branchNames.trim() === '') {
        errors.push('Please select at least one branch name.');
        if (!firstErrorField) firstErrorField = document.getElementById('branch_search');
    }
    
    // Validate Person/Company Name - check if supplier dropdown is visible
    const personCompanyContainer = document.getElementById('person_company_select_container');
    if (personCompanyContainer && personCompanyContainer.style.display !== 'none') {
        // Supplier dropdown is visible, validate it
        const personCompanySelect = document.getElementById('person_company_select');
        const personCompanyValue = personCompanySelect ? personCompanySelect.value : '';
        
        if (!personCompanyValue) {
            errors.push('Please select a supplier from the dropdown.');
            if (!firstErrorField) firstErrorField = document.getElementById('person_company_search');
        } else {
            // Validate that the selected value is in the allowed options for the current department and request type
            const department = document.getElementById('department').value;
            // Validate that the selected value is in the allowed options
            // Get allowed suppliers from the select element options
            const allowedSuppliers = Array.from(personCompanySelect.options).map(opt => opt.value).filter(v => v);
            if (!allowedSuppliers.includes(personCompanyValue)) {
                errors.push('Invalid supplier selected. Please select a valid supplier from the dropdown.');
                if (!firstErrorField) firstErrorField = document.getElementById('person_company_search');
            }
        }
    } else {
        // Text input is visible, validate it
        const personCompanyInput = document.getElementById('person_company');
        if (personCompanyInput && !personCompanyInput.value.trim()) {
            errors.push('Please enter a person/company name.');
            if (!firstErrorField) firstErrorField = personCompanyInput;
        }
    }
    
    // Validate dynamic fields based on request type
    if (requestType === 'Others') {
        const othersDescription = document.getElementById('others_description').value.trim();
        if (!othersDescription) {
            errors.push('Please specify the type of request.');
            if (!firstErrorField) firstErrorField = document.getElementById('others_description');
        }
    }
    
    // Validate Purpose/Description
    const purpose = document.getElementById('purpose').value.trim();
    if (!purpose) {
        errors.push('Please enter a purpose/description for this request.');
        if (!firstErrorField) firstErrorField = document.getElementById('purpose');
    }
    
    // Validate Payment Method
    const paymentMethod = document.getElementById('payment_method').value;
    if (!paymentMethod) {
        errors.push('Please select a payment method.');
        if (!firstErrorField) firstErrorField = document.getElementById('payment_method');
    }
    
    // Validate Bank Name
    const bankName = document.getElementById('bank_name').value;
    if (!bankName) {
        errors.push('Please select a bank name.');
        if (!firstErrorField) firstErrorField = document.getElementById('bank_name');
    }
    
    // Validate Account Name
    const accountName = document.getElementById('account_name').value.trim();
    if (!accountName) {
        errors.push('Please enter an account name.');
        if (!firstErrorField) firstErrorField = document.getElementById('account_name');
    }
    
    // Validate Account Number (only if payment method is Card)
    if (paymentMethod === 'Card') {
        const accountNumber = document.getElementById('account_number').value.trim();
        if (!accountNumber) {
            errors.push('Please enter an account number.');
            if (!firstErrorField) firstErrorField = document.getElementById('account_number');
        } else {
            if (!/^\d+$/.test(accountNumber)) {
                errors.push('Account number must contain only numbers.');
                if (!firstErrorField) firstErrorField = document.getElementById('account_number');
            } else if (accountNumber.length > 16) {
                errors.push('Account number cannot exceed 16 digits.');
                if (!firstErrorField) firstErrorField = document.getElementById('account_number');
            }
        }
    }
    
    // Validate Amount
    const amountValue = document.getElementById('amount').value.replace(/,/g, '');
    const amount = parseFloat(amountValue);
    if (!amountValue || isNaN(amount) || amount <= 0) {
        errors.push('Please enter a valid amount greater than 0.');
        if (!firstErrorField) firstErrorField = document.getElementById('amount');
    }
    
    // Validate Recurring Payment Schedule (if Recurring is selected)
    const recurring = document.getElementById('recurring').value;
    const recurringInterval = document.getElementById('recurring_interval').value;
    if (recurring === 'Recurring' && !recurringInterval) {
        errors.push('Please configure the recurring payment schedule by clicking "Edit Payment Schedule".');
        if (!firstErrorField) firstErrorField = document.getElementById('recurring');
    }
    
    // Return validation result
    return {
        isValid: errors.length === 0,
        errors: errors,
        firstErrorField: firstErrorField
    };
}

// Form validation
document.getElementById('requestForm').addEventListener('submit', function(e) {
    const validation = validateRequestForm();
    
    if (!validation.isValid) {
        e.preventDefault();
        
        // Show all errors in a single alert
        let errorMessage = 'Please fix the following errors before submitting:\n\n';
        errorMessage += validation.errors.map((error, index) => `${index + 1}. ${error}`).join('\n');
        
        alert(errorMessage);
        
        // Focus on the first error field
        if (validation.firstErrorField) {
            validation.firstErrorField.focus();
            validation.firstErrorField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        return false;
    }
    
    // If supplier dropdown is used, ensure the value is set in the hidden person_company field
    const personCompanyContainer = document.getElementById('person_company_select_container');
    if (personCompanyContainer && personCompanyContainer.style.display !== 'none') {
        const personCompanySelect = document.getElementById('person_company_select');
        const personCompanyInput = document.getElementById('person_company');
        if (personCompanySelect && personCompanySelect.value) {
            personCompanyInput.value = personCompanySelect.value;
        }
    }
});

// Function to show SWIFT code when bank is selected
function showSwiftCode() {
    const bankSelect = document.getElementById('bank_name');
    const swiftDisplay = document.getElementById('swift-code-display');
    const swiftText = document.getElementById('swift-code-text');
    
    // Check if all required elements exist
    if (!bankSelect || !swiftDisplay || !swiftText) {
        console.error('SWIFT code elements not found');
        return;
    }
    
    const swiftCodes = {
        'Bank Dhofar': 'BDOFOMRU',
        'Bank Muscat': 'BMUSOMRX',
        'National Bank of Oman': 'NBOMOMRX',
        'Oman Arab Bank': 'OMABOMRU',
        'Bank Sohar': 'BSHROMRU',
        'HSBC Bank Oman': 'BBMEOMRX',
        'Ahli Bank': 'AUBOOMRU',
        'Oman Development Bank': 'ODBLOMRX',
        'Oman Housing Bank': 'OHLBOMRU',
        'Meethaq Islamic Banking (Bank Dhofar)': 'BDOFOMRUMIB',
        'Meethaq Islamic Banking (Bank Muscat)': 'BMUSOMRXISL',
        'Muzn Islamic Banking (National Bank of Oman)': 'NBOMOMRXIBS',
        'Al Hilal Islamic Banking (Ahli Bank)': 'AUBOOMRUALH',
        'National Bank of Abu Dhabi': 'NBADOMRX',
        'Qatar National Bank': 'QNBAOMRX',
        'Standard Chartered Bank': 'SCBLOMRX',
        'Bank of Baroda': 'BABEOMRX',
        'Bank of Beirut': 'BARBOMMX',
        'State Bank of India': 'SBINOMRX',
        'Habib Bank AG Zurich': 'HABBOMRX',
        'Alizz Islamic Bank': 'IZZBOMRU',
            'Sohar Islamic (Sohar Bank)': 'BSHROMRUISL',
            'Al Yusr Islamic Banking Services (Oman Arab Bank)': 'OMABOMRUYSR',
            'Bank Nizwa': 'BNZWOMRX',
            'Mashreq Bank': 'BOMLAEAD'
        };
    
    const selectedBank = bankSelect.value ? bankSelect.value.trim() : '';
    
    if (selectedBank && swiftCodes[selectedBank]) {
        swiftText.textContent = swiftCodes[selectedBank];
        swiftDisplay.style.display = 'block';
    } else {
        swiftDisplay.style.display = 'none';
    }
}

// Global array to store all selected files
let allSelectedFiles = [];

// Add Files button functionality
document.getElementById('add-files-btn').addEventListener('click', function() {
    document.getElementById('receipt_files').click();
});

// File selection handling
document.getElementById('receipt_files').addEventListener('change', function(e) {
    const newFiles = Array.from(e.target.files);
    const maxFileSize = 50 * 1024 * 1024; // 50MB in bytes
    const allowedExtensions = ['pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx'];
    
    const validFiles = [];
    const errors = [];
    
    // Validate each file before adding
    newFiles.forEach(file => {
        // Check if file already exists (by name and size)
        const exists = allSelectedFiles.some(existingFile => 
            existingFile.name === file.name && existingFile.size === file.size
        );
        
        if (exists) {
            return; // Skip duplicate files
        }
        
        // Validate file size
        if (file.size > maxFileSize) {
            errors.push(`File "${file.name}" is too large. Maximum size is 50MB. Your file is ${(file.size / 1024 / 1024).toFixed(2)}MB.`);
            return;
        }
        
        // Validate file extension
        const fileExtension = file.name.split('.').pop().toLowerCase();
        if (!allowedExtensions.includes(fileExtension)) {
            errors.push(`Invalid file type for "${file.name}". Allowed types: PDF, JPG, PNG, DOC, DOCX, XLS, XLSX`);
            return;
        }
        
        // File is valid
        validFiles.push(file);
    });
    
    // Show validation errors if any
    if (errors.length > 0) {
        alert(errors.join('\n\n'));
    }
    
    // Add only valid files to the global array
    if (validFiles.length > 0) {
        allSelectedFiles.push(...validFiles);
        updateFilePreview();
    }
    
    // Clear the file input to prevent showing old file names
    e.target.value = '';
});

// Helper function to format file size intelligently
function formatFileSize(bytes) {
    if (bytes < 1024) {
        return bytes + ' B';
    } else if (bytes < 1024 * 1024) {
        return (bytes / 1024).toFixed(2) + ' KB';
    } else {
        return (bytes / 1024 / 1024).toFixed(2) + ' MB';
    }
}

function updateFilePreview() {
    const preview = document.getElementById('file-preview');
    const button = document.getElementById('add-files-btn');
    preview.innerHTML = '';
    
    if (allSelectedFiles.length > 0) {
        // Update button text when files are selected
        button.innerHTML = '<i class="fas fa-plus"></i> Add More Files';
        button.className = 'btn btn-outline-primary';
        
        const fileList = document.createElement('div');
        fileList.style.cssText = 'border: 1px solid #28a745; border-radius: 4px; padding: 10px; background: #d4edda;';
        
        // Calculate total size of all files
        const totalSize = allSelectedFiles.reduce((sum, file) => sum + file.size, 0);
        
        const header = document.createElement('div');
        header.style.cssText = 'font-weight: bold; margin-bottom: 8px; color: #155724; display: flex; align-items: center; justify-content: space-between;';
        
        const headerLeft = document.createElement('div');
        headerLeft.style.cssText = 'display: flex; align-items: center;';
        headerLeft.innerHTML = `<i class="fas fa-check-circle" style="margin-right: 8px; color: #28a745;"></i>Selected Files (${allSelectedFiles.length}):`;
        
        const headerRight = document.createElement('div');
        headerRight.style.cssText = 'display: flex; align-items: center; gap: 10px;';
        
        const totalSizeDiv = document.createElement('div');
        totalSizeDiv.style.cssText = 'font-size: 13px; color: #155724; font-weight: normal;';
        totalSizeDiv.textContent = `Total: ${formatFileSize(totalSize)}`;
        headerRight.appendChild(totalSizeDiv);
        
        // Add "Compress All" button if total size is >= 1 MB and there are image files
        const minSizeForCompressAll = 1024 * 1024; // 1 MB in bytes
        const hasImageFiles = allSelectedFiles.some(file => {
            const ext = file.name.split('.').pop().toLowerCase();
            return ['jpg', 'jpeg', 'png'].includes(ext);
        });
        
        if (totalSize >= minSizeForCompressAll && hasImageFiles) {
            const compressAllBtn = document.createElement('button');
            compressAllBtn.type = 'button';
            compressAllBtn.innerHTML = '<i class="fas fa-compress-arrows-alt"></i> Compress All Images';
            compressAllBtn.style.cssText = 'background: #17a2b8; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px; white-space: nowrap;';
            compressAllBtn.onclick = function() {
                compressAllImages();
            };
            headerRight.appendChild(compressAllBtn);
        }
        
        header.appendChild(headerLeft);
        header.appendChild(headerRight);
        fileList.appendChild(header);
        
        allSelectedFiles.forEach((file, index) => {
            const fileItem = document.createElement('div');
            fileItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border-radius: 4px; margin-bottom: 5px; border: 1px solid #c3e6cb;';
            
            const fileInfo = document.createElement('div');
            fileInfo.style.cssText = 'display: flex; align-items: center; color: #333; font-size: 14px;';
            
            // Add file type icon
            const fileIcon = document.createElement('i');
            const extension = file.name.split('.').pop().toLowerCase();
            if (['jpg', 'jpeg', 'png', 'gif'].includes(extension)) {
                fileIcon.className = 'fas fa-image';
                fileIcon.style.cssText = 'color: #17a2b8; margin-right: 8px;';
            } else if (extension === 'pdf') {
                fileIcon.className = 'fas fa-file-pdf';
                fileIcon.style.cssText = 'color: #dc3545; margin-right: 8px;';
            } else if (['doc', 'docx'].includes(extension)) {
                fileIcon.className = 'fas fa-file-word';
                fileIcon.style.cssText = 'color: #007bff; margin-right: 8px;';
            } else {
                fileIcon.className = 'fas fa-file';
                fileIcon.style.cssText = 'color: #6c757d; margin-right: 8px;';
            }
            
            const fileName = document.createElement('span');
            fileName.textContent = `${file.name} (${formatFileSize(file.size)})`;
            
            fileInfo.appendChild(fileIcon);
            fileInfo.appendChild(fileName);
            
            // Create button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 8px; align-items: center;';
            
            // Add Compress Image button for image files that are large enough to benefit from compression
            // Show button for images larger than 500KB (0.5MB)
            const minSizeForCompression = 500 * 1024; // 500KB in bytes
            if (['jpg', 'jpeg', 'png'].includes(extension) && file.size > minSizeForCompression) {
                const compressBtn = document.createElement('button');
                compressBtn.type = 'button';
                compressBtn.innerHTML = '<i class="fas fa-compress"></i> Compress Image';
                compressBtn.style.cssText = 'background: #17a2b8; color: white; border: none; border-radius: 4px; padding: 4px 10px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px; white-space: nowrap;';
                compressBtn.onclick = function() {
                    compressImage(file);
                };
                buttonContainer.appendChild(compressBtn);
            }
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.innerHTML = '<i class="fas fa-times"></i>';
            removeBtn.style.cssText = 'background: #dc3545; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center;';
            removeBtn.onclick = function() {
                removeFileFromList(file);
            };
            
            buttonContainer.appendChild(removeBtn);
            
            fileItem.appendChild(fileInfo);
            fileItem.appendChild(buttonContainer);
            fileList.appendChild(fileItem);
        });
        
        preview.appendChild(fileList);
    } else {
        // Reset button when no files are selected
        button.innerHTML = '<i class="fas fa-plus"></i> Add Files';
        button.className = 'btn btn-primary';
    }
}

// Function removed - using FormData approach instead

// Compress all image files function
async function compressAllImages() {
    // Get all image files
    const imageFiles = allSelectedFiles.filter(file => {
        const ext = file.name.split('.').pop().toLowerCase();
        return ['jpg', 'jpeg', 'png'].includes(ext);
    });
    
    if (imageFiles.length === 0) {
        alert('No image files found to compress.');
        return;
    }
    
    // Confirm with user
    const confirmMessage = `This will compress ${imageFiles.length} image file(s). This may take a few moments. Continue?`;
    if (!confirm(confirmMessage)) {
        return;
    }
    
    // Calculate original total size
    const originalTotalSize = allSelectedFiles.reduce((sum, file) => sum + file.size, 0);
    
    // Compress each image file sequentially
    // Store indices first to avoid issues with file references changing
    const imageFileIndices = [];
    for (let i = 0; i < imageFiles.length; i++) {
        const file = imageFiles[i];
        const fileIndex = allSelectedFiles.findIndex(f => f === file);
        if (fileIndex !== -1) {
            imageFileIndices.push(fileIndex);
        }
    }
    
    let compressedCount = 0;
    let totalCompressed = 0;
    
    // Compress files in reverse order to avoid index shifting issues
    for (let i = imageFileIndices.length - 1; i >= 0; i--) {
        const fileIndex = imageFileIndices[i];
        const file = allSelectedFiles[fileIndex];
        
        try {
            
            // Compress the image (reusing the compression logic)
            const extension = file.name.split('.').pop().toLowerCase();
            const originalSize = file.size;
            
            // Create a canvas to compress the image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            // Create a promise to handle image loading
            const imageLoadPromise = new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                
                // Create object URL from file
                const objectUrl = URL.createObjectURL(file);
                img.src = objectUrl;
            });
            
            await imageLoadPromise;
            
            // Calculate new dimensions (max width/height of 1920px, maintain aspect ratio)
            const maxWidth = 1920;
            const maxHeight = 1920;
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth || height > maxHeight) {
                if (width > height) {
                    height = (height / width) * maxWidth;
                    width = maxWidth;
                } else {
                    width = (width / height) * maxHeight;
                    height = maxHeight;
                }
            }
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Draw image on canvas
            ctx.drawImage(img, 0, 0, width, height);
            
            // Determine output format and quality
            let outputFormat = 'image/jpeg';
            let quality = 0.75; // 75% quality for JPEG
            
            // If original is PNG and smaller than 2MB, keep as PNG with resizing only
            if (extension === 'png' && originalSize < 2 * 1024 * 1024) {
                outputFormat = 'image/png';
            }
            
            // Convert canvas to blob
            const blob = await new Promise((resolve) => {
                if (outputFormat === 'image/png') {
                    canvas.toBlob(resolve, outputFormat);
                } else {
                    canvas.toBlob(resolve, outputFormat, quality);
                }
            });
            
            // Revoke the object URL
            URL.revokeObjectURL(img.src);
            
            // Create a new File object with the compressed image
            let compressedFileName = file.name;
            if (extension === 'png' && outputFormat === 'image/jpeg') {
                compressedFileName = file.name.replace(/\.png$/i, '.jpg');
            }
            
            const compressedFile = new File([blob], compressedFileName, {
                type: outputFormat,
                lastModified: Date.now()
            });
            
            // Replace the original file with compressed version
            allSelectedFiles[fileIndex] = compressedFile;
            compressedCount++;
            totalCompressed += (originalSize - compressedFile.size);
            
        } catch (error) {
            console.error(`Error compressing ${file.name}:`, error);
            // Continue with next file even if one fails
        }
    }
    
    // Calculate new total size
    const newTotalSize = allSelectedFiles.reduce((sum, file) => sum + file.size, 0);
    const totalReduction = ((1 - newTotalSize / originalTotalSize) * 100).toFixed(1);
    
    // Update preview once after all compressions
    updateFilePreview();
    
    // Show success message
    alert(`Compression complete!\n\nCompressed: ${compressedCount} of ${imageFiles.length} image(s)\n\nOriginal total: ${formatFileSize(originalTotalSize)}\nNew total: ${formatFileSize(newTotalSize)}\nTotal reduction: ${totalReduction}%`);
}

// Image compression function
async function compressImage(fileToCompress) {
    // Find the file in the array by reference
    let file = fileToCompress;
    let fileIndex = allSelectedFiles.findIndex(f => f === fileToCompress);
    
    // Fallback: find by name and size if reference doesn't match
    if (fileIndex === -1) {
        fileIndex = allSelectedFiles.findIndex(f => 
            f.name === fileToCompress.name && f.size === fileToCompress.size
        );
        if (fileIndex !== -1) {
            file = allSelectedFiles[fileIndex];
        } else {
            alert('File not found. Please try again.');
            return;
        }
    }
    
    const extension = file.name.split('.').pop().toLowerCase();
    
    // Only compress image files
    if (!['jpg', 'jpeg', 'png'].includes(extension)) {
        alert('Only image files (JPG, JPEG, PNG) can be compressed.');
        return;
    }
    
    // Show loading message
    const originalSize = file.size;
    
    try {
        // Create a canvas to compress the image
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        // Create a promise to handle image loading
        const imageLoadPromise = new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
            
            // Create object URL from file
            const objectUrl = URL.createObjectURL(file);
            img.src = objectUrl;
        });
        
        await imageLoadPromise;
        
        // Calculate new dimensions (max width/height of 1920px, maintain aspect ratio)
        const maxWidth = 1920;
        const maxHeight = 1920;
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth || height > maxHeight) {
            if (width > height) {
                height = (height / width) * maxWidth;
                width = maxWidth;
            } else {
                width = (width / height) * maxHeight;
                height = maxHeight;
            }
        }
        
        // Set canvas dimensions
        canvas.width = width;
        canvas.height = height;
        
        // Draw image on canvas
        ctx.drawImage(img, 0, 0, width, height);
        
        // Determine output format and quality
        // For better compression, convert PNG to JPEG (unless user wants to preserve transparency)
        // For PNG, we'll convert to JPEG for better compression, but keep original filename
        let outputFormat = 'image/jpeg';
        let quality = 0.75; // 75% quality for JPEG (good balance between size and quality)
        
        // If original is PNG and smaller than 2MB, keep as PNG with resizing only
        // Otherwise convert to JPEG for better compression
        if (extension === 'png' && originalSize < 2 * 1024 * 1024) {
            outputFormat = 'image/png';
        }
        
        // Convert canvas to blob
        const blob = await new Promise((resolve) => {
            if (outputFormat === 'image/png') {
                // PNG doesn't use quality parameter
                canvas.toBlob(resolve, outputFormat);
            } else {
                canvas.toBlob(resolve, outputFormat, quality);
            }
        });
        
        // Revoke the object URL
        URL.revokeObjectURL(img.src);
        
        // Create a new File object with the compressed image
        // Update filename extension if format changed (e.g., PNG to JPEG)
        let compressedFileName = file.name;
        if (extension === 'png' && outputFormat === 'image/jpeg') {
            compressedFileName = file.name.replace(/\.png$/i, '.jpg');
        }
        
        const compressedFile = new File([blob], compressedFileName, {
            type: outputFormat,
            lastModified: Date.now()
        });
        
        // Replace the original file with compressed version
        if (fileIndex !== -1) {
            allSelectedFiles[fileIndex] = compressedFile;
        }
        
        // Update preview to show new file size
        updateFilePreview();
        
        // Show success message
        const reduction = ((1 - compressedFile.size / originalSize) * 100).toFixed(1);
        alert(`Image compressed successfully!\n\nOriginal size: ${formatFileSize(originalSize)}\nCompressed size: ${formatFileSize(compressedFile.size)}\nSize reduction: ${reduction}%`);
        
    } catch (error) {
        console.error('Compression error:', error);
        alert('Failed to compress image. Please try again or use a different image.');
    }
}

function removeFileFromList(fileToRemove) {
    // Remove file by reference (more reliable than index)
    const index = allSelectedFiles.findIndex(f => f === fileToRemove);
    if (index !== -1) {
        allSelectedFiles.splice(index, 1);
        updateFilePreview();
    } else {
        // Fallback: try to find by name and size if reference doesn't match
        const fileIndex = allSelectedFiles.findIndex(f => 
            f.name === fileToRemove.name && f.size === fileToRemove.size
        );
        if (fileIndex !== -1) {
            allSelectedFiles.splice(fileIndex, 1);
            updateFilePreview();
        } else {
            console.error('File not found in list:', fileToRemove.name);
        }
    }
}

// Form submission handler to ensure files are properly submitted
document.getElementById('requestForm').addEventListener('submit', function(e) {
    // First, run comprehensive validation
    const validation = validateRequestForm();
    
    if (!validation.isValid) {
        e.preventDefault();
        
        // Show all errors in a single alert
        let errorMessage = 'Please fix the following errors before submitting:\n\n';
        errorMessage += validation.errors.map((error, index) => `${index + 1}. ${error}`).join('\n');
        
        alert(errorMessage);
        
        // Focus on the first error field
        if (validation.firstErrorField) {
            validation.firstErrorField.focus();
            validation.firstErrorField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        return false;
    }
    
    // Create a new FormData object with all the files
    const formData = new FormData(this);
    
    // Clear account_number from FormData if payment method is Cheque
    const paymentMethod = document.getElementById('payment_method').value;
    if (paymentMethod === 'Cheque') {
        formData.set('account_number', '');
    }
    
    // Ensure person_company value is set correctly if supplier dropdown is used
    const personCompanyContainer = document.getElementById('person_company_select_container');
    if (personCompanyContainer && personCompanyContainer.style.display !== 'none') {
        const personCompanySelect = document.getElementById('person_company_select');
        const requestType = document.getElementById('request_type').value;
        
        if (personCompanySelect && personCompanySelect.value) {
            // Final validation: ensure the value is in the allowed suppliers list
            // Get allowed suppliers from the select element options
            const allowedSuppliers = Array.from(personCompanySelect.options).map(opt => opt.value).filter(v => v);
            if (!allowedSuppliers.includes(personCompanySelect.value)) {
                e.preventDefault();
                alert('Invalid supplier selected. Please select a valid supplier from the dropdown.');
                return false;
            }
            formData.set('person_company', personCompanySelect.value);
        } else {
            e.preventDefault();
            alert('Please select a supplier from the dropdown.');
            return false;
        }
    }
    
    // Clear existing receipt_files from FormData
    formData.delete('receipt_files');
    
    // Add all selected files to FormData
    allSelectedFiles.forEach((file, index) => {
        formData.append('receipt_files', file);
    });
    
    // Debug: Log the files being submitted
    console.log('Files being submitted:', allSelectedFiles.length);
    allSelectedFiles.forEach((file, index) => {
        console.log('File', index, ':', file.name);
    });
    
    // Prevent default form submission
    e.preventDefault();
    
    // Submit the form with FormData
    fetch(this.action, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (response.ok) {
            // Redirect to dashboard on success
            window.location.href = '/dashboard';
        } else {
            // Handle specific error codes
            if (response.status === 413) {
                // Request Entity Too Large - try to get error message from response
                response.json().then(data => {
                    alert(data.message || 'File upload failed: The uploaded file(s) exceed the maximum allowed size of 100MB total. Please reduce file sizes and try again.');
                }).catch(() => {
                    alert('File upload failed: The uploaded file(s) exceed the maximum allowed size of 100MB total. Please reduce file sizes and try again.');
                });
            } else if (response.status === 400) {
                // Bad Request - likely file validation error
                response.json().then(data => {
                    alert(data.message || data.error || 'File validation failed. Please check file sizes and types.');
                }).catch(() => {
                    alert('File validation failed. Please check file sizes and types.');
                });
            } else {
                // Try to get error message from response
                response.text().then(text => {
                    try {
                        const data = JSON.parse(text);
                        alert(data.message || data.error || 'Form submission failed. Please try again.');
                    } catch {
                        alert('Form submission failed. Please check your connection and try again.');
                    }
                }).catch(() => {
                    alert('Form submission failed. Please try again.');
                });
            }
        }
    })
    .catch(error => {
        console.error('Error:', error);
        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            alert('Network error: Unable to connect to the server. Please check your connection and try again.');
        } else {
            alert('An error occurred: ' + error.message);
        }
    });
});
// Function to save form as draft
function saveAsDraft() {
    const form = document.getElementById('requestForm');
    if (!form) {
        console.error('Form not found');
        return;
    }
    
    // Create FormData to ensure files are included
    const formData = new FormData(form);
    
    // Ensure person_company value is set correctly if supplier dropdown is used
    const personCompanyContainer = document.getElementById('person_company_select_container');
    if (personCompanyContainer && personCompanyContainer.style.display !== 'none') {
        const personCompanySelect = document.getElementById('person_company_select');
        const personCompanyInput = document.getElementById('person_company');
        
        if (personCompanySelect && personCompanySelect.value) {
            // Copy dropdown value to text input
            if (personCompanyInput) {
                personCompanyInput.value = personCompanySelect.value;
            }
            // Also explicitly set it in FormData to ensure it's sent
            formData.set('person_company', personCompanySelect.value);
        }
    } else {
        // For text input, make sure it's included in FormData
        const personCompanyInput = document.getElementById('person_company');
        if (personCompanyInput && personCompanyInput.value) {
            formData.set('person_company', personCompanyInput.value);
        }
    }
    
    // Add save_as_draft flag
    formData.set('save_as_draft', 'true');
    
    // Remove required attributes temporarily for draft saving
    const requiredFields = form.querySelectorAll('[required]');
    const originalRequired = [];
    requiredFields.forEach(field => {
        originalRequired.push({
            element: field,
            wasRequired: field.hasAttribute('required')
        });
        field.removeAttribute('required');
    });
    
    // Ensure all selected files are included in FormData
    // Use the allSelectedFiles array (same as regular form submission)
    formData.delete('receipt_files');
    
    // Debug logging
    console.log('Saving draft - allSelectedFiles:', typeof allSelectedFiles !== 'undefined' ? allSelectedFiles.length : 'undefined');
    
    if (typeof allSelectedFiles !== 'undefined' && allSelectedFiles && allSelectedFiles.length > 0) {
        // Add all files from the allSelectedFiles array
        console.log('Adding', allSelectedFiles.length, 'files to FormData');
        allSelectedFiles.forEach((file, index) => {
            console.log('Adding file', index + 1, ':', file.name, 'Size:', file.size);
            formData.append('receipt_files', file);
        });
    } else {
        // Fallback: try to get files from the input element
        const receiptFileInput = document.getElementById('receipt_files');
        if (receiptFileInput && receiptFileInput.files && receiptFileInput.files.length > 0) {
            console.log('Using fallback - files from input element:', receiptFileInput.files.length);
            for (let i = 0; i < receiptFileInput.files.length; i++) {
                formData.append('receipt_files', receiptFileInput.files[i]);
            }
        } else {
            console.log('No files to add to draft');
        }
    }
    
    // Debug: Log FormData contents
    console.log('FormData entries:');
    for (let pair of formData.entries()) {
        if (pair[1] instanceof File) {
            console.log(pair[0], ':', pair[1].name, '(', pair[1].size, 'bytes)');
        } else {
            console.log(pair[0], ':', pair[1]);
        }
    }
    
    // Submit using fetch to ensure FormData is properly sent
    fetch(form.action, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (response.ok) {
            return response.text();
        }
        throw new Error('Network response was not ok');
    })
    .then(html => {
        // If response is HTML, redirect to drafts page
        window.location.href = '/drafts';
    })
    .catch(error => {
        console.error('Error saving draft:', error);
        alert('Error saving draft. Please try again.');
    });
    
    // Restore required attributes
    originalRequired.forEach(item => {
        if (item.wasRequired) {
            item.element.setAttribute('required', 'required');
        }
    });
}

// Function to submit draft (convert to regular request)
function submitDraft() {
    const form = document.getElementById('requestForm');
    if (!form) {
        console.error('Form not found');
        return;
    }
    
    // Validate form before submitting
    if (!form.checkValidity()) {
        form.reportValidity();
        return false;
    }
    
    // Find the submit button and show loading state
    const submitButton = document.querySelector('button[onclick*="submitDraft"]');
    const originalButtonHTML = submitButton ? submitButton.innerHTML : '';
    const originalButtonDisabled = submitButton ? submitButton.disabled : false;
    
    if (submitButton) {
        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
        submitButton.style.opacity = '0.7';
        submitButton.style.cursor = 'not-allowed';
    }
    
    // Create FormData to handle file uploads properly
    const formData = new FormData(form);
    
    // Remove any existing draft inputs from FormData
    formData.delete('save_as_draft');
    
    // Add submit_draft flag
    formData.set('submit_draft', 'true');
    
    // Ensure all selected files are included in FormData
    // Use the allSelectedFiles array (same as regular form submission)
    formData.delete('receipt_files');
    
    // Debug logging
    console.log('Submitting draft - allSelectedFiles:', typeof allSelectedFiles !== 'undefined' ? allSelectedFiles.length : 'undefined');
    
    if (typeof allSelectedFiles !== 'undefined' && allSelectedFiles && allSelectedFiles.length > 0) {
        // Add all files from the allSelectedFiles array
        console.log('Adding', allSelectedFiles.length, 'files to FormData');
        allSelectedFiles.forEach((file, index) => {
            console.log('Adding file', index + 1, ':', file.name, 'Size:', file.size);
            formData.append('receipt_files', file);
        });
    } else {
        // Fallback: try to get files from the input element
        const receiptFileInput = document.getElementById('receipt_files');
        if (receiptFileInput && receiptFileInput.files && receiptFileInput.files.length > 0) {
            console.log('Using fallback - files from input element:', receiptFileInput.files.length);
            for (let i = 0; i < receiptFileInput.files.length; i++) {
                formData.append('receipt_files', receiptFileInput.files[i]);
            }
        } else {
            console.log('No new files to add');
        }
    }
    
    // Handle person_company - ensure dropdown value is used if available
    const personCompanySelect = document.getElementById('person_company_select');
    if (personCompanySelect && personCompanySelect.style.display !== 'none' && personCompanySelect.value) {
        formData.set('person_company_select', personCompanySelect.value);
    }
    
    // Submit using fetch to ensure FormData is properly sent
    fetch(form.action, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (response.ok) {
            // If response is HTML (redirect), follow it
            if (response.headers.get('content-type')?.includes('text/html')) {
                return response.text().then(html => {
                    // Check if response contains a redirect or success message
                    if (html.includes('Draft submitted successfully') || response.redirected) {
                        window.location.href = '/dashboard';
                    } else {
                        window.location.reload();
                    }
                });
            } else {
                // JSON response
                return response.json().then(data => {
                    if (data.success || data.redirect) {
                        window.location.href = data.redirect || '/dashboard';
                    } else {
                        alert(data.message || 'Draft submitted successfully!');
                        window.location.href = '/dashboard';
                    }
                });
            }
        } else {
            // Handle error response
            return response.text().then(html => {
                // If it's an HTML error page, reload to show flash messages
                window.location.reload();
            });
        }
    })
    .catch(error => {
        console.error('Error submitting draft:', error);
        // Restore button state on error
        if (submitButton) {
            submitButton.disabled = originalButtonDisabled;
            submitButton.innerHTML = originalButtonHTML;
            submitButton.style.opacity = '1';
            submitButton.style.cursor = 'pointer';
        }
        alert('Error submitting draft. Please try again.');
    });
    
    return false; // Prevent default form submission
}

{% if draft %}
// Pre-fill form with draft data when editing
document.addEventListener('DOMContentLoaded', function() {
    const draft = {{ draft|tojson|safe }};
    
    if (draft) {
        // Save the person_company value to restore it after handleRequestTypeChange
        const savedPersonCompany = draft.person_company;
        
        // Fill form fields with draft data
        if (draft.request_type) {
            const requestTypeSelect = document.getElementById('request_type');
            if (requestTypeSelect) {
                // Handle "Others" type with description
                let requestType = draft.request_type;
                let othersDescription = '';
                
                if (draft.request_type.startsWith('Others:')) {
                    // Extract the description part
                    othersDescription = draft.request_type.substring('Others:'.length).trim();
                    requestType = 'Others';
                }
                
                requestTypeSelect.value = requestType;
                handleRequestTypeChange();
                
                // If it's an "Others" type, populate the description field
                if (othersDescription) {
                    setTimeout(function() {
                        const othersDescInput = document.getElementById('others_description');
                        if (othersDescInput) {
                            othersDescInput.value = othersDescription;
                        }
                    }, 100);
                }
            }
        }
        
        if (draft.requestor_name) {
            const requestorNameInput = document.getElementById('requestor_name');
            if (requestorNameInput) requestorNameInput.value = draft.requestor_name;
        }
        
        // Handle branch name - populate chips if branch_name exists
        if (draft.branch_name) {
            // Split comma-separated branch names
            const branchNames = draft.branch_name.split(',').map(b => b.trim()).filter(b => b);
            if (branchNames.length > 0) {
                // Suppress dropdown opening during draft population
                if (typeof window.setSuppressDropdownOpen === 'function') {
                    window.setSuppressDropdownOpen(true);
                }
                
                // Populate branches immediately - branch search should already be initialized
                const hiddenSelect = document.getElementById('branch_name');
                const hiddenInput = document.getElementById('branch_names');
                const chipsContainer = document.getElementById('branch_chips_container');
                
                if (hiddenSelect && hiddenInput) {
                    // Access the selectedBranches array from initializeBranchSearch scope
                    // We need to populate it through the selectBranch function
                    branchNames.forEach(function(branchName) {
                        // Find the option in the select
                        const option = Array.from(hiddenSelect.options).find(opt => opt.value === branchName);
                        if (option && typeof window.selectBranch === 'function') {
                            // Use the global selectBranch function
                            window.selectBranch(option.value, option.textContent);
                        }
                    });
                    
                    // Also update the hidden input directly as fallback
                    hiddenInput.value = branchNames.join(',');
                    
                    // Re-enable dropdown opening after population
                    if (typeof window.setSuppressDropdownOpen === 'function') {
                        window.setSuppressDropdownOpen(false);
                    }
                } else {
                    // If selectBranch is not yet available, retry with a short delay
                    setTimeout(function() {
                        const hiddenSelect = document.getElementById('branch_name');
                        const hiddenInput = document.getElementById('branch_names');
                        if (hiddenSelect && hiddenInput) {
                            branchNames.forEach(function(branchName) {
                                const option = Array.from(hiddenSelect.options).find(opt => opt.value === branchName);
                                if (option && typeof window.selectBranch === 'function') {
                                    window.selectBranch(option.value, option.textContent);
                                }
                            });
                            hiddenInput.value = branchNames.join(',');
                        }
                        
                        // Re-enable dropdown opening after population
                        if (typeof window.setSuppressDropdownOpen === 'function') {
                            window.setSuppressDropdownOpen(false);
                        }
                    }, 100); // Short retry delay only if needed
                }
            }
        }
        
        if (draft.purpose) {
            const purposeInput = document.getElementById('purpose');
            if (purposeInput) purposeInput.value = draft.purpose;
        }
        
        if (draft.payment_method) {
            const paymentMethodSelect = document.getElementById('payment_method');
            if (paymentMethodSelect) {
                paymentMethodSelect.value = draft.payment_method;
                handlePaymentMethodChange();
            }
        }
        
        if (draft.account_name) {
            const accountNameInput = document.getElementById('account_name');
            if (accountNameInput) accountNameInput.value = draft.account_name;
        }
        
        if (draft.account_number) {
            const accountNumberInput = document.getElementById('account_number');
            if (accountNumberInput) accountNumberInput.value = draft.account_number;
        }
        
        if (draft.bank_name) {
            const bankNameSelect = document.getElementById('bank_name');
            if (bankNameSelect) bankNameSelect.value = draft.bank_name;
        }
        
        if (draft.amount) {
            const amountInput = document.getElementById('amount');
            if (amountInput) amountInput.value = draft.amount;
        }
        
        if (draft.recurring) {
            const recurringSelect = document.getElementById('recurring');
            if (recurringSelect) recurringSelect.value = draft.recurring;
        }
        
        // Handle person_company - restore the saved value after handleRequestTypeChange completes
        if (savedPersonCompany) {
            // Use a slight delay to ensure handleRequestTypeChange async operations complete
            setTimeout(function() {
                const personCompanyInput = document.getElementById('person_company');
                const personCompanySelect = document.getElementById('person_company_select');
                
                // Try dropdown first (for supplier types)
                if (personCompanySelect && personCompanySelect.style.display !== 'none') {
                    personCompanySelect.value = savedPersonCompany;
                    // Trigger change event to update bank fields if needed
                    personCompanySelect.dispatchEvent(new Event('change'));
                }
                
                // Also set text input (for Person/Company types)
                if (personCompanyInput && personCompanyInput.style.display !== 'none') {
                    personCompanyInput.value = savedPersonCompany;
                }
            }, 100); // Wait for async operations to complete
        }
        
        // Display existing receipt files if any
        if (draft.requestor_receipt_path && Array.isArray(draft.requestor_receipt_path) && draft.requestor_receipt_path.length > 0) {
            const preview = document.getElementById('file-preview');
            if (preview) {
                // Create a section for previously uploaded files
                const serverFilesSection = document.createElement('div');
                serverFilesSection.style.cssText = 'border: 1px solid #dcdcdc; border-radius: 4px; padding: 8px; background: #f8f9fa; margin-bottom: 10px;';
                
                const header = document.createElement('div');
                header.style.cssText = 'font-weight: bold; margin-bottom: 8px; color: #333; display:flex; align-items:center; gap:8px;';
                header.innerHTML = `<i class="fas fa-paperclip" style="color:#666;"></i> Previously uploaded files:`;
                serverFilesSection.appendChild(header);
                
                draft.requestor_receipt_path.forEach((fname, index) => {
                    if (!fname) return;
                    
                    const fileItem = document.createElement('div');
                    fileItem.className = 'existing-file-item';
                    fileItem.dataset.filename = fname;
                    fileItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; border-radius: 4px; margin-bottom: 5px; border: 1px solid #dee2e6;';
                    
                    const fileInfo = document.createElement('div');
                    fileInfo.style.cssText = 'display: flex; align-items: center; color: #333; font-size: 14px; flex: 1;';
                    
                    // Add file type icon
                    const fileIcon = document.createElement('i');
                    const extension = fname.split('.').pop().toLowerCase();
                    if (['jpg', 'jpeg', 'png', 'gif'].includes(extension)) {
                        fileIcon.className = 'fas fa-image';
                        fileIcon.style.cssText = 'color: #17a2b8; margin-right: 8px;';
                    } else if (extension === 'pdf') {
                        fileIcon.className = 'fas fa-file-pdf';
                        fileIcon.style.cssText = 'color: #dc3545; margin-right: 8px;';
                    } else if (['doc', 'docx'].includes(extension)) {
                        fileIcon.className = 'fas fa-file-word';
                        fileIcon.style.cssText = 'color: #007bff; margin-right: 8px;';
                    } else {
                        fileIcon.className = 'fas fa-file';
                        fileIcon.style.cssText = 'color: #6c757d; margin-right: 8px;';
                    }
                    
                    const fileName = document.createElement('span');
                    // Extract original filename (remove UUID prefix if present)
                    // Files are saved as: {uuid}_{original_filename}
                    // So we need to find the first underscore and take everything after it
                    let displayName = fname;
                    if (fname.includes('_')) {
                        // Find the first underscore (UUID separator)
                        const firstUnderscoreIndex = fname.indexOf('_');
                        // Get everything after the first underscore
                        displayName = fname.substring(firstUnderscoreIndex + 1);
                    }
                    fileName.textContent = displayName;
                    
                    fileInfo.appendChild(fileIcon);
                    fileInfo.appendChild(fileName);
                    
                    // Create button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = 'display: flex; gap: 8px; align-items: center;';
                    
                    // Create view link
                    const viewLink = document.createElement('a');
                    viewLink.href = `/uploads/receipts/${fname}`;
                    viewLink.target = '_blank';
                    viewLink.className = 'btn btn-sm btn-info';
                    viewLink.style.cssText = 'padding: 4px 8px; font-size: 12px;';
                    viewLink.innerHTML = '<i class="fas fa-eye"></i> View';
                    
                    // Create delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'btn btn-sm btn-danger';
                    deleteBtn.style.cssText = 'padding: 4px 8px; font-size: 12px;';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
                    deleteBtn.onclick = function() {
                        if (confirm('Are you sure you want to delete this file? This action cannot be undone.')) {
                            // Mark file for deletion by adding a hidden checkbox
                            const deleteCheckbox = document.createElement('input');
                            deleteCheckbox.type = 'checkbox';
                            deleteCheckbox.name = 'delete_files';
                            deleteCheckbox.value = fname;
                            deleteCheckbox.checked = true;
                            deleteCheckbox.style.display = 'none';
                            document.getElementById('requestForm').appendChild(deleteCheckbox);
                            
                            // Remove the file item from display
                            fileItem.style.opacity = '0.5';
                            fileItem.style.textDecoration = 'line-through';
                            deleteBtn.disabled = true;
                            deleteBtn.innerHTML = '<i class="fas fa-check"></i> Marked';
                        }
                    };
                    
                    buttonContainer.appendChild(viewLink);
                    buttonContainer.appendChild(deleteBtn);
                    
                    fileItem.appendChild(fileInfo);
                    fileItem.appendChild(buttonContainer);
                    serverFilesSection.appendChild(fileItem);
                });
                
                preview.appendChild(serverFilesSection);
            }
        }
    }
});
{% endif %}
</script>

{% endblock %}


