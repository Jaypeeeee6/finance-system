{% extends "base.html" %}

{% block title %}New Payment Request{% endblock %}

{% block content %}
<div class="dashboard-container">
    <div class="dashboard-header">
        <h1><i class="fas fa-plus-circle"></i> New Payment Request</h1>
        <p>Submit a new payment request</p>
    </div>

    <div class="card">
        <div class="card-body">
            <form method="POST" action="{{ url_for('new_request') }}" id="requestForm">
                <div class="form-row">
                    <div class="form-group">
                        <label for="request_type">Request Type *</label>
                        <select name="request_type" id="request_type" required onchange="handleRequestTypeChange()">
                            <option value="">-- Select Type --</option>
                            <option value="Item">Item</option>
                            <option value="Person">Person</option>
                            
                            {% if user.role == 'Finance' %}
                            <!-- Finance can access Item, Person, Supplier/Rental -->
                            <option value="Supplier/Rental">Supplier/Rental</option>
                            {% endif %}
                            
                            {% if user.role == 'Project' %}
                            <!-- Project role can access Item or Supplier/Rental -->
                            <option value="Supplier/Rental">Supplier/Rental</option>
                            {% endif %}
                        </select>
                        <small>
                            {% if user.role == 'Finance' %}
                                Available: Item, Person, Supplier/Rental
                            {% elif user.role == 'Project' %}
                                Available: Item, Supplier/Rental
                            {% else %}
                                Available: Item, Person
                            {% endif %}
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="requestor_name">Requestor Name *</label>
                        <input type="text" name="requestor_name" id="requestor_name" required>
                    </div>
                </div>

                <!-- Dynamic field based on request type -->
                <div id="itemNameGroup" class="form-group" style="display: none;">
                    <label for="item_name">Item Name *</label>
                    <input type="text" name="item_name" id="item_name">
                </div>

                <div id="personCompanyGroup" class="form-group" style="display: none;">
                    <label for="person_company">Person/Company *</label>
                    <input type="text" name="person_company" id="person_company">
                </div>

                <div id="companyNameGroup" class="form-group" style="display: none;">
                    <label for="company_name">Company Name *</label>
                    <input type="text" name="company_name" id="company_name">
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="department">Department *</label>
                        <input type="text" name="department" id="department" value="{{ user.department }}" readonly>
                    </div>

                    <div class="form-group">
                        <label for="date">Date of Submission</label>
                        <input type="text" name="date" id="date" value="{{ today }}" readonly style="background: #f5f5f5; cursor: not-allowed;">
                        <small style="color: #666;">Automatically set to today's date</small>
                    </div>
                </div>

                <div class="form-group">
                    <label for="purpose">Purpose/Description *</label>
                    <textarea name="purpose" id="purpose" rows="4" required></textarea>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="account_name">Account Name *</label>
                        <input type="text" name="account_name" id="account_name" required>
                    </div>

                    <div class="form-group">
                        <label for="account_number">Account Number *</label>
                        <input type="text" name="account_number" id="account_number" pattern="[0-9]+" title="Please enter numbers only" required inputmode="numeric">
                        <small>Numbers only</small>
                    </div>
                </div>

                <div class="form-group">
                    <label for="amount">Amount (OMR) *</label>
                    <div style="position: relative;">
                        <span style="position: absolute; left: 12px; top: 12px; color: #666; font-weight: 600;">OMR</span>
                        <input type="number" name="amount" id="amount" step="0.001" min="0" required style="padding-left: 55px;" placeholder="0.000">
                    </div>
                    <small>Omani Rials (OMR) - Numbers only</small>
                </div>

                <!-- Show only for Supplier/Rental type -->
                <div id="recurringFields" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="recurring">Payment Type</label>
                            <select name="recurring" id="recurring" onchange="handleRecurringChange()">
                                <option value="One-Time">One-Time</option>
                                <option value="Recurring">Recurring</option>
                            </select>
                        </div>

                        <!-- Hidden field to store the custom recurring interval -->
                        <input type="hidden" name="recurring_interval" id="recurring_interval" value="">
                        
                        <!-- Hidden fields for variable amounts -->
                        <input type="hidden" name="variable_amounts" id="variable_amounts" value="false">
                        <input type="hidden" name="payment_schedule" id="payment_schedule" value="[]">
                        
                        <!-- Edit button - shown when Recurring is selected -->
                        <div id="configureButton" class="form-group" style="display: none; margin-top: 35px;">
                            <button type="button" class="btn btn-outline-primary" onclick="openRecurringModal()">
                                <i class="fas fa-edit"></i> Edit Payment Schedule
                                </button>
                        </div>
                    </div>

                    <!-- New Custom Repeat Modal -->
                    <div id="recurringModal" class="recurring-modal" style="display: none;">
                        <div class="recurring-modal-overlay" onclick="closeRecurringModal()"></div>
                        <div class="recurring-modal-container">
                            <div class="recurring-modal-header">
                                <div class="header-content">
                                    <i class="fas fa-calendar-alt"></i>
                                    <h2>Configure Recurring Payment</h2>
                                </div>
                                <button type="button" class="close-btn" onclick="closeRecurringModal()">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            
                            <div class="recurring-modal-body">

                                <!-- Interval Configuration -->
                                <div class="config-section">
                                    <h3><i class="fas fa-repeat"></i> Payment Schedule</h3>
                                    <div class="interval-config">
                                        <label>Every</label>
                                        <input type="number" id="intervalValue" value="1" min="1" max="99" onchange="updateSchedulePreview()">
                                        <span>month(s)</span>
                                    </div>
                                </div>

                                <!-- Specific Options -->
                                <div class="config-section" id="specificOptions">
                                    <h3><i class="fas fa-cog"></i> Specific Settings</h3>
                                    

                                    <!-- Monthly Options -->
                                    <div id="monthlyOptions" class="specific-options">
                                        <div class="monthly-config">
                                            <div class="month-year-selector">
                                                <label>Select month and year:</label>
                                                <div class="date-selector">
                                                    <select id="monthSelect" onchange="updateCalendarDays()">
                                                        <option value="0">January</option>
                                                        <option value="1">February</option>
                                                        <option value="2">March</option>
                                                        <option value="3">April</option>
                                                        <option value="4">May</option>
                                                        <option value="5">June</option>
                                                        <option value="6">July</option>
                                                        <option value="7">August</option>
                                                        <option value="8">September</option>
                                                        <option value="9">October</option>
                                                        <option value="10">November</option>
                                                        <option value="11">December</option>
                                                    </select>
                                                    <select id="yearSelect" onchange="updateCalendarDays()">
                                                        <!-- Years will be populated by JavaScript -->
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="calendar-container">
                                                <label>Select starting date:</label>
                                                <div id="calendarGrid" class="calendar-grid">
                                                    <!-- Calendar will be generated by JavaScript -->
                                        </div>
                                    </div>

                                            <!-- End Date Selection -->
                                            <div class="end-date-section" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e0e0e0;">
                                                <h4 style="margin-bottom: 1rem; color: #333; font-size: 1rem;">
                                                    <i class="fas fa-calendar-times"></i> End Date (Optional)
                                                </h4>
                                                <div class="end-date-config">
                                                    <div class="end-date-toggle" style="margin-bottom: 1rem;">
                                                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                                            <input type="checkbox" id="endDateToggle" onchange="toggleEndDate()" style="margin: 0;">
                                                            <span>Set an end date for this recurring payment</span>
                                                </label>
                                            </div>
                                                    
                                                    <div id="endDateSection" style="display: none;">
                                                        <div class="end-date-selector">
                                                            <label>Select end month and year (automatically set to 30th of the month):</label>
                                                            <div class="date-selector">
                                                                <select id="endMonthSelect" onchange="updateSchedulePreview()">
                                                                    <option value="0">January</option>
                                                                    <option value="1">February</option>
                                                                    <option value="2">March</option>
                                                                    <option value="3">April</option>
                                                                    <option value="4">May</option>
                                                                    <option value="5">June</option>
                                                                    <option value="6">July</option>
                                                                    <option value="7">August</option>
                                                                    <option value="8">September</option>
                                                                    <option value="9">October</option>
                                                                    <option value="10">November</option>
                                                                    <option value="11">December</option>
                                                                </select>
                                                                <select id="endYearSelect" onchange="updateSchedulePreview()">
                                                                    <!-- Years will be populated by JavaScript -->
                                                                </select>
                                        </div>
                                    </div>

                                                        <div class="end-date-display" style="margin-top: 1rem; padding: 0.75rem; background-color: #f5f5f5; border-radius: 4px;">
                                                            <p style="margin: 0; color: #666;">
                                                                <i class="fas fa-info-circle"></i> 
                                                                <strong>End Date:</strong> <span id="endDateDisplay">30th of selected month/year</span>
                                                            </p>
                                                        </div>
                                                    </div>
                                            </div>
                                        </div>
                                    </div>
                                    </div>

                                </div>

                                <!-- Schedule Preview -->
                                <div class="config-section">
                                    <h3><i class="fas fa-eye"></i> Preview</h3>
                                    <div class="schedule-preview">
                                        <div class="preview-content">
                                            <i class="fas fa-calendar-check"></i>
                                            <div class="preview-text">
                                                <strong>Payment Schedule:</strong>
                                                <span id="schedulePreview">Every month</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Variable Amount Configuration -->
                                <div class="config-section">
                                    <h3><i class="fas fa-money-bill-wave"></i> Variable Amounts</h3>
                                    <div class="variable-amount-config">
                                        <div class="amount-toggle">
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="variableAmountsToggle" onchange="toggleVariableAmounts()">
                                                <span class="toggle-slider"></span>
                                            </label>
                                            <span class="toggle-label">Use different amounts for each payment</span>
                                        </div>
                                        
                                        <div id="variableAmountsSection" class="variable-amounts-section" style="display: none;">
                                            <div class="total-amount-display">
                                                <label>Total Amount: <span id="totalAmountDisplay">0</span> OMR</label>
                                            </div>
                                            
                                            <div class="payment-amounts-container">
                                                <div id="paymentAmountsList" class="payment-amounts-list">
                                                    <!-- Payment amount inputs will be generated here -->
                                                </div>
                                                
                                                <div class="add-payment-section">
                                                    <button type="button" id="addPaymentBtn" class="btn-add-payment" onclick="addNewPayment()">
                                                        <i class="fas fa-plus"></i> Add Payment
                                                    </button>
                                                </div>
                                            </div>
                                            
                                            <div class="amount-summary">
                                                <div class="summary-row">
                                                    <span>Total Allocated:</span>
                                                    <span id="totalAllocated">0.000</span> OMR
                                                </div>
                                                <div class="summary-row">
                                                    <span>Remaining:</span>
                                                    <span id="remainingAmount">0.000</span> OMR
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="recurring-modal-footer">
                                <button type="button" class="btn-start-fresh" onclick="clearSavedPreferences()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px;">
                                    <i class="fas fa-refresh"></i> Start Fresh
                                </button>
                                <button type="button" class="btn-save" onclick="saveRecurringConfig()">
                                    <i class="fas fa-check"></i> Save Configuration
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">
                        <i class="fas fa-paper-plane"></i> Submit Request
                    </button>
                    <a href="{{ url_for('dashboard') }}" class="btn btn-secondary">
                        <i class="fas fa-times"></i> Cancel
                    </a>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Date is already set to today's date in the template, no need to set it here

// Add event listener for amount field changes
const amountField = document.getElementById('amount');
if (amountField) {
    amountField.addEventListener('input', function() {
        // If variable amounts are enabled, update the total amount display
        const variableAmountsToggle = document.getElementById('variableAmountsToggle');
        if (variableAmountsToggle && variableAmountsToggle.checked) {
            const totalAmount = parseFloat(this.value) || 0;
            const totalAmountDisplay = document.getElementById('totalAmountDisplay');
            if (totalAmountDisplay) {
                totalAmountDisplay.textContent = totalAmount.toFixed(3);
            }
            updateAmountSummary();
        }
    });
}

// New Recurring Modal JavaScript
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the modal
    initializeRecurringModal();
});

function handleRequestTypeChange() {
    const requestType = document.getElementById('request_type').value;
    const recurringFields = document.getElementById('recurringFields');
    
    // Hide all dynamic fields first
    document.getElementById('itemNameGroup').style.display = 'none';
    document.getElementById('personCompanyGroup').style.display = 'none';
    document.getElementById('companyNameGroup').style.display = 'none';
    
    // Remove required attribute from all dynamic fields
    document.getElementById('item_name').required = false;
    document.getElementById('person_company').required = false;
    document.getElementById('company_name').required = false;
    
    // Show appropriate field based on request type
    if (requestType === 'Item') {
        document.getElementById('itemNameGroup').style.display = 'block';
        document.getElementById('item_name').required = true;
        recurringFields.style.display = 'none';
    } else if (requestType === 'Person') {
        document.getElementById('personCompanyGroup').style.display = 'block';
        document.getElementById('person_company').required = true;
        recurringFields.style.display = 'none';
    } else if (requestType === 'Supplier/Rental') {
        document.getElementById('companyNameGroup').style.display = 'block';
        document.getElementById('company_name').required = true;
        recurringFields.style.display = 'block';
    } else {
        recurringFields.style.display = 'none';
    }
    
    // Reset recurring fields if not Supplier/Rental
    if (requestType !== 'Supplier/Rental') {
        document.getElementById('recurring').value = 'One-Time';
        document.getElementById('recurring_interval').value = '';
        closeRecurringModal();
    }
}

function handleRecurringChange() {
    const recurring = document.getElementById('recurring').value;
    
    if (recurring === 'Recurring') {
        // Show the edit button
        document.getElementById('configureButton').style.display = 'block';
        // Clear any existing configuration to start fresh
        document.getElementById('recurring_interval').value = '';
        // Open the modal automatically
        openRecurringModal();
    } else {
        document.getElementById('recurring_interval').value = '';
        closeRecurringModal();
        // Hide the edit button
        document.getElementById('configureButton').style.display = 'none';
    }
}

function initializeRecurringModal() {
    console.log('🔧 DEBUG: initializeRecurringModal - starting');
    
    // Set default values
    updateFrequencyOptions();
    updateSchedulePreview();
    initializeCalendar();
    
    console.log('🔧 DEBUG: initializeRecurringModal - completed');
}

function initializeCalendar() {
    // Set current month and year as default
    const now = new Date();
    document.getElementById('monthSelect').value = now.getMonth();
    
    // Clear existing options first
    const yearSelect = document.getElementById('yearSelect');
    yearSelect.innerHTML = '';
    
    // Populate years (current year ± 5 years)
    const currentYear = now.getFullYear();
    for (let i = currentYear - 2; i <= currentYear + 3; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        if (i === currentYear) {
            option.selected = true;
        }
        yearSelect.appendChild(option);
    }
    
    updateCalendarDays();
    highlightCurrentDate();
}


function highlightCurrentDate() {
    const now = new Date();
    const currentDay = now.getDate();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    const selectedMonth = parseInt(document.getElementById('monthSelect').value);
    const selectedYear = parseInt(document.getElementById('yearSelect').value);
    
    // Only highlight if we're viewing the current month and year
    if (selectedMonth === currentMonth && selectedYear === currentYear) {
        const calendarDays = document.querySelectorAll('.calendar-day');
        calendarDays.forEach(day => {
            if (parseInt(day.dataset.day) === currentDay) {
                day.classList.add('current-date');
            }
        });
    }
}



function updateCalendarDays() {
    const monthSelect = document.getElementById('monthSelect');
    const yearSelect = document.getElementById('yearSelect');
    const calendarGrid = document.getElementById('calendarGrid');
    
    if (!monthSelect || !yearSelect || !calendarGrid) {
        console.error('Calendar elements not found');
        return;
    }
    
    const month = parseInt(monthSelect.value);
    const year = parseInt(yearSelect.value);
    
    // Validate year and month
    if (isNaN(year) || isNaN(month)) {
        console.error('Invalid year or month');
        return;
    }
    
    // Get first day of month and number of days
    // JavaScript getDay() returns: 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
    // Our header is: Sun(0), Mon(1), Tue(2), Wed(3), Thu(4), Fri(5), Sat(6)
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    
    calendarGrid.innerHTML = '';
    
    // Create calendar header
    const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    dayHeaders.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'calendar-header';
        dayHeader.textContent = day;
        calendarGrid.appendChild(dayHeader);
    });
    
    // Add empty cells for days before the first day of the month
    // firstDay already matches our header order (0=Sunday, 1=Monday, etc.)
    for (let i = 0; i < firstDay; i++) {
        const emptyCell = document.createElement('div');
        emptyCell.className = 'calendar-day empty';
        calendarGrid.appendChild(emptyCell);
    }
    
    // Add days of the month
    const today = new Date();
    const currentDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    
    for (let day = 1; day <= daysInMonth; day++) {
        const dayCell = document.createElement('div');
        dayCell.className = 'calendar-day';
        dayCell.textContent = day;
        dayCell.dataset.day = day;
        dayCell.dataset.year = year;
        dayCell.dataset.month = month;
        
        // Check if this day is in the past
        const dayDate = new Date(year, month, day);
        if (dayDate < currentDate) {
            // Disable past dates
            dayCell.classList.add('disabled');
            dayCell.style.opacity = '0.3';
            dayCell.style.cursor = 'not-allowed';
            dayCell.title = 'Cannot select past dates. Please choose today or a future date.';
        } else {
            dayCell.onclick = function() { 
                console.log('🔧 DEBUG: onclick triggered for day:', day);
                console.log('🔧 DEBUG: calling toggleCalendarDay with this:', this);
                console.log('🔧 DEBUG: toggleCalendarDay function exists:', typeof toggleCalendarDay);
                try {
                    if (typeof toggleCalendarDay === 'function') {
                        console.log('🔧 DEBUG: About to call toggleCalendarDay...');
                        toggleCalendarDay(this); 
                        console.log('🔧 DEBUG: toggleCalendarDay call completed');
                    } else {
                        console.error('🔧 DEBUG: toggleCalendarDay is not a function');
                    }
                } catch (error) {
                    console.error('🔧 DEBUG: Error in toggleCalendarDay:', error);
                }
            };
        }
        
        // Check if this date is already selected
        if (isDateSelected(year, month, day)) {
            dayCell.classList.add('selected');
        }
        
        calendarGrid.appendChild(dayCell);
    }
    
    // Highlight current date if viewing current month
    const now = new Date();
    if (month === now.getMonth() && year === now.getFullYear()) {
        const currentDay = now.getDate();
        const currentDayElement = document.querySelector(`#calendarGrid .calendar-day[data-day="${currentDay}"]`);
        if (currentDayElement) {
            currentDayElement.classList.add('current-date');
        }
    }
    
    updateSchedulePreview();
    highlightCurrentDate();
    
    // Refresh end date display if it's visible
    const endDateSection = document.getElementById('endDateSection');
    if (endDateSection && endDateSection.style.display !== 'none') {
        updateEndDateDisplay();
    }
}

function toggleCalendarDay(dayElement) {
    console.log('🔧 DEBUG: toggleCalendarDay called with element:', dayElement);
    
    // Check if the day is disabled (past date)
    if (dayElement.classList.contains('disabled')) {
        alert('Cannot select past dates. Please choose today or a future date.');
        return;
    }
    
    const year = parseInt(dayElement.dataset.year);
    const month = parseInt(dayElement.dataset.month);
    const day = parseInt(dayElement.dataset.day);
    
    console.log('🔧 DEBUG: toggleCalendarDay - year:', year, 'month:', month, 'day:', day);
    console.log('🔧 DEBUG: toggleCalendarDay - selectedDates before:', selectedDates);
    
    if (dayElement.classList.contains('selected')) {
        // Remove from selection
        dayElement.classList.remove('selected');
        removeSelectedDate(year, month, day);
        console.log('🔧 DEBUG: toggleCalendarDay - removed date');
    } else {
        // Clear all previous selections (only allow one date)
        document.querySelectorAll('#calendarGrid .calendar-day.selected').forEach(el => {
            el.classList.remove('selected');
        });
        selectedDates = []; // Clear the array
        
        // Add the new selection
        dayElement.classList.add('selected');
        addSelectedDate(year, month, day);
        console.log('🔧 DEBUG: toggleCalendarDay - selected single date');
    }
    
    console.log('🔧 DEBUG: toggleCalendarDay - selectedDates after:', selectedDates);
    
    updateSchedulePreview();
    
    // Refresh end date display if it's visible
    const endDateSection = document.getElementById('endDateSection');
    if (endDateSection && endDateSection.style.display !== 'none') {
        updateEndDateDisplay();
    }
    
    // If variable amounts are enabled, refresh the payment inputs
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log('Date selection changed, refreshing variable amounts...');
        generatePaymentAmountInputs();
        updateAmountSummary();
    }
}

function openRecurringModal() {
    document.getElementById('recurringModal').style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    // Initialize calendar when modal opens
    initializeCalendar();
    
    // Load existing configuration if any, or load temporary config
    loadExistingConfig();
    
    updateSchedulePreview();
}

function clearSavedPreferences() {
    // Clear saved preferences from localStorage
    localStorage.removeItem('paymentScheduleInterval');
    localStorage.removeItem('paymentScheduleStartDate');
    
    // Reset the form to defaults
    document.getElementById('intervalValue').value = '1';
    document.getElementById('yearSelect').value = new Date().getFullYear();
    document.getElementById('monthSelect').value = new Date().getMonth();
    
    // Clear all selected dates
    selectedDates = [];
    
    updateCalendarDays();
    
    // Clear any selected days
    document.querySelectorAll('#monthlyOptions .calendar-day.selected').forEach(day => {
        day.classList.remove('selected');
    });
    
    updateSchedulePreview();
    
    console.log('🔧 DEBUG: clearSavedPreferences - cleared all saved preferences');
}

// Temporary storage for unsaved configuration
let tempRecurringConfig = '';

function saveTempConfig() {
    const interval = document.getElementById('intervalValue').value;
    let config = `monthly:${interval}`;
    
    // Handle monthly options
    const selectedDays = Array.from(document.querySelectorAll('#monthlyOptions .calendar-day.selected'))
        .map(day => day.dataset.day);
    if (selectedDays.length > 0) {
        const selectedMonth = parseInt(document.getElementById('monthSelect').value) + 1; // Convert 0-based to 1-based
        const selectedYear = document.getElementById('yearSelect').value;
        config += `:days:${selectedDays.join(',')}:${selectedYear}:${selectedMonth}`;
    }
    
    console.log('Saving temp config:', config);
    tempRecurringConfig = config;
    
    // Also save to the hidden field so it persists when reopening the modal
    document.getElementById('recurring_interval').value = config;
}

function loadExistingConfig() {
    const config = document.getElementById('recurring_interval').value || tempRecurringConfig;
    console.log('Loading config:', config);
    
    // Only load saved preferences if there's no existing configuration
    // This prevents new payment requests from inheriting previous choices
    if (!config) {
        console.log('No existing config, starting fresh...');
        
        // Don't automatically load saved preferences for new requests
        // User can click "Start Fresh" if they want to use saved preferences
        console.log('Starting with default values - no saved preferences loaded');
    } else {
        console.log('Existing config found, loading from config...');
        
        // Load from existing configuration
        const parts = config.split(':');
        const frequency = parts[0];
        const interval = parts[1];
        
        // All configurations are monthly now
        updateFrequencyOptions();
        
        // Set interval from config
        document.getElementById('intervalValue').value = interval;
        
        // Load monthly settings
        if (frequency === 'monthly' && parts[2] === 'days') {
            const days = parts[3].split(',');
            // Set the correct month and year first if they exist
            if (parts.length > 5) {
                const year = parseInt(parts[5]);
                const month = parseInt(parts[4]) - 1; // Convert 1-based to 0-based for dropdown
                document.getElementById('yearSelect').value = year;
                document.getElementById('monthSelect').value = month;
                
                // Add days to selectedDates array
                selectedDates = [];
            days.forEach(day => {
                    addSelectedDate(year, month, parseInt(day));
                });
                
                updateCalendarDays();
            }
            // Then select the days
            setTimeout(() => {
                updateSchedulePreview();
            }, 100);
        }
        
        // Load end date if it exists
        const endDateIndex = parts.indexOf('end');
        if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
            const endDate = parts[endDateIndex + 1];
            console.log('Loading end date:', endDate);
            
            // Parse end date and set the selectors (always 30th)
            const [year, month] = endDate.split('-').map(num => parseInt(num));
            document.getElementById('endDateToggle').checked = true;
            document.getElementById('endDateSection').style.display = 'block';
            
            // Set the month and year for end date
            document.getElementById('endMonthSelect').value = month - 1; // Convert to 0-based
            document.getElementById('endYearSelect').value = year;
            
            // Initialize end date selectors
            initializeEndDateSelectors();
            
            // Update display and preview
            setTimeout(() => {
                updateEndDateDisplay();
                updateSchedulePreview();
            }, 200);
        }
    }
}

function closeRecurringModal() {
    // Save current configuration to temporary storage before closing
    saveTempConfig();
    
    // Update payment schedule if variable amounts are enabled
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log('🔧 DEBUG: closeRecurringModal - updating payment schedule before closing');
        updatePaymentSchedule();
    }
    
    document.getElementById('recurringModal').style.display = 'none';
    document.body.style.overflow = 'auto';
}

function updateFrequencyOptions() {
    // All recurring payments are monthly by default
    // Show monthly options
        document.getElementById('monthlyOptions').style.display = 'block';
    
    updateSchedulePreview();
}

function toggleDay(button) {
    button.classList.toggle('selected');
    updateSchedulePreview();
}


// Multi-month date selection functions
let selectedDates = []; // Store all selected dates across months

// Initialize selectedDates array if not already done
if (typeof selectedDates === 'undefined') {
    selectedDates = [];
}

function isDateSelected(year, month, day) {
    return selectedDates.some(date => 
        date.year === year && date.month === month && date.day === day
    );
}

function addSelectedDate(year, month, day) {
    const dateKey = `${year}-${month}-${day}`;
    if (!selectedDates.some(date => date.key === dateKey)) {
        selectedDates.push({ year, month, day, key: dateKey });
    }
}

function removeSelectedDate(year, month, day) {
    const dateKey = `${year}-${month}-${day}`;
    selectedDates = selectedDates.filter(date => date.key !== dateKey);
}

function getSelectedDatesForCurrentMonth() {
    const currentMonth = parseInt(document.getElementById('monthSelect').value);
    const currentYear = parseInt(document.getElementById('yearSelect').value);
    return selectedDates.filter(date => 
        date.year === currentYear && date.month === currentMonth
    );
}

// End Date Functions
function toggleEndDate() {
    const endDateToggle = document.getElementById('endDateToggle');
    const endDateSection = document.getElementById('endDateSection');
    
    if (endDateToggle.checked) {
        endDateSection.style.display = 'block';
        // Initialize end date selectors
        initializeEndDateSelectors();
    } else {
        endDateSection.style.display = 'none';
    }
    
    updateSchedulePreview();
}

function initializeEndDateSelectors() {
    // Set default end date to 1 year from now
    const now = new Date();
    const nextYear = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());
    
    document.getElementById('endMonthSelect').value = nextYear.getMonth();
    document.getElementById('endYearSelect').value = nextYear.getFullYear();
    
    // Populate end year options
    populateEndYearOptions();
    
    // Update the display
    updateEndDateDisplay();
}

function populateEndYearOptions() {
    const endYearSelect = document.getElementById('endYearSelect');
    const currentYear = new Date().getFullYear();
    
    // Clear existing options
    endYearSelect.innerHTML = '';
    
    // Add years from current year to 10 years in the future
    for (let year = currentYear; year <= currentYear + 10; year++) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        endYearSelect.appendChild(option);
    }
}

function updateEndDateDisplay() {
    const monthSelect = document.getElementById('endMonthSelect');
    const yearSelect = document.getElementById('endYearSelect');
    const endDateDisplay = document.getElementById('endDateDisplay');
    
    if (!monthSelect || !yearSelect || !endDateDisplay) {
        return;
    }
    
    const month = parseInt(monthSelect.value);
    const year = parseInt(yearSelect.value);
    
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    
    endDateDisplay.textContent = `${monthNames[month]} 30, ${year}`;
}

// No longer needed - end date is always 30th

function getSelectedEndDate() {
    // Always return the 30th of the selected month/year
    const month = parseInt(document.getElementById('endMonthSelect').value) + 1; // Convert to 1-based
    const year = parseInt(document.getElementById('endYearSelect').value);
    const day = 30; // Always 30th
    
    console.log('🔧 DEBUG: getSelectedEndDate - year:', year, 'month:', month, 'day:', day);
    
    const result = `${year}-${month.toString().padStart(2, '0')}-30`;
    console.log('🔧 DEBUG: getSelectedEndDate - returning:', result);
    return result;
}

function updateSchedulePreview() {
    const interval = document.getElementById('intervalValue').value;
    console.log('🔧 DEBUG: updateSchedulePreview - interval:', interval);
    console.log('🔧 DEBUG: updateSchedulePreview - selectedDates:', selectedDates);
    
    let preview = `Every ${interval} month(s)`;
    
    // Save configuration to hidden field in real-time
    saveConfigurationToHiddenField();
    
    // Handle monthly options - use all selected dates across months
    if (selectedDates && selectedDates.length > 0) {
        const selectedDays = selectedDates
            .map(date => {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                return `${monthNames[date.month]} ${date.day}, ${date.year}`;
            })
            .sort((a, b) => {
                // Sort by actual date
                const dateA = new Date(a);
                const dateB = new Date(b);
                return dateA - dateB;
            });
        
        console.log('🔧 DEBUG: updateSchedulePreview - selected days:', selectedDays);
        
        if (selectedDays.length > 0) {
            preview += ` starting on ${selectedDays.join(', ')}`;
        }
    }
    
    // Add end date information if set
    const endDateToggle = document.getElementById('endDateToggle');
    if (endDateToggle && endDateToggle.checked) {
        const endDate = getSelectedEndDate();
        if (endDate) {
            // Parse date string to avoid timezone issues
            const [year, month, day] = endDate.split('-').map(num => parseInt(num));
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const formattedEndDate = `${monthNames[month - 1]} 30, ${year}`;
            preview += ` until ${formattedEndDate}`;
            console.log('🔧 DEBUG: updateSchedulePreview - end date string:', endDate, '-> formatted:', formattedEndDate);
            
            // Update the end date display
            updateEndDateDisplay();
        }
    }
    
    console.log('🔧 DEBUG: updateSchedulePreview - final preview:', preview);
    const previewElement = document.getElementById('schedulePreview');
    if (previewElement) {
        previewElement.textContent = preview;
    }
    
    // If variable amounts are enabled, refresh the payment inputs
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log('🔧 DEBUG: updateSchedulePreview - schedule preview updated, refreshing variable amounts...');
        generatePaymentAmountInputs();
        updateAmountSummary();
    }
}

function saveConfigurationToHiddenField() {
    const interval = document.getElementById('intervalValue').value;
    console.log('🔧 DEBUG: saveConfigurationToHiddenField - interval value:', interval);
    
    let config = `monthly:${interval}`;
    
    // Handle monthly options - store the single selected date
    if (selectedDates.length > 0) {
        // Get the first (and only) selected date
        const date = selectedDates[0];
        const monthNum = String(date.month + 1).padStart(2, '0'); // Convert 0-based to 1-based and pad
        const dayNum = String(date.day).padStart(2, '0');
        const dateString = `${date.year}-${monthNum}-${dayNum}`;
        
        // Store the single date in the config
        config += `:date:${dateString}`;
        console.log('🔧 DEBUG: saveConfigurationToHiddenField - selected date:', dateString);
    }
    
    // Add end date if set
    const endDateToggle = document.getElementById('endDateToggle');
    if (endDateToggle && endDateToggle.checked) {
        const endDate = getSelectedEndDate();
        if (endDate) {
            config += `:end:${endDate}`;
            console.log('🔧 DEBUG: saveConfigurationToHiddenField - added end date:', endDate);
        }
    }
    
    console.log('🔧 DEBUG: saveConfigurationToHiddenField - final config:', config);
    document.getElementById('recurring_interval').value = config;
    
    // Save the user's choice for payment schedule as default
    localStorage.setItem('paymentScheduleInterval', interval);
    console.log('🔧 DEBUG: saveConfigurationToHiddenField - saved interval to localStorage:', interval);
    
    // Save the user's choice for starting date
    if (selectedDates && selectedDates.length > 0) {
        const selectedMonth = parseInt(document.getElementById('monthSelect').value);
        const selectedYear = parseInt(document.getElementById('yearSelect').value);
        const startDate = {
            year: selectedYear,
            month: selectedMonth,
            days: selectedDates.map(d => d.day)
        };
        localStorage.setItem('paymentScheduleStartDate', JSON.stringify(startDate));
        console.log('🔧 DEBUG: saveConfigurationToHiddenField - saved start date to localStorage:', startDate);
    }
}

function saveRecurringConfig() {
    const interval = document.getElementById('intervalValue').value;
    
    let config = `monthly:${interval}`;
    
    console.log('Saving recurring config - frequency: monthly, interval:', interval);
    
    // Handle monthly options - store the single selected date
    if (selectedDates && selectedDates.length > 0) {
        // Get the first (and only) selected date
        const date = selectedDates[0];
        const monthNum = String(date.month + 1).padStart(2, '0'); // Convert 0-based to 1-based and pad
        const dayNum = String(date.day).padStart(2, '0');
        const dateString = `${date.year}-${monthNum}-${dayNum}`;
        
        // Store the single date in the config
        config += `:date:${dateString}`;
        console.log('Selected date for config:', dateString);
    }
    
    console.log('Final config being saved:', config);
    document.getElementById('recurring_interval').value = config;
    
    // Verify the config was saved
    setTimeout(() => {
        const savedConfig = document.getElementById('recurring_interval').value;
        console.log('Config verification after save:', savedConfig);
        console.log('Config verification length:', savedConfig ? savedConfig.length : 0);
    }, 50);
    
    // Show the current configuration
    showCurrentConfig();
    
    // If variable amounts are enabled, regenerate the payment inputs
    const variableAmountsToggle = document.getElementById('variableAmountsToggle');
    if (variableAmountsToggle && variableAmountsToggle.checked) {
        console.log('Regenerating payment inputs after config save...');
        // Add a small delay to ensure the configuration is properly saved
        setTimeout(() => {
            generatePaymentAmountInputs();
            updateAmountSummary();
        }, 100);
    }
    
    // Clear temporary storage since config is now saved
    tempRecurringConfig = '';
    
    closeRecurringModal();
}

function showCurrentConfig() {
    // Always show the edit button when this function is called
    document.getElementById('configureButton').style.display = 'block';
}

// Variable Amount Functions
function toggleVariableAmounts() {
    const toggle = document.getElementById('variableAmountsToggle');
    const section = document.getElementById('variableAmountsSection');
    const variableAmountsField = document.getElementById('variable_amounts');
    
    console.log('🔧 DEBUG: toggleVariableAmounts - toggle checked:', toggle.checked);
    console.log('🔧 DEBUG: toggleVariableAmounts - section element:', section);
    console.log('🔧 DEBUG: toggleVariableAmounts - variable amounts field:', variableAmountsField);
    
    if (toggle.checked) {
        section.style.display = 'block';
        variableAmountsField.value = 'true';
        console.log('🔧 DEBUG: toggleVariableAmounts - variable amounts enabled, generating inputs...');
        
        // Get the current amount
        const currentAmount = document.getElementById('amount').value;
        console.log('🔧 DEBUG: toggleVariableAmounts - current amount:', currentAmount);
        
        // Check if we have a recurring configuration
        const recurringConfig = document.getElementById('recurring_interval').value;
        console.log('🔧 DEBUG: toggleVariableAmounts - recurring config when toggling:', recurringConfig);
        console.log('🔧 DEBUG: toggleVariableAmounts - recurring config length:', recurringConfig ? recurringConfig.length : 0);
        console.log('🔧 DEBUG: toggleVariableAmounts - recurring config type:', typeof recurringConfig);
        
        generatePaymentAmountInputs();
        updateAmountSummary();
    } else {
        section.style.display = 'none';
        variableAmountsField.value = 'false';
        document.getElementById('payment_schedule').value = '[]';
    }
}

function generatePaymentAmountInputs() {
    const container = document.getElementById('paymentAmountsList');
    const totalAmount = parseFloat(document.getElementById('amount').value) || 0;
    
    console.log('🔧 DEBUG: generatePaymentAmountInputs - starting');
    console.log('Container element:', container);
    console.log('Total amount:', totalAmount);
    
    if (!container) {
        console.error('Payment amounts list container not found!');
        return;
    }
    
    // Check for existing schedule data in the hidden field
    const existingScheduleData = document.getElementById('payment_schedule').value;
    console.log('🔧 DEBUG: generatePaymentAmountInputs - existing schedule data:', existingScheduleData);
    
    let existingSchedule = [];
    if (existingScheduleData && existingScheduleData !== '[]') {
        try {
            existingSchedule = JSON.parse(existingScheduleData);
            console.log('🔧 DEBUG: generatePaymentAmountInputs - parsed existing schedule:', existingSchedule);
        } catch (e) {
            console.error('Error parsing existing schedule data:', e);
        }
    }
    
    // Get the selected dates from the schedule
    const scheduleDates = getScheduleDates();
    console.log('🔧 DEBUG: generatePaymentAmountInputs - schedule dates:', scheduleDates);
    console.log('🔧 DEBUG: generatePaymentAmountInputs - schedule dates length:', scheduleDates ? scheduleDates.length : 0);
    
    container.innerHTML = '';
    
    if (scheduleDates.length === 0) {
        // If no schedule dates are available, generate some default dates using user's saved choices
        console.log('No schedule dates found, generating default dates using user choices...');
        const defaultDates = generateDefaultDatesWithUserChoices();
        console.log('Default dates generated with user choices:', defaultDates);
        
        defaultDates.forEach((date, index) => {
            // Find existing amount for this date
            const existingAmount = existingSchedule.find(item => item.date === date)?.amount || 0;
            console.log(`🔧 DEBUG: generatePaymentAmountInputs - date ${date}, existing amount: ${existingAmount}`);
            
            const paymentDiv = document.createElement('div');
            paymentDiv.className = 'payment-amount-item';
            paymentDiv.innerHTML = `
                <div class="payment-info">
                    <label>Payment ${index + 1}:</label>
                    <span class="payment-date">${date}</span>
                </div>
                <div class="amount-input-container">
                    <span class="currency-symbol">OMR</span>
                    <input type="number" 
                           class="payment-amount-input" 
                           step="0.001" 
                           min="0" 
                           max="${totalAmount}"
                           placeholder="0.000"
                           value="${existingAmount}"
                           onchange="validateAndUpdateAmount(this)"
                           data-payment-index="${index}"
                           data-payment-date="${date}">
                </div>
                <div class="payment-actions">
                    <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            container.appendChild(paymentDiv);
        });
    } else {
        scheduleDates.forEach((date, index) => {
            // Find existing amount for this date
            const existingAmount = existingSchedule.find(item => item.date === date)?.amount || 0;
            console.log(`🔧 DEBUG: generatePaymentAmountInputs - date ${date}, existing amount: ${existingAmount}`);
            
            const paymentDiv = document.createElement('div');
            paymentDiv.className = 'payment-amount-item';
            paymentDiv.innerHTML = `
                <div class="payment-info">
                    <label>Payment ${index + 1}:</label>
                    <span class="payment-date">${date}</span>
                </div>
                <div class="amount-input-container">
                    <span class="currency-symbol">OMR</span>
                    <input type="number" 
                           class="payment-amount-input" 
                           step="0.001" 
                           min="0" 
                           max="${totalAmount}"
                           placeholder="0.000"
                           value="${existingAmount}"
                           onchange="validateAndUpdateAmount(this)"
                           data-payment-index="${index}"
                           data-payment-date="${date}">
                </div>
                <div class="payment-actions">
                    <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            container.appendChild(paymentDiv);
        });
    }
    
    // Update total amount display
    const totalAmountDisplay = document.getElementById('totalAmountDisplay');
    if (totalAmountDisplay) {
        totalAmountDisplay.textContent = totalAmount.toFixed(3);
    }
    
    // Update add button state and amount summary
    updateAddButtonState();
    updateAmountSummary();
    
    console.log('🔧 DEBUG: generatePaymentAmountInputs - completed successfully');
}

function generateDefaultDates() {
    // Generate default dates for the case where schedule isn't configured yet
    const dates = [];
    
    // Try to get the actual configured date from the recurring interval
    const config = document.getElementById('recurring_interval').value;
    console.log('Current config:', config);
    
    let startDate;
    
    if (config) {
        // Parse the configuration to get the actual selected date
        const parts = config.split(':');
        console.log('Config parts:', parts);
        
        // Try to extract date information from any configuration type
        startDate = extractStartDateFromConfig(parts);
        
        if (startDate) {
            console.log('Using configured start date:', startDate.toISOString().split('T')[0]);
        } else {
            console.log('Could not extract date from config, using current date');
            startDate = new Date();
        }
    } else {
        // Fallback to current date
        console.log('No config found, using current date');
        startDate = new Date();
    }
    
    // Start with just one payment date
    dates.push(startDate.toISOString().split('T')[0]);
    console.log('Generated default dates:', dates);
    
    return dates;
}

function generateDefaultDatesWithUserChoices() {
    console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - starting');
    
    // Generate default dates using the user's saved choices
    const dates = [];
    
    // Get saved user choices
    const savedInterval = localStorage.getItem('paymentScheduleInterval');
    const savedStartDate = localStorage.getItem('paymentScheduleStartDate');
    console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - saved interval:', savedInterval, 'saved start date:', savedStartDate);
    
    let startDate;
    let interval = 1; // Default interval
    
    // Use saved interval if available
    if (savedInterval) {
        interval = parseInt(savedInterval);
        console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - using saved interval:', interval);
    } else {
        console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - no saved interval, using default:', interval);
    }
    
    // Use saved start date if available
    if (savedStartDate) {
        try {
            const startDateData = JSON.parse(savedStartDate);
            console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - parsed start date data:', startDateData);
            // Use the earliest day as the start date
            const earliestDay = Math.min(...startDateData.days);
            startDate = new Date(startDateData.year, startDateData.month, earliestDay);
            console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - using saved start date:', startDate.toISOString().split('T')[0]);
        } catch (e) {
            console.error('🔧 DEBUG: generateDefaultDatesWithUserChoices - error parsing saved start date:', e);
            startDate = new Date();
        }
    } else {
        console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - no saved start date, checking config');
        // Try to get from current configuration
        const config = document.getElementById('recurring_interval').value;
        console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - config:', config);
        if (config) {
            const parts = config.split(':');
            startDate = extractStartDateFromConfig(parts);
            console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - extracted start date from config:', startDate);
        }
        
        if (!startDate) {
            console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - no start date found, using current date');
            startDate = new Date();
        }
    }
    
    // Generate the first payment date (always the starting date)
    const firstDate = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
    dates.push(firstDate);
    
    console.log('🔧 DEBUG: generateDefaultDatesWithUserChoices - final dates:', dates);
    return dates;
}

function extractStartDateFromConfig(parts) {
        const frequency = parts[0];
    
    if (frequency === 'monthly' && parts.length > 2 && parts[2] === 'days') {
        // Monthly configuration with specific days
        const days = parts[3].split(',').map(d => parseInt(d.trim()));
        const year = parseInt(parts[4]) || new Date().getFullYear();
        const month = parseInt(parts[5]) - 1 || new Date().getMonth(); // Convert 1-based to 0-based
        
        // Use the earliest day as the start date
        const earliestDay = Math.min(...days);
        
        console.log('Monthly config - days:', days, 'earliest day:', earliestDay, 'year:', year, 'month:', month);
        const date = new Date(year, month, earliestDay);
        console.log('Created date object:', date);
        console.log('Date ISO string:', date.toISOString());
        console.log('Date local string:', date.toLocaleDateString());
        return date;
    }
    
    return null;
}

function getScheduleDates() {
    // This function should extract dates from the current schedule configuration
    const config = document.getElementById('recurring_interval').value;
    console.log('🔧 DEBUG: getScheduleDates - config:', config);
    
    if (!config) {
        console.log('🔧 DEBUG: getScheduleDates - no config found, returning empty array');
        return [];
    }
    
    // Parse the configuration and generate dates
    const parts = config.split(':');
    const frequency = parts[0];
    const interval = parseInt(parts[1]);
    console.log('🔧 DEBUG: getScheduleDates - frequency:', frequency, 'interval:', interval);
    
    const dates = [];
    
    // Get the start date from the specific settings using the flexible extractor
    let startDate = extractStartDateFromConfig(parts);
    console.log('🔧 DEBUG: getScheduleDates - extracted start date:', startDate);
    
    if (!startDate) {
        console.log('🔧 DEBUG: getScheduleDates - could not extract start date, using current date');
        startDate = new Date();
    }
    
    // Use local date formatting to avoid timezone issues
    const startDateString = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
    console.log('🔧 DEBUG: getScheduleDates - using start date for schedule:', startDateString);
    
    // Check for end date in the configuration
    let endDate = null;
    const endDateIndex = parts.indexOf('end');
    if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
        endDate = new Date(parts[endDateIndex + 1]);
        console.log('🔧 DEBUG: getScheduleDates - found end date:', parts[endDateIndex + 1], '-> parsed:', endDate);
    }
    
    // Generate payment dates based on the configuration
    if (frequency === 'monthly' && parts.length > 2 && parts[2] === 'date') {
        // Handle single date format
        const baseDate = parts[3];
        console.log('🔧 DEBUG: getScheduleDates - base date:', baseDate);
        
        // Generate recurring payment dates based on the interval
        const startDate = new Date(baseDate);
        let numPayments = endDate ? 100 : 4; // Generate up to 100 if end date exists, otherwise 4
        
        for (let i = 0; i < numPayments; i++) {
            const paymentDate = new Date(startDate);
            paymentDate.setMonth(paymentDate.getMonth() + (interval * i));
            
            // Check if this payment date exceeds the end date
            if (endDate && paymentDate > endDate) {
                console.log(`🔧 DEBUG: getScheduleDates - payment ${i + 1} exceeds end date, stopping`);
                break;
            }
            
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            dates.push(dateString);
            console.log(`🔧 DEBUG: getScheduleDates - payment ${i + 1}:`, dateString);
        }
    } else if (frequency === 'monthly' && parts.length > 2 && parts[2] === 'days') {
        // Handle old format for backward compatibility (single month, multiple days)
        const days = parts[3].split(',').map(d => parseInt(d.trim()));
        const year = parseInt(parts[4]) || new Date().getFullYear();
        const month = parseInt(parts[5]) - 1 || new Date().getMonth(); // Convert 1-based to 0-based
        
        console.log('🔧 DEBUG: getScheduleDates - generating dates for multiple days:', days, 'year:', year, 'month:', month);
        
        // Generate dates for all days in the first occurrence
        for (const day of days) {
            const paymentDate = new Date(year, month, day);
            
            // Check if this payment date exceeds the end date
            if (endDate && paymentDate > endDate) {
                console.log(`🔧 DEBUG: getScheduleDates - payment date exceeds end date, skipping`);
                continue;
            }
            
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            dates.push(dateString);
        }
    } else {
        // Generate payment dates based on the configuration (monthly only)
        console.log('🔧 DEBUG: getScheduleDates - generating payment dates with interval:', interval);
        let numPayments = endDate ? 100 : 4; // Generate up to 100 if end date exists, otherwise 4
        
        for (let i = 0; i < numPayments; i++) {
            const paymentDate = new Date(startDate);
            
            // All payments are monthly - use the user's chosen interval
            paymentDate.setMonth(paymentDate.getMonth() + (interval * i));
            
            // Check if this payment date exceeds the end date
            if (endDate && paymentDate > endDate) {
                console.log(`🔧 DEBUG: getScheduleDates - payment ${i + 1} exceeds end date, stopping`);
                break;
            }
            
            // Use local date formatting to avoid timezone issues
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            console.log(`🔧 DEBUG: getScheduleDates - payment ${i + 1} date:`, dateString, '(added', interval * i, 'months)');
            dates.push(dateString);
        }
    }
    
    console.log('🔧 DEBUG: getScheduleDates - final generated dates:', dates, 'total:', dates.length);
    return dates;
}

function updateAmountSummary() {
    const inputs = document.querySelectorAll('.payment-amount-input');
    let totalAllocated = 0;
    
    inputs.forEach(input => {
        const amount = parseFloat(input.value) || 0;
        totalAllocated += amount;
    });
    
    const totalAmount = parseFloat(document.getElementById('amount').value) || 0;
    const remaining = totalAmount - totalAllocated;
    
    document.getElementById('totalAllocated').textContent = totalAllocated.toFixed(3);
    document.getElementById('remainingAmount').textContent = remaining.toFixed(3);
    
    // Check if total allocated doesn't match the total amount
    const isMismatch = totalAmount > 0 && Math.abs(totalAllocated - totalAmount) > 0.001;
    
    if (isMismatch) {
        // Show alert if there's a mismatch
        const mismatchAlert = document.getElementById('amountMismatchAlert');
        if (mismatchAlert) {
            mismatchAlert.style.display = 'block';
    } else {
            // Create alert if it doesn't exist
            createAmountMismatchAlert();
        }
    } else {
        // Hide alert if amounts match
        const mismatchAlert = document.getElementById('amountMismatchAlert');
        if (mismatchAlert) {
            mismatchAlert.style.display = 'none';
        }
    }
    
    // Enable/disable Save Configuration button based on amount match
    const saveButton = document.querySelector('button[onclick="saveRecurringConfig()"]');
    if (saveButton) {
        if (isMismatch) {
            saveButton.disabled = true;
            saveButton.style.opacity = '0.5';
            saveButton.style.cursor = 'not-allowed';
        } else {
            saveButton.disabled = false;
            saveButton.style.opacity = '1';
            saveButton.style.cursor = 'pointer';
        }
    }
    
    // Update the payment schedule data
    updatePaymentSchedule();
    
    // Update the add button state
    updateAddButtonState();
}

// Prevent form submission when Enter is pressed in recurring payment modal
document.addEventListener('DOMContentLoaded', function() {
    // Add event listener to prevent Enter key from submitting form when in recurring modal
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            // Check if we're in the recurring payment modal
            const recurringModal = document.getElementById('recurringModal');
            if (recurringModal && recurringModal.style.display !== 'none') {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }
    });
    
    // Also prevent form submission on Enter in the main form when recurring modal is open
    const mainForm = document.querySelector('form');
    if (mainForm) {
        mainForm.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                const recurringModal = document.getElementById('recurringModal');
                if (recurringModal && recurringModal.style.display !== 'none') {
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
            }
        });
    }
});

function createAmountMismatchAlert() {
    // Create the alert element
    const alertDiv = document.createElement('div');
    alertDiv.id = 'amountMismatchAlert';
    alertDiv.className = 'alert alert-warning';
    alertDiv.style.cssText = 'margin: 10px 0; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; color: #856404; display: block;';
    alertDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        <strong>Amount Mismatch:</strong> Please ensure the total allocated amount matches the total amount (OMR ${parseFloat(document.getElementById('amount').value || 0).toFixed(3)}).
    `;
    
    // Find the variable amounts section and insert the alert
    const variableAmountsSection = document.querySelector('.variable-amounts-section');
    if (variableAmountsSection) {
        variableAmountsSection.insertBefore(alertDiv, variableAmountsSection.firstChild);
    }
}

function updatePaymentSchedule() {
    const inputs = document.querySelectorAll('.payment-amount-input');
    const schedule = [];
    
    inputs.forEach(input => {
        const amount = parseFloat(input.value) || 0;
        if (amount > 0) {
            // Get the date from the data attribute
            const paymentDate = input.getAttribute('data-payment-date');
            console.log('🔧 DEBUG: updatePaymentSchedule - input amount:', amount, 'date:', paymentDate);
            schedule.push({
                date: paymentDate,
                amount: amount
            });
        }
    });
    
    console.log('🔧 DEBUG: updatePaymentSchedule - final schedule:', schedule);
    document.getElementById('payment_schedule').value = JSON.stringify(schedule);
}

// New functions for dynamic payment management

function addNewPayment() {
    console.log('🔧 DEBUG: addNewPayment - starting to add new payment');
    
    const totalAmount = parseFloat(document.getElementById('amount').value) || 0;
    const remainingAmount = getRemainingAmount();
    console.log('🔧 DEBUG: addNewPayment - total amount:', totalAmount, 'remaining amount:', remainingAmount);
    
    // Check if there's remaining amount to allocate
    if (remainingAmount <= 0) {
        alert('Cannot add more payments. All amount has been allocated.');
        return;
    }
    
    // Get the recurring configuration to determine selected days
    const config = document.getElementById('recurring_interval').value;
    console.log('🔧 DEBUG: addNewPayment - config:', config);
    
    if (!config) {
        alert('No recurring configuration found. Please configure recurring payment first.');
        return;
    }
    
    const parts = config.split(':');
    const interval = parseInt(parts[1]); // Get the user's chosen interval
    console.log('🔧 DEBUG: addNewPayment - parsed interval:', interval);
    
    // Check for end date in the configuration
    let endDate = null;
    const endDateIndex = parts.indexOf('end');
    if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
        endDate = new Date(parts[endDateIndex + 1]);
        console.log('🔧 DEBUG: addNewPayment - found end date:', parts[endDateIndex + 1], '-> parsed:', endDate);
    }
    
    if (parts.length > 2 && parts[2] === 'date') {
        console.log('🔧 DEBUG: addNewPayment - handling single date format');
        // Handle single date format
        const baseDate = parts[3];
        console.log('🔧 DEBUG: addNewPayment - base date:', baseDate);
        
        // Get the current number of payments to determine the next payment
        const existingPayments = document.querySelectorAll('.payment-amount-item');
        const nextPaymentNumber = existingPayments.length + 1;
        
        // Calculate the next payment date
        const startDate = new Date(baseDate);
        startDate.setMonth(startDate.getMonth() + (interval * existingPayments.length));
        
        // Check if this payment date exceeds the end date
        if (endDate && startDate > endDate) {
            alert('Cannot add more payments. The next payment date would exceed the end date.');
            console.log('🔧 DEBUG: addNewPayment - next payment would exceed end date, aborting');
            return;
        }
        
        const dateString = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
        
        console.log('🔧 DEBUG: addNewPayment - creating payment:', nextPaymentNumber, 'for date:', dateString);
        
        // Create the new payment element
        const container = document.getElementById('paymentAmountsList');
        const paymentDiv = document.createElement('div');
        paymentDiv.className = 'payment-amount-item';
        paymentDiv.innerHTML = `
            <div class="payment-info">
                <label>Payment ${nextPaymentNumber}:</label>
                <span class="payment-date">${dateString}</span>
            </div>
            <div class="amount-input-container">
                <span class="currency-symbol">OMR</span>
                <input type="number" 
                       class="payment-amount-input" 
                       step="0.001" 
                       min="0" 
                       max="${remainingAmount}"
                       placeholder="0.000"
                       onchange="validateAndUpdateAmount(this)"
                       data-payment-index="${nextPaymentNumber - 1}"
                       data-payment-date="${dateString}">
            </div>
            <div class="payment-actions">
                <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        
        container.appendChild(paymentDiv);
    } else if (parts.length > 2 && parts[2] === 'days') {
        console.log('🔧 DEBUG: addNewPayment - handling multiple days');
        // Handle multiple days for monthly payments
        const days = parts[3].split(',').map(d => parseInt(d.trim()));
        const year = parseInt(parts[4]) || new Date().getFullYear();
        const month = parseInt(parts[5]) - 1 || new Date().getMonth(); // Convert 1-based to 0-based
        
        console.log('🔧 DEBUG: addNewPayment - days:', days, 'year:', year, 'month:', month);
        
        // Get the current number of payments to determine the next payment number
        const existingPayments = document.querySelectorAll('.payment-amount-item');
        const nextPaymentNumber = existingPayments.length + 1;
        
        // Calculate how many complete payment cycles we've had
        // Each cycle includes all selected days
        const paymentCycles = Math.floor((nextPaymentNumber - 1) / days.length);
        // Add the interval for the next cycle (paymentCycles already represents completed cycles)
        const nextMonth = month + (interval * paymentCycles);
        
        console.log('🔧 DEBUG: addNewPayment - payment cycles:', paymentCycles, 'next payment number:', nextPaymentNumber, 'next month:', nextMonth);
        
        // Generate new payment dates for all selected days
        const container = document.getElementById('paymentAmountsList');
        
        for (let i = 0; i < days.length; i++) {
            const day = days[i];
            const paymentDate = new Date(year, nextMonth, day);
            const dateString = `${paymentDate.getFullYear()}-${String(paymentDate.getMonth() + 1).padStart(2, '0')}-${String(paymentDate.getDate()).padStart(2, '0')}`;
            
            console.log('🔧 DEBUG: addNewPayment - creating payment for day:', day, 'date:', dateString);
            
            const paymentDiv = document.createElement('div');
            paymentDiv.className = 'payment-amount-item';
            paymentDiv.innerHTML = `
                <div class="payment-info">
                    <label>Payment ${nextPaymentNumber + i}:</label>
                    <span class="payment-date">${dateString}</span>
                </div>
                <div class="amount-input-container">
                    <span class="currency-symbol">OMR</span>
                    <input type="number" 
                           class="payment-amount-input" 
                           step="0.001" 
                           min="0" 
                           max="${remainingAmount}"
                           placeholder="0.000"
                           onchange="validateAndUpdateAmount(this)"
                           data-payment-index="${nextPaymentNumber + i - 1}"
                           data-payment-date="${dateString}">
                </div>
                <div class="payment-actions">
                    <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            
            container.appendChild(paymentDiv);
        }
    } else {
        console.log('🔧 DEBUG: addNewPayment - handling single day with interval:', interval);
        // Handle single day or other frequencies using dynamic interval
        const nextDate = generateNextPaymentDateWithInterval(interval);
        
        // Get the current number of payments to determine the next payment number
        const existingPayments = document.querySelectorAll('.payment-amount-item');
        const nextPaymentNumber = existingPayments.length + 1;
        
        console.log('🔧 DEBUG: addNewPayment - next payment number:', nextPaymentNumber, 'next date:', nextDate);
        
        // Create the new payment element
        const container = document.getElementById('paymentAmountsList');
        const paymentDiv = document.createElement('div');
        paymentDiv.className = 'payment-amount-item';
        paymentDiv.innerHTML = `
            <div class="payment-info">
                <label>Payment ${nextPaymentNumber}:</label>
                <span class="payment-date">${nextDate}</span>
            </div>
            <div class="amount-input-container">
                <span class="currency-symbol">OMR</span>
                <input type="number" 
                       class="payment-amount-input" 
                       step="0.001" 
                       min="0" 
                       max="${remainingAmount}"
                       placeholder="0.000"
                       onchange="validateAndUpdateAmount(this)"
                       data-payment-index="${nextPaymentNumber - 1}"
                       data-payment-date="${nextDate}">
            </div>
            <div class="payment-actions">
                <button type="button" class="btn-remove-payment" onclick="removePayment(this)" title="Remove Payment">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
        
        container.appendChild(paymentDiv);
    }
    
    // Update the add button state
    updateAddButtonState();
    console.log('🔧 DEBUG: addNewPayment - completed');
}

function generateNextPaymentDate() {
    // Get the last payment date and add 2 months (fallback for backward compatibility)
    const existingDates = Array.from(document.querySelectorAll('.payment-date')).map(el => el.textContent);
    if (existingDates.length === 0) {
        return '2025-10-14'; // First payment date
    }
    
    const lastDate = new Date(existingDates[existingDates.length - 1]);
    const nextDate = new Date(lastDate);
    nextDate.setMonth(nextDate.getMonth() + 2); // Add 2 months
    
    return nextDate.toISOString().split('T')[0];
}

function generateNextPaymentDateWithInterval(interval) {
    console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - interval:', interval);
    
    // Get the last payment date and add the user's chosen interval
    const existingDates = Array.from(document.querySelectorAll('.payment-date')).map(el => el.textContent);
    console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - existing dates:', existingDates);
    
    if (existingDates.length === 0) {
        // If no existing dates, get the start date from the configuration
        const config = document.getElementById('recurring_interval').value;
        console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - no existing dates, checking config:', config);
        
        if (config) {
            const parts = config.split(':');
            const startDate = extractStartDateFromConfig(parts);
            if (startDate) {
                const dateString = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`;
                console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - using start date from config:', dateString);
                return dateString;
            }
        }
        console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - using fallback date');
        return '2025-10-14'; // Fallback first payment date
    }
    
    const lastDate = new Date(existingDates[existingDates.length - 1]);
    const nextDate = new Date(lastDate);
    console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - last date:', lastDate, 'adding', interval, 'months');
    
    nextDate.setMonth(nextDate.getMonth() + interval); // Add the user's chosen interval
    
    const result = nextDate.toISOString().split('T')[0];
    console.log('🔧 DEBUG: generateNextPaymentDateWithInterval - result:', result);
    return result;
}

function removePayment(button) {
    const paymentItem = button.closest('.payment-amount-item');
    paymentItem.remove();
    
    // Renumber the remaining payments
    renumberPayments();
    updateAmountSummary();
    updateAddButtonState();
}

function renumberPayments() {
    const paymentItems = document.querySelectorAll('.payment-amount-item');
    paymentItems.forEach((item, index) => {
        const label = item.querySelector('label');
        if (label) {
            label.textContent = `Payment ${index + 1}:`;
        }
    });
}

function validateAndUpdateAmount(input) {
    const enteredAmount = parseFloat(input.value) || 0;
    const totalAmount = parseFloat(document.getElementById('amount').value) || 0;
    
    // First, get the remaining amount BEFORE this input is considered
    const otherInputs = Array.from(document.querySelectorAll('.payment-amount-input')).filter(inp => inp !== input);
    let otherAllocated = 0;
    otherInputs.forEach(inp => {
        otherAllocated += parseFloat(inp.value) || 0;
    });
    const remainingAmount = totalAmount - otherAllocated;
    
    // Check if the entered amount exceeds the total amount
    if (enteredAmount > totalAmount) {
        alert(`Cannot allocate more than the total amount (${totalAmount.toFixed(3)} OMR).`);
        input.value = totalAmount.toFixed(3);
        updateInputMaxValues();
        updateAmountSummary();
        return;
    }
    
    // Check if the entered amount exceeds the remaining amount (allowing for small floating point differences)
    if (enteredAmount > remainingAmount + 0.001) {
        alert(`Cannot allocate more than the remaining amount (${remainingAmount.toFixed(3)} OMR).`);
        input.value = remainingAmount.toFixed(3);
    }
    
    // Update the max attribute for all inputs
    updateInputMaxValues();
    updateAmountSummary();
}

function getRemainingAmount() {
    const totalAmount = parseFloat(document.getElementById('amount').value) || 0;
    const inputs = document.querySelectorAll('.payment-amount-input');
    let totalAllocated = 0;
    
    inputs.forEach(input => {
        totalAllocated += parseFloat(input.value) || 0;
    });
    
    return totalAmount - totalAllocated;
}

function updateInputMaxValues() {
    const totalAmount = parseFloat(document.getElementById('amount').value) || 0;
    const inputs = document.querySelectorAll('.payment-amount-input');
    
    inputs.forEach(input => {
        // Calculate remaining amount excluding this specific input
        const otherInputs = Array.from(inputs).filter(inp => inp !== input);
        let otherAllocated = 0;
        otherInputs.forEach(inp => {
            otherAllocated += parseFloat(inp.value) || 0;
        });
        const remainingAmount = totalAmount - otherAllocated;
        
        input.max = Math.max(0, remainingAmount);
    });
}

function updateAddButtonState() {
    const addButton = document.getElementById('addPaymentBtn');
    const remainingAmount = getRemainingAmount();
    
    // Check if the next payment would exceed the end date
    const config = document.getElementById('recurring_interval').value;
    let isEndDateExceeded = false;
    
    if (config) {
        const parts = config.split(':');
        const endDateIndex = parts.indexOf('end');
        
        if (endDateIndex !== -1 && endDateIndex + 1 < parts.length) {
            const endDate = new Date(parts[endDateIndex + 1]);
            
            // Calculate what the next payment date would be
            if (parts.length > 2 && parts[2] === 'date') {
                const baseDate = parts[3];
                const interval = parseInt(parts[1]);
                const existingPayments = document.querySelectorAll('.payment-amount-item');
                
                const nextPaymentDate = new Date(baseDate);
                nextPaymentDate.setMonth(nextPaymentDate.getMonth() + (interval * existingPayments.length));
                
                if (nextPaymentDate > endDate) {
                    isEndDateExceeded = true;
                }
            }
        }
    }
    
    if (remainingAmount <= 0) {
        addButton.disabled = true;
        addButton.innerHTML = '<i class="fas fa-plus"></i> All Amount Allocated';
        addButton.style.opacity = '0.5';
    } else if (isEndDateExceeded) {
        addButton.disabled = true;
        addButton.innerHTML = '<i class="fas fa-plus"></i> End Date Reached';
        addButton.style.opacity = '0.5';
    } else {
        addButton.disabled = false;
        addButton.innerHTML = '<i class="fas fa-plus"></i> Add Payment';
        addButton.style.opacity = '1';
    }
}

// Form validation
document.getElementById('requestForm').addEventListener('submit', function(e) {
    const accountNumber = document.getElementById('account_number').value;
    if (!/^\d+$/.test(accountNumber)) {
        e.preventDefault();
        alert('Account number must contain only numbers.');
        return false;
    }
    
    const amount = parseFloat(document.getElementById('amount').value);
    if (amount <= 0) {
        e.preventDefault();
        alert('Amount must be greater than 0.');
        return false;
    }
    
    // Check if recurring is selected but no interval is set
    const recurring = document.getElementById('recurring').value;
    const recurringInterval = document.getElementById('recurring_interval').value;
    if (recurring === 'Recurring' && !recurringInterval) {
        e.preventDefault();
        alert('Please configure the recurring payment schedule.');
        return false;
    }
});
</script>

{% endblock %}

